/* automatically generated by rust-bindgen 0.69.4 */

#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(transparent)]
pub struct __BindgenFloat16(pub u16);
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &[u8; 1] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING: u32 = 32;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const _UPPER: u32 = 1;
pub const _LOWER: u32 = 2;
pub const _DIGIT: u32 = 4;
pub const _SPACE: u32 = 8;
pub const _PUNCT: u32 = 16;
pub const _CONTROL: u32 = 32;
pub const _BLANK: u32 = 64;
pub const _HEX: u32 = 128;
pub const _LEADBYTE: u32 = 32768;
pub const _ALPHA: u32 = 259;
pub const _SH_DENYRW: u32 = 16;
pub const _SH_DENYWR: u32 = 32;
pub const _SH_DENYRD: u32 = 48;
pub const _SH_DENYNO: u32 = 64;
pub const _SH_SECURE: u32 = 128;
pub const SH_DENYRW: u32 = 16;
pub const SH_DENYWR: u32 = 32;
pub const SH_DENYRD: u32 = 48;
pub const SH_DENYNO: u32 = 64;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const _S_IFMT: u32 = 61440;
pub const _S_IFDIR: u32 = 16384;
pub const _S_IFCHR: u32 = 8192;
pub const _S_IFIFO: u32 = 4096;
pub const _S_IFREG: u32 = 32768;
pub const _S_IREAD: u32 = 256;
pub const _S_IWRITE: u32 = 128;
pub const _S_IEXEC: u32 = 64;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFREG: u32 = 32768;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const GS_MAX_TEXTURES: u32 = 8;
pub const GS_BUILD_MIPMAPS: u32 = 1;
pub const GS_DYNAMIC: u32 = 2;
pub const GS_RENDER_TARGET: u32 = 4;
pub const GS_GL_DUMMYTEX: u32 = 8;
pub const GS_DUP_BUFFER: u32 = 16;
pub const GS_SHARED_TEX: u32 = 32;
pub const GS_SHARED_KM_TEX: u32 = 64;
pub const GS_SUCCESS: u32 = 0;
pub const GS_ERROR_FAIL: i32 = -1;
pub const GS_ERROR_MODULE_NOT_FOUND: i32 = -2;
pub const GS_ERROR_NOT_SUPPORTED: i32 = -3;
pub const GS_DEVICE_OPENGL: u32 = 1;
pub const GS_DEVICE_DIRECT3D_11: u32 = 2;
pub const GS_FLIP_U: u32 = 1;
pub const GS_FLIP_V: u32 = 2;
pub const GS_CLEAR_COLOR: u32 = 1;
pub const GS_CLEAR_DEPTH: u32 = 2;
pub const GS_CLEAR_STENCIL: u32 = 4;
pub const GS_USE_DEBUG_MARKERS: u32 = 0;
pub const _DOMAIN: u32 = 1;
pub const _SING: u32 = 2;
pub const _OVERFLOW: u32 = 3;
pub const _UNDERFLOW: u32 = 4;
pub const _TLOSS: u32 = 5;
pub const _PLOSS: u32 = 6;
pub const _HUGE_ENUF : f64 = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 ;
pub const _DENORM: i32 = -2;
pub const _FINITE: i32 = -1;
pub const _INFCODE: u32 = 1;
pub const _NANCODE: u32 = 2;
pub const FP_INFINITE: u32 = 1;
pub const FP_NAN: u32 = 2;
pub const FP_NORMAL: i32 = -1;
pub const FP_SUBNORMAL: i32 = -2;
pub const FP_ZERO: u32 = 0;
pub const _C2: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: u32 = 2147483647;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const _FE_DIVBYZERO: u32 = 4;
pub const _FE_INEXACT: u32 = 32;
pub const _FE_INVALID: u32 = 1;
pub const _FE_OVERFLOW: u32 = 8;
pub const _FE_UNDERFLOW: u32 = 16;
pub const _D0_C: u32 = 3;
pub const _D1_C: u32 = 2;
pub const _D2_C: u32 = 1;
pub const _D3_C: u32 = 0;
pub const _DBIAS: u32 = 1022;
pub const _DOFF: u32 = 4;
pub const _F0_C: u32 = 1;
pub const _F1_C: u32 = 0;
pub const _FBIAS: u32 = 126;
pub const _FOFF: u32 = 7;
pub const _FRND: u32 = 1;
pub const _L0_C: u32 = 3;
pub const _L1_C: u32 = 2;
pub const _L2_C: u32 = 1;
pub const _L3_C: u32 = 0;
pub const _LBIAS: u32 = 1022;
pub const _LOFF: u32 = 4;
pub const _FP_LT: u32 = 1;
pub const _FP_EQ: u32 = 2;
pub const _FP_GT: u32 = 4;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const M_PI: f64 = 3.141592653589793;
pub const LARGE_EPSILON: f64 = 0.01;
pub const EPSILON: f64 = 0.0001;
pub const TINY_EPSILON: f64 = 0.00001;
pub const _HEAP_MAXREQ: i32 = -32;
pub const _HEAPEMPTY: i32 = -1;
pub const _HEAPOK: i32 = -2;
pub const _HEAPBADBEGIN: i32 = -3;
pub const _HEAPBADNODE: i32 = -4;
pub const _HEAPEND: i32 = -5;
pub const _HEAPBADPTR: i32 = -6;
pub const _FREEENTRY: u32 = 0;
pub const _USEDENTRY: u32 = 1;
pub const _ALLOCA_S_THRESHOLD: u32 = 1024;
pub const _ALLOCA_S_STACK_MARKER: u32 = 52428;
pub const _ALLOCA_S_HEAP_MARKER: u32 = 56797;
pub const _ALLOCA_S_MARKER_SIZE: u32 = 16;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const MAX_AV_PLANES: u32 = 8;
pub const MAX_AUDIO_MIXES: u32 = 6;
pub const MAX_AUDIO_CHANNELS: u32 = 8;
pub const MAX_DEVICE_INPUT_CHANNELS: u32 = 64;
pub const AUDIO_OUTPUT_FRAMES: u32 = 1024;
pub const AUDIO_OUTPUT_SUCCESS: u32 = 0;
pub const AUDIO_OUTPUT_INVALIDPARAM: i32 = -1;
pub const AUDIO_OUTPUT_FAIL: i32 = -2;
pub const VIDEO_OUTPUT_SUCCESS: u32 = 0;
pub const VIDEO_OUTPUT_INVALIDPARAM: i32 = -1;
pub const VIDEO_OUTPUT_FAIL: i32 = -2;
pub const CALL_PARAM_IN: u32 = 1;
pub const CALL_PARAM_OUT: u32 = 2;
pub const LIBOBS_API_MAJOR_VER: u32 = 30;
pub const LIBOBS_API_MINOR_VER: u32 = 2;
pub const LIBOBS_API_PATCH_VER: u32 = 2;
pub const OBS_VERSION: &[u8; 8] = b"unknown\0";
pub const OBS_DATA_PATH: &[u8; 11] = b"../../data\0";
pub const OBS_INSTALL_PREFIX: &[u8; 1] = b"\0";
pub const OBS_PLUGIN_DESTINATION: &[u8; 12] = b"obs-plugins\0";
pub const OBS_RELATIVE_PREFIX: &[u8; 7] = b"../../\0";
pub const OBS_RELEASE_CANDIDATE: u32 = 0;
pub const OBS_BETA: u32 = 0;
pub const OBS_INSTALL_DATA_PATH: &[u8; 12] = b"/../../data\0";
pub const MAX_CHANNELS: u32 = 64;
pub const OBS_ALIGN_CENTER: u32 = 0;
pub const OBS_ALIGN_LEFT: u32 = 1;
pub const OBS_ALIGN_RIGHT: u32 = 2;
pub const OBS_ALIGN_TOP: u32 = 4;
pub const OBS_ALIGN_BOTTOM: u32 = 8;
pub const MODULE_SUCCESS: u32 = 0;
pub const MODULE_ERROR: i32 = -1;
pub const MODULE_FILE_NOT_FOUND: i32 = -2;
pub const MODULE_MISSING_EXPORTS: i32 = -3;
pub const MODULE_INCOMPATIBLE_VER: i32 = -4;
pub const MODULE_HARDCODED_SKIP: i32 = -5;
pub const OBS_OUTPUT_SUCCESS: u32 = 0;
pub const OBS_OUTPUT_BAD_PATH: i32 = -1;
pub const OBS_OUTPUT_CONNECT_FAILED: i32 = -2;
pub const OBS_OUTPUT_INVALID_STREAM: i32 = -3;
pub const OBS_OUTPUT_ERROR: i32 = -4;
pub const OBS_OUTPUT_DISCONNECTED: i32 = -5;
pub const OBS_OUTPUT_UNSUPPORTED: i32 = -6;
pub const OBS_OUTPUT_NO_SPACE: i32 = -7;
pub const OBS_OUTPUT_ENCODE_ERROR: i32 = -8;
pub const OBS_OUTPUT_HDR_DISABLED: i32 = -9;
pub const OBS_VIDEO_SUCCESS: u32 = 0;
pub const OBS_VIDEO_FAIL: i32 = -1;
pub const OBS_VIDEO_NOT_SUPPORTED: i32 = -2;
pub const OBS_VIDEO_INVALID_PARAM: i32 = -3;
pub const OBS_VIDEO_CURRENTLY_ACTIVE: i32 = -4;
pub const OBS_VIDEO_MODULE_NOT_FOUND: i32 = -5;
pub const OBS_PROPERTIES_DEFER_UPDATE: u32 = 1;
pub const OBS_FONT_BOLD: u32 = 1;
pub const OBS_FONT_ITALIC: u32 = 2;
pub const OBS_FONT_UNDERLINE: u32 = 4;
pub const OBS_FONT_STRIKEOUT: u32 = 8;
pub const OBS_SOURCE_VIDEO: u32 = 1;
pub const OBS_SOURCE_AUDIO: u32 = 2;
pub const OBS_SOURCE_ASYNC: u32 = 4;
pub const OBS_SOURCE_ASYNC_VIDEO: u32 = 5;
pub const OBS_SOURCE_CUSTOM_DRAW: u32 = 8;
pub const OBS_SOURCE_INTERACTION: u32 = 32;
pub const OBS_SOURCE_COMPOSITE: u32 = 64;
pub const OBS_SOURCE_DO_NOT_DUPLICATE: u32 = 128;
pub const OBS_SOURCE_DEPRECATED: u32 = 256;
pub const OBS_SOURCE_DO_NOT_SELF_MONITOR: u32 = 512;
pub const OBS_SOURCE_CAP_DISABLED: u32 = 1024;
pub const OBS_SOURCE_CAP_OBSOLETE: u32 = 1024;
pub const OBS_SOURCE_MONITOR_BY_DEFAULT: u32 = 2048;
pub const OBS_SOURCE_SUBMIX: u32 = 4096;
pub const OBS_SOURCE_CONTROLLABLE_MEDIA: u32 = 8192;
pub const OBS_SOURCE_CEA_708: u32 = 16384;
pub const OBS_SOURCE_SRGB: u32 = 32768;
pub const OBS_SOURCE_CAP_DONT_SHOW_PROPERTIES: u32 = 65536;
pub const OBS_ENCODER_CAP_DEPRECATED: u32 = 1;
pub const OBS_ENCODER_CAP_PASS_TEXTURE: u32 = 2;
pub const OBS_ENCODER_CAP_DYN_BITRATE: u32 = 4;
pub const OBS_ENCODER_CAP_INTERNAL: u32 = 8;
pub const OBS_ENCODER_CAP_ROI: u32 = 16;
pub const OBS_OUTPUT_VIDEO: u32 = 1;
pub const OBS_OUTPUT_AUDIO: u32 = 2;
pub const OBS_OUTPUT_AV: u32 = 3;
pub const OBS_OUTPUT_ENCODED: u32 = 4;
pub const OBS_OUTPUT_SERVICE: u32 = 8;
pub const OBS_OUTPUT_MULTI_TRACK: u32 = 16;
pub const OBS_OUTPUT_CAN_PAUSE: u32 = 32;
pub const OBS_OUTPUT_MULTI_TRACK_AUDIO: u32 = 16;
pub const OBS_OUTPUT_MULTI_TRACK_VIDEO: u32 = 64;
pub const OBS_OUTPUT_MULTI_TRACK_AV: u32 = 80;
pub const MAX_OUTPUT_AUDIO_ENCODERS: u32 = 6;
pub const MAX_OUTPUT_VIDEO_ENCODERS: u32 = 6;
pub const XINPUT_MOUSE_LEN: u32 = 33;
pub const OBS_MOUSE_BUTTON_DEFAULT: u32 = 1;
pub const OBS_SOURCE_FRAME_LINEAR_ALPHA: u32 = 1;
pub const OBS_SOURCE_FLAG_UNUSED_1: u32 = 1;
pub const OBS_SOURCE_FLAG_FORCE_MONO: u32 = 2;
pub const OBS_OUTPUT_DELAY_PRESERVE: u32 = 1;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
pub type va_list = *mut ::std::os::raw::c_char;
pub type __vcrt_bool = bool;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type __crt_bool = bool;
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
impl Default for __crt_locale_data_public {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
impl Default for __crt_locale_pointers {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
pub type _ino_t = ::std::os::raw::c_ushort;
pub type ino_t = _ino_t;
pub type _dev_t = ::std::os::raw::c_uint;
pub type dev_t = _dev_t;
pub type _off_t = ::std::os::raw::c_long;
pub type off_t = _off_t;
pub type __gnuc_va_list = __builtin_va_list;
#[doc = " Use if there's a problem that can potentially affect the program,\n but isn't enough to require termination of the program.\n\n Use in creation functions and core subsystem functions.  Places that\n should definitely not fail."]
pub const LOG_ERROR: _bindgen_ty_1 = 100;
#[doc = " Use if a problem occurs that doesn't affect the program and is\n recoverable.\n\n Use in places where failure isn't entirely unexpected, and can\n be handled safely."]
pub const LOG_WARNING: _bindgen_ty_1 = 200;
#[doc = " Informative message to be displayed in the log."]
pub const LOG_INFO: _bindgen_ty_1 = 300;
#[doc = " Debug message to be used mostly by developers."]
pub const LOG_DEBUG: _bindgen_ty_1 = 400;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub type log_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        lvl: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
        args: va_list,
        p: *mut ::std::os::raw::c_void,
    ),
>;
pub type _fsize_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _wfinddata32_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time32_t,
    pub time_access: __time32_t,
    pub time_write: __time32_t,
    pub size: _fsize_t,
    pub name: [wchar_t; 260usize],
}
impl Default for _wfinddata32_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _wfinddata32i64_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time32_t,
    pub time_access: __time32_t,
    pub time_write: __time32_t,
    pub size: ::std::os::raw::c_longlong,
    pub name: [wchar_t; 260usize],
}
impl Default for _wfinddata32i64_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _wfinddata64i32_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time64_t,
    pub time_access: __time64_t,
    pub time_write: __time64_t,
    pub size: _fsize_t,
    pub name: [wchar_t; 260usize],
}
impl Default for _wfinddata64i32_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _wfinddata64_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time64_t,
    pub time_access: __time64_t,
    pub time_write: __time64_t,
    pub size: ::std::os::raw::c_longlong,
    pub name: [wchar_t; 260usize],
}
impl Default for _wfinddata64_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
impl Default for _iobuf {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FILE = _iobuf;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _stat32 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: __time32_t,
    pub st_mtime: __time32_t,
    pub st_ctime: __time32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _stat32i64 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: ::std::os::raw::c_longlong,
    pub st_atime: __time32_t,
    pub st_mtime: __time32_t,
    pub st_ctime: __time32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _stat64i32 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: __time64_t,
    pub st_mtime: __time64_t,
    pub st_ctime: __time64_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _stat64 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: ::std::os::raw::c_longlong,
    pub st_atime: __time64_t,
    pub st_mtime: __time64_t,
    pub st_ctime: __time64_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct stat {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: time_t,
    pub st_mtime: time_t,
    pub st_ctime: time_t,
}
pub type _Wint_t = wchar_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct base_allocator {
    pub malloc: ::std::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void>,
    pub realloc: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: usize) -> *mut ::std::os::raw::c_void,
    >,
    pub free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
pub type lldiv_t = _lldiv_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct darray {
    pub array: *mut ::std::os::raw::c_void,
    pub num: usize,
    pub capacity: usize,
}
impl Default for darray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct profiler_snapshot {
    _unused: [u8; 0],
}
pub type profiler_snapshot_t = profiler_snapshot;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct profiler_snapshot_entry {
    _unused: [u8; 0],
}
pub type profiler_snapshot_entry_t = profiler_snapshot_entry;
pub type profiler_time_entry_t = profiler_time_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct profiler_name_store {
    _unused: [u8; 0],
}
pub type profiler_name_store_t = profiler_name_store;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct profiler_time_entry {
    pub time_delta: u64,
    pub count: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union profiler_time_entries_t {
    pub da: darray,
    pub __bindgen_anon_1: profiler_time_entries_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct profiler_time_entries_t__bindgen_ty_1 {
    pub array: *mut profiler_time_entry_t,
    pub num: usize,
    pub capacity: usize,
}
impl Default for profiler_time_entries_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for profiler_time_entries_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type profiler_entry_enum_func = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, entry: *mut profiler_snapshot_entry_t) -> bool,
>;
pub type profiler_name_filter_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        remove: *mut bool,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct text_lookup {
    _unused: [u8; 0],
}
pub type lookup_t = text_lookup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct input_subsystem {
    _unused: [u8; 0],
}
pub type input_t = input_subsystem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct axisang {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plane {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matrix3 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matrix4 {
    _unused: [u8; 0],
}
pub const gs_draw_mode_GS_POINTS: gs_draw_mode = 0;
pub const gs_draw_mode_GS_LINES: gs_draw_mode = 1;
pub const gs_draw_mode_GS_LINESTRIP: gs_draw_mode = 2;
pub const gs_draw_mode_GS_TRIS: gs_draw_mode = 3;
pub const gs_draw_mode_GS_TRISTRIP: gs_draw_mode = 4;
pub type gs_draw_mode = ::std::os::raw::c_int;
pub const gs_color_format_GS_UNKNOWN: gs_color_format = 0;
pub const gs_color_format_GS_A8: gs_color_format = 1;
pub const gs_color_format_GS_R8: gs_color_format = 2;
pub const gs_color_format_GS_RGBA: gs_color_format = 3;
pub const gs_color_format_GS_BGRX: gs_color_format = 4;
pub const gs_color_format_GS_BGRA: gs_color_format = 5;
pub const gs_color_format_GS_R10G10B10A2: gs_color_format = 6;
pub const gs_color_format_GS_RGBA16: gs_color_format = 7;
pub const gs_color_format_GS_R16: gs_color_format = 8;
pub const gs_color_format_GS_RGBA16F: gs_color_format = 9;
pub const gs_color_format_GS_RGBA32F: gs_color_format = 10;
pub const gs_color_format_GS_RG16F: gs_color_format = 11;
pub const gs_color_format_GS_RG32F: gs_color_format = 12;
pub const gs_color_format_GS_R16F: gs_color_format = 13;
pub const gs_color_format_GS_R32F: gs_color_format = 14;
pub const gs_color_format_GS_DXT1: gs_color_format = 15;
pub const gs_color_format_GS_DXT3: gs_color_format = 16;
pub const gs_color_format_GS_DXT5: gs_color_format = 17;
pub const gs_color_format_GS_R8G8: gs_color_format = 18;
pub const gs_color_format_GS_RGBA_UNORM: gs_color_format = 19;
pub const gs_color_format_GS_BGRX_UNORM: gs_color_format = 20;
pub const gs_color_format_GS_BGRA_UNORM: gs_color_format = 21;
pub const gs_color_format_GS_RG16: gs_color_format = 22;
pub type gs_color_format = ::std::os::raw::c_int;
pub const gs_color_space_GS_CS_SRGB: gs_color_space = 0;
pub const gs_color_space_GS_CS_SRGB_16F: gs_color_space = 1;
pub const gs_color_space_GS_CS_709_EXTENDED: gs_color_space = 2;
pub const gs_color_space_GS_CS_709_SCRGB: gs_color_space = 3;
pub type gs_color_space = ::std::os::raw::c_int;
pub const gs_zstencil_format_GS_ZS_NONE: gs_zstencil_format = 0;
pub const gs_zstencil_format_GS_Z16: gs_zstencil_format = 1;
pub const gs_zstencil_format_GS_Z24_S8: gs_zstencil_format = 2;
pub const gs_zstencil_format_GS_Z32F: gs_zstencil_format = 3;
pub const gs_zstencil_format_GS_Z32F_S8X24: gs_zstencil_format = 4;
pub type gs_zstencil_format = ::std::os::raw::c_int;
pub const gs_index_type_GS_UNSIGNED_SHORT: gs_index_type = 0;
pub const gs_index_type_GS_UNSIGNED_LONG: gs_index_type = 1;
pub type gs_index_type = ::std::os::raw::c_int;
pub const gs_cull_mode_GS_BACK: gs_cull_mode = 0;
pub const gs_cull_mode_GS_FRONT: gs_cull_mode = 1;
pub const gs_cull_mode_GS_NEITHER: gs_cull_mode = 2;
pub type gs_cull_mode = ::std::os::raw::c_int;
pub const gs_blend_type_GS_BLEND_ZERO: gs_blend_type = 0;
pub const gs_blend_type_GS_BLEND_ONE: gs_blend_type = 1;
pub const gs_blend_type_GS_BLEND_SRCCOLOR: gs_blend_type = 2;
pub const gs_blend_type_GS_BLEND_INVSRCCOLOR: gs_blend_type = 3;
pub const gs_blend_type_GS_BLEND_SRCALPHA: gs_blend_type = 4;
pub const gs_blend_type_GS_BLEND_INVSRCALPHA: gs_blend_type = 5;
pub const gs_blend_type_GS_BLEND_DSTCOLOR: gs_blend_type = 6;
pub const gs_blend_type_GS_BLEND_INVDSTCOLOR: gs_blend_type = 7;
pub const gs_blend_type_GS_BLEND_DSTALPHA: gs_blend_type = 8;
pub const gs_blend_type_GS_BLEND_INVDSTALPHA: gs_blend_type = 9;
pub const gs_blend_type_GS_BLEND_SRCALPHASAT: gs_blend_type = 10;
pub type gs_blend_type = ::std::os::raw::c_int;
pub const gs_blend_op_type_GS_BLEND_OP_ADD: gs_blend_op_type = 0;
pub const gs_blend_op_type_GS_BLEND_OP_SUBTRACT: gs_blend_op_type = 1;
pub const gs_blend_op_type_GS_BLEND_OP_REVERSE_SUBTRACT: gs_blend_op_type = 2;
pub const gs_blend_op_type_GS_BLEND_OP_MIN: gs_blend_op_type = 3;
pub const gs_blend_op_type_GS_BLEND_OP_MAX: gs_blend_op_type = 4;
pub type gs_blend_op_type = ::std::os::raw::c_int;
pub const gs_depth_test_GS_NEVER: gs_depth_test = 0;
pub const gs_depth_test_GS_LESS: gs_depth_test = 1;
pub const gs_depth_test_GS_LEQUAL: gs_depth_test = 2;
pub const gs_depth_test_GS_EQUAL: gs_depth_test = 3;
pub const gs_depth_test_GS_GEQUAL: gs_depth_test = 4;
pub const gs_depth_test_GS_GREATER: gs_depth_test = 5;
pub const gs_depth_test_GS_NOTEQUAL: gs_depth_test = 6;
pub const gs_depth_test_GS_ALWAYS: gs_depth_test = 7;
pub type gs_depth_test = ::std::os::raw::c_int;
pub const gs_stencil_side_GS_STENCIL_FRONT: gs_stencil_side = 1;
pub const gs_stencil_side_GS_STENCIL_BACK: gs_stencil_side = 2;
pub const gs_stencil_side_GS_STENCIL_BOTH: gs_stencil_side = 3;
pub type gs_stencil_side = ::std::os::raw::c_int;
pub const gs_stencil_op_type_GS_KEEP: gs_stencil_op_type = 0;
pub const gs_stencil_op_type_GS_ZERO: gs_stencil_op_type = 1;
pub const gs_stencil_op_type_GS_REPLACE: gs_stencil_op_type = 2;
pub const gs_stencil_op_type_GS_INCR: gs_stencil_op_type = 3;
pub const gs_stencil_op_type_GS_DECR: gs_stencil_op_type = 4;
pub const gs_stencil_op_type_GS_INVERT: gs_stencil_op_type = 5;
pub type gs_stencil_op_type = ::std::os::raw::c_int;
pub const gs_cube_sides_GS_POSITIVE_X: gs_cube_sides = 0;
pub const gs_cube_sides_GS_NEGATIVE_X: gs_cube_sides = 1;
pub const gs_cube_sides_GS_POSITIVE_Y: gs_cube_sides = 2;
pub const gs_cube_sides_GS_NEGATIVE_Y: gs_cube_sides = 3;
pub const gs_cube_sides_GS_POSITIVE_Z: gs_cube_sides = 4;
pub const gs_cube_sides_GS_NEGATIVE_Z: gs_cube_sides = 5;
pub type gs_cube_sides = ::std::os::raw::c_int;
pub const gs_sample_filter_GS_FILTER_POINT: gs_sample_filter = 0;
pub const gs_sample_filter_GS_FILTER_LINEAR: gs_sample_filter = 1;
pub const gs_sample_filter_GS_FILTER_ANISOTROPIC: gs_sample_filter = 2;
pub const gs_sample_filter_GS_FILTER_MIN_MAG_POINT_MIP_LINEAR: gs_sample_filter = 3;
pub const gs_sample_filter_GS_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT: gs_sample_filter = 4;
pub const gs_sample_filter_GS_FILTER_MIN_POINT_MAG_MIP_LINEAR: gs_sample_filter = 5;
pub const gs_sample_filter_GS_FILTER_MIN_LINEAR_MAG_MIP_POINT: gs_sample_filter = 6;
pub const gs_sample_filter_GS_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR: gs_sample_filter = 7;
pub const gs_sample_filter_GS_FILTER_MIN_MAG_LINEAR_MIP_POINT: gs_sample_filter = 8;
pub type gs_sample_filter = ::std::os::raw::c_int;
pub const gs_address_mode_GS_ADDRESS_CLAMP: gs_address_mode = 0;
pub const gs_address_mode_GS_ADDRESS_WRAP: gs_address_mode = 1;
pub const gs_address_mode_GS_ADDRESS_MIRROR: gs_address_mode = 2;
pub const gs_address_mode_GS_ADDRESS_BORDER: gs_address_mode = 3;
pub const gs_address_mode_GS_ADDRESS_MIRRORONCE: gs_address_mode = 4;
pub type gs_address_mode = ::std::os::raw::c_int;
pub const gs_texture_type_GS_TEXTURE_2D: gs_texture_type = 0;
pub const gs_texture_type_GS_TEXTURE_3D: gs_texture_type = 1;
pub const gs_texture_type_GS_TEXTURE_CUBE: gs_texture_type = 2;
pub type gs_texture_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct gs_device_loss {
    pub device_loss_release: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub device_loss_rebuild: ::std::option::Option<
        unsafe extern "C" fn(device: *mut ::std::os::raw::c_void, data: *mut ::std::os::raw::c_void),
    >,
    pub data: *mut ::std::os::raw::c_void,
}
impl Default for gs_device_loss {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct gs_monitor_info {
    pub rotation_degrees: ::std::os::raw::c_int,
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
    pub cx: ::std::os::raw::c_long,
    pub cy: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct gs_tvertarray {
    pub width: usize,
    pub array: *mut ::std::os::raw::c_void,
}
impl Default for gs_tvertarray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct gs_vb_data {
    pub num: usize,
    pub points: *mut vec3,
    pub normals: *mut vec3,
    pub tangents: *mut vec3,
    pub colors: *mut u32,
    pub num_tex: usize,
    pub tvarray: *mut gs_tvertarray,
}
impl Default for gs_vb_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct gs_sampler_info {
    pub filter: gs_sample_filter,
    pub address_u: gs_address_mode,
    pub address_v: gs_address_mode,
    pub address_w: gs_address_mode,
    pub max_anisotropy: ::std::os::raw::c_int,
    pub border_color: u32,
}
impl Default for gs_sampler_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct gs_display_mode {
    pub width: u32,
    pub height: u32,
    pub bits: u32,
    pub freq: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct gs_rect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub cx: ::std::os::raw::c_int,
    pub cy: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_texture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_stage_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_zstencil_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_vertex_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_index_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_sampler_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_shader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_swap_chain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_timer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_texrender {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_shader_param {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_effect {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_effect_technique {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_effect_pass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_effect_param {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct graphics_subsystem {
    _unused: [u8; 0],
}
pub type gs_texture_t = gs_texture;
pub type gs_stagesurf_t = gs_stage_surface;
pub type gs_zstencil_t = gs_zstencil_buffer;
pub type gs_vertbuffer_t = gs_vertex_buffer;
pub type gs_indexbuffer_t = gs_index_buffer;
pub type gs_samplerstate_t = gs_sampler_state;
pub type gs_swapchain_t = gs_swap_chain;
pub type gs_timer_t = gs_timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_timer_range {
    _unused: [u8; 0],
}
pub type gs_timer_range_t = gs_timer_range;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_texture_render {
    _unused: [u8; 0],
}
pub type gs_texrender_t = gs_texture_render;
pub type gs_shader_t = gs_shader;
pub type gs_sparam_t = gs_shader_param;
pub type gs_effect_t = gs_effect;
pub type gs_technique_t = gs_effect_technique;
pub type gs_epass_t = gs_effect_pass;
pub type gs_eparam_t = gs_effect_param;
pub type gs_device_t = gs_device;
pub type graphics_t = graphics_subsystem;
pub const gs_shader_param_type_GS_SHADER_PARAM_UNKNOWN: gs_shader_param_type = 0;
pub const gs_shader_param_type_GS_SHADER_PARAM_BOOL: gs_shader_param_type = 1;
pub const gs_shader_param_type_GS_SHADER_PARAM_FLOAT: gs_shader_param_type = 2;
pub const gs_shader_param_type_GS_SHADER_PARAM_INT: gs_shader_param_type = 3;
pub const gs_shader_param_type_GS_SHADER_PARAM_STRING: gs_shader_param_type = 4;
pub const gs_shader_param_type_GS_SHADER_PARAM_VEC2: gs_shader_param_type = 5;
pub const gs_shader_param_type_GS_SHADER_PARAM_VEC3: gs_shader_param_type = 6;
pub const gs_shader_param_type_GS_SHADER_PARAM_VEC4: gs_shader_param_type = 7;
pub const gs_shader_param_type_GS_SHADER_PARAM_INT2: gs_shader_param_type = 8;
pub const gs_shader_param_type_GS_SHADER_PARAM_INT3: gs_shader_param_type = 9;
pub const gs_shader_param_type_GS_SHADER_PARAM_INT4: gs_shader_param_type = 10;
pub const gs_shader_param_type_GS_SHADER_PARAM_MATRIX4X4: gs_shader_param_type = 11;
pub const gs_shader_param_type_GS_SHADER_PARAM_TEXTURE: gs_shader_param_type = 12;
pub type gs_shader_param_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct gs_shader_texture {
    pub tex: *mut gs_texture_t,
    pub srgb: bool,
}
impl Default for gs_shader_texture {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct gs_shader_param_info {
    pub type_: gs_shader_param_type,
    pub name: *const ::std::os::raw::c_char,
}
impl Default for gs_shader_param_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const gs_shader_type_GS_SHADER_VERTEX: gs_shader_type = 0;
pub const gs_shader_type_GS_SHADER_PIXEL: gs_shader_type = 1;
pub type gs_shader_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct gs_effect_param_info {
    pub name: *const ::std::os::raw::c_char,
    pub type_: gs_shader_param_type,
}
impl Default for gs_effect_param_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct gs_window {
    pub hwnd: *mut ::std::os::raw::c_void,
}
impl Default for gs_window {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct gs_init_data {
    pub window: gs_window,
    pub cx: u32,
    pub cy: u32,
    pub num_backbuffers: u32,
    pub format: gs_color_format,
    pub zsformat: gs_zstencil_format,
    pub adapter: u32,
}
impl Default for gs_init_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const gs_image_alpha_mode_GS_IMAGE_ALPHA_STRAIGHT: gs_image_alpha_mode = 0;
pub const gs_image_alpha_mode_GS_IMAGE_ALPHA_PREMULTIPLY_SRGB: gs_image_alpha_mode = 1;
pub const gs_image_alpha_mode_GS_IMAGE_ALPHA_PREMULTIPLY: gs_image_alpha_mode = 2;
pub type gs_image_alpha_mode = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_duplicator {
    _unused: [u8; 0],
}
pub type gs_duplicator_t = gs_duplicator;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct _exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
impl Default for _exception {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct _complex {
    pub x: f64,
    pub y: f64,
}
pub type float_t = f32;
pub type double_t = f64;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _double_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
}
impl Default for _double_val {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_val {
    pub _Sh: [::std::os::raw::c_ushort; 2usize],
    pub _Val: f32,
}
impl Default for _float_val {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ldouble_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
}
impl Default for _ldouble_val {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_const {
    pub _Word: [::std::os::raw::c_ushort; 4usize],
    pub _Float: f32,
    pub _Double: f64,
    pub _Long_double: f64,
}
impl Default for _float_const {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vec2 {
    pub __bindgen_anon_1: vec2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vec2__bindgen_ty_1 {
    pub __bindgen_anon_1: vec2__bindgen_ty_1__bindgen_ty_1,
    pub ptr: [f32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct vec2__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
}
impl Default for vec2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vec2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct _heapinfo {
    pub _pentry: *mut ::std::os::raw::c_int,
    pub _size: usize,
    pub _useflag: ::std::os::raw::c_int,
}
impl Default for _heapinfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _HEAPINFO = _heapinfo;
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
pub type __v8hf = [__BindgenFloat16; 8usize];
pub type __m128h = [__BindgenFloat16; 8usize];
pub type __m128h_u = [__BindgenFloat16; 8usize];
pub type __v8bf = u128;
pub type __m128bh = u128;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct vec4 {
    pub __bindgen_anon_1: vec4__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union vec4__bindgen_ty_1 {
    pub __bindgen_anon_1: vec4__bindgen_ty_1__bindgen_ty_1,
    pub ptr: [f32; 4usize],
    pub m: __m128,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct vec4__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
impl Default for vec4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vec4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct vec3 {
    pub __bindgen_anon_1: vec3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union vec3__bindgen_ty_1 {
    pub __bindgen_anon_1: vec3__bindgen_ty_1__bindgen_ty_1,
    pub ptr: [f32; 4usize],
    pub m: __m128,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct vec3__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
impl Default for vec3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vec3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_output {
    _unused: [u8; 0],
}
pub type audio_t = audio_output;
pub const audio_format_AUDIO_FORMAT_UNKNOWN: audio_format = 0;
pub const audio_format_AUDIO_FORMAT_U8BIT: audio_format = 1;
pub const audio_format_AUDIO_FORMAT_16BIT: audio_format = 2;
pub const audio_format_AUDIO_FORMAT_32BIT: audio_format = 3;
pub const audio_format_AUDIO_FORMAT_FLOAT: audio_format = 4;
pub const audio_format_AUDIO_FORMAT_U8BIT_PLANAR: audio_format = 5;
pub const audio_format_AUDIO_FORMAT_16BIT_PLANAR: audio_format = 6;
pub const audio_format_AUDIO_FORMAT_32BIT_PLANAR: audio_format = 7;
pub const audio_format_AUDIO_FORMAT_FLOAT_PLANAR: audio_format = 8;
pub type audio_format = ::std::os::raw::c_int;
#[doc = "< Unknown setting, fallback is stereo."]
pub const speaker_layout_SPEAKERS_UNKNOWN: speaker_layout = 0;
#[doc = "< Channels: MONO"]
pub const speaker_layout_SPEAKERS_MONO: speaker_layout = 1;
#[doc = "< Channels: FL, FR"]
pub const speaker_layout_SPEAKERS_STEREO: speaker_layout = 2;
#[doc = "< Channels: FL, FR, LFE"]
pub const speaker_layout_SPEAKERS_2POINT1: speaker_layout = 3;
#[doc = "< Channels: FL, FR, FC, RC"]
pub const speaker_layout_SPEAKERS_4POINT0: speaker_layout = 4;
#[doc = "< Channels: FL, FR, FC, LFE, RC"]
pub const speaker_layout_SPEAKERS_4POINT1: speaker_layout = 5;
#[doc = "< Channels: FL, FR, FC, LFE, RL, RR"]
pub const speaker_layout_SPEAKERS_5POINT1: speaker_layout = 6;
#[doc = "< Channels: FL, FR, FC, LFE, RL, RR, SL, SR"]
pub const speaker_layout_SPEAKERS_7POINT1: speaker_layout = 8;
#[doc = " The speaker layout describes where the speakers are located in the room.\n For OBS it dictates:\n  *  how many channels are available and\n  *  which channels are used for which speakers.\n\n Standard channel layouts where retrieved from ffmpeg documentation at:\n     https://trac.ffmpeg.org/wiki/AudioChannelManipulation"]
pub type speaker_layout = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct audio_data {
    pub data: [*mut u8; 8usize],
    pub frames: u32,
    pub timestamp: u64,
}
impl Default for audio_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct audio_output_data {
    pub data: [*mut f32; 8usize],
}
impl Default for audio_output_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type audio_input_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        param: *mut ::std::os::raw::c_void,
        start_ts: u64,
        end_ts: u64,
        new_ts: *mut u64,
        active_mixers: u32,
        mixes: *mut audio_output_data,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct audio_output_info {
    pub name: *const ::std::os::raw::c_char,
    pub samples_per_sec: u32,
    pub format: audio_format,
    pub speakers: speaker_layout,
    pub input_callback: audio_input_callback_t,
    pub input_param: *mut ::std::os::raw::c_void,
}
impl Default for audio_output_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct audio_convert_info {
    pub samples_per_sec: u32,
    pub format: audio_format,
    pub speakers: speaker_layout,
    pub allow_clipping: bool,
}
impl Default for audio_convert_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type audio_output_callback_t = ::std::option::Option<
    unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, mix_idx: usize, data: *mut audio_data),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_frame {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_output {
    _unused: [u8; 0],
}
pub type video_t = video_output;
pub const video_format_VIDEO_FORMAT_NONE: video_format = 0;
pub const video_format_VIDEO_FORMAT_I420: video_format = 1;
pub const video_format_VIDEO_FORMAT_NV12: video_format = 2;
pub const video_format_VIDEO_FORMAT_YVYU: video_format = 3;
pub const video_format_VIDEO_FORMAT_YUY2: video_format = 4;
pub const video_format_VIDEO_FORMAT_UYVY: video_format = 5;
pub const video_format_VIDEO_FORMAT_RGBA: video_format = 6;
pub const video_format_VIDEO_FORMAT_BGRA: video_format = 7;
pub const video_format_VIDEO_FORMAT_BGRX: video_format = 8;
pub const video_format_VIDEO_FORMAT_Y800: video_format = 9;
pub const video_format_VIDEO_FORMAT_I444: video_format = 10;
pub const video_format_VIDEO_FORMAT_BGR3: video_format = 11;
pub const video_format_VIDEO_FORMAT_I422: video_format = 12;
pub const video_format_VIDEO_FORMAT_I40A: video_format = 13;
pub const video_format_VIDEO_FORMAT_I42A: video_format = 14;
pub const video_format_VIDEO_FORMAT_YUVA: video_format = 15;
pub const video_format_VIDEO_FORMAT_AYUV: video_format = 16;
pub const video_format_VIDEO_FORMAT_I010: video_format = 17;
pub const video_format_VIDEO_FORMAT_P010: video_format = 18;
pub const video_format_VIDEO_FORMAT_I210: video_format = 19;
pub const video_format_VIDEO_FORMAT_I412: video_format = 20;
pub const video_format_VIDEO_FORMAT_YA2L: video_format = 21;
pub const video_format_VIDEO_FORMAT_P216: video_format = 22;
pub const video_format_VIDEO_FORMAT_P416: video_format = 23;
pub const video_format_VIDEO_FORMAT_V210: video_format = 24;
pub const video_format_VIDEO_FORMAT_R10L: video_format = 25;
pub type video_format = ::std::os::raw::c_int;
pub const video_trc_VIDEO_TRC_DEFAULT: video_trc = 0;
pub const video_trc_VIDEO_TRC_SRGB: video_trc = 1;
pub const video_trc_VIDEO_TRC_PQ: video_trc = 2;
pub const video_trc_VIDEO_TRC_HLG: video_trc = 3;
pub type video_trc = ::std::os::raw::c_int;
pub const video_colorspace_VIDEO_CS_DEFAULT: video_colorspace = 0;
pub const video_colorspace_VIDEO_CS_601: video_colorspace = 1;
pub const video_colorspace_VIDEO_CS_709: video_colorspace = 2;
pub const video_colorspace_VIDEO_CS_SRGB: video_colorspace = 3;
pub const video_colorspace_VIDEO_CS_2100_PQ: video_colorspace = 4;
pub const video_colorspace_VIDEO_CS_2100_HLG: video_colorspace = 5;
pub type video_colorspace = ::std::os::raw::c_int;
pub const video_range_type_VIDEO_RANGE_DEFAULT: video_range_type = 0;
pub const video_range_type_VIDEO_RANGE_PARTIAL: video_range_type = 1;
pub const video_range_type_VIDEO_RANGE_FULL: video_range_type = 2;
pub type video_range_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct video_data {
    pub data: [*mut u8; 8usize],
    pub linesize: [u32; 8usize],
    pub timestamp: u64,
}
impl Default for video_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct video_output_info {
    pub name: *const ::std::os::raw::c_char,
    pub format: video_format,
    pub fps_num: u32,
    pub fps_den: u32,
    pub width: u32,
    pub height: u32,
    pub cache_size: usize,
    pub colorspace: video_colorspace,
    pub range: video_range_type,
}
impl Default for video_output_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const video_scale_type_VIDEO_SCALE_DEFAULT: video_scale_type = 0;
pub const video_scale_type_VIDEO_SCALE_POINT: video_scale_type = 1;
pub const video_scale_type_VIDEO_SCALE_FAST_BILINEAR: video_scale_type = 2;
pub const video_scale_type_VIDEO_SCALE_BILINEAR: video_scale_type = 3;
pub const video_scale_type_VIDEO_SCALE_BICUBIC: video_scale_type = 4;
pub type video_scale_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct video_scale_info {
    pub format: video_format,
    pub width: u32,
    pub height: u32,
    pub range: video_range_type,
    pub colorspace: video_colorspace,
}
impl Default for video_scale_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const call_param_type_CALL_PARAM_TYPE_VOID: call_param_type = 0;
pub const call_param_type_CALL_PARAM_TYPE_INT: call_param_type = 1;
pub const call_param_type_CALL_PARAM_TYPE_FLOAT: call_param_type = 2;
pub const call_param_type_CALL_PARAM_TYPE_BOOL: call_param_type = 3;
pub const call_param_type_CALL_PARAM_TYPE_PTR: call_param_type = 4;
pub const call_param_type_CALL_PARAM_TYPE_STRING: call_param_type = 5;
pub type call_param_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct calldata {
    pub stack: *mut u8,
    pub size: usize,
    pub capacity: usize,
    pub fixed: bool,
}
impl Default for calldata {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type calldata_t = calldata;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_handler {
    _unused: [u8; 0],
}
pub type signal_handler_t = signal_handler;
pub type global_signal_callback_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *const ::std::os::raw::c_char, arg3: *mut calldata_t),
>;
pub type signal_callback_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut calldata_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_handler {
    _unused: [u8; 0],
}
pub type proc_handler_t = proc_handler;
pub type proc_handler_proc_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut calldata_t)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct media_frames_per_second {
    pub numerator: u32,
    pub denominator: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_data_item {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_data_array {
    _unused: [u8; 0],
}
pub type obs_data_t = obs_data;
pub type obs_data_item_t = obs_data_item;
pub type obs_data_array_t = obs_data_array;
pub const obs_data_type_OBS_DATA_NULL: obs_data_type = 0;
pub const obs_data_type_OBS_DATA_STRING: obs_data_type = 1;
pub const obs_data_type_OBS_DATA_NUMBER: obs_data_type = 2;
pub const obs_data_type_OBS_DATA_BOOLEAN: obs_data_type = 3;
pub const obs_data_type_OBS_DATA_OBJECT: obs_data_type = 4;
pub const obs_data_type_OBS_DATA_ARRAY: obs_data_type = 5;
pub type obs_data_type = ::std::os::raw::c_int;
pub const obs_data_number_type_OBS_DATA_NUM_INVALID: obs_data_number_type = 0;
pub const obs_data_number_type_OBS_DATA_NUM_INT: obs_data_number_type = 1;
pub const obs_data_number_type_OBS_DATA_NUM_DOUBLE: obs_data_number_type = 2;
pub type obs_data_number_type = ::std::os::raw::c_int;
pub const obs_property_type_OBS_PROPERTY_INVALID: obs_property_type = 0;
pub const obs_property_type_OBS_PROPERTY_BOOL: obs_property_type = 1;
pub const obs_property_type_OBS_PROPERTY_INT: obs_property_type = 2;
pub const obs_property_type_OBS_PROPERTY_FLOAT: obs_property_type = 3;
pub const obs_property_type_OBS_PROPERTY_TEXT: obs_property_type = 4;
pub const obs_property_type_OBS_PROPERTY_PATH: obs_property_type = 5;
pub const obs_property_type_OBS_PROPERTY_LIST: obs_property_type = 6;
pub const obs_property_type_OBS_PROPERTY_COLOR: obs_property_type = 7;
pub const obs_property_type_OBS_PROPERTY_BUTTON: obs_property_type = 8;
pub const obs_property_type_OBS_PROPERTY_FONT: obs_property_type = 9;
pub const obs_property_type_OBS_PROPERTY_EDITABLE_LIST: obs_property_type = 10;
pub const obs_property_type_OBS_PROPERTY_FRAME_RATE: obs_property_type = 11;
pub const obs_property_type_OBS_PROPERTY_GROUP: obs_property_type = 12;
pub const obs_property_type_OBS_PROPERTY_COLOR_ALPHA: obs_property_type = 13;
pub type obs_property_type = ::std::os::raw::c_int;
pub const obs_combo_format_OBS_COMBO_FORMAT_INVALID: obs_combo_format = 0;
pub const obs_combo_format_OBS_COMBO_FORMAT_INT: obs_combo_format = 1;
pub const obs_combo_format_OBS_COMBO_FORMAT_FLOAT: obs_combo_format = 2;
pub const obs_combo_format_OBS_COMBO_FORMAT_STRING: obs_combo_format = 3;
pub const obs_combo_format_OBS_COMBO_FORMAT_BOOL: obs_combo_format = 4;
pub type obs_combo_format = ::std::os::raw::c_int;
pub const obs_combo_type_OBS_COMBO_TYPE_INVALID: obs_combo_type = 0;
pub const obs_combo_type_OBS_COMBO_TYPE_EDITABLE: obs_combo_type = 1;
pub const obs_combo_type_OBS_COMBO_TYPE_LIST: obs_combo_type = 2;
pub const obs_combo_type_OBS_COMBO_TYPE_RADIO: obs_combo_type = 3;
pub type obs_combo_type = ::std::os::raw::c_int;
pub const obs_editable_list_type_OBS_EDITABLE_LIST_TYPE_STRINGS: obs_editable_list_type = 0;
pub const obs_editable_list_type_OBS_EDITABLE_LIST_TYPE_FILES: obs_editable_list_type = 1;
pub const obs_editable_list_type_OBS_EDITABLE_LIST_TYPE_FILES_AND_URLS: obs_editable_list_type = 2;
pub type obs_editable_list_type = ::std::os::raw::c_int;
pub const obs_path_type_OBS_PATH_FILE: obs_path_type = 0;
pub const obs_path_type_OBS_PATH_FILE_SAVE: obs_path_type = 1;
pub const obs_path_type_OBS_PATH_DIRECTORY: obs_path_type = 2;
pub type obs_path_type = ::std::os::raw::c_int;
pub const obs_text_type_OBS_TEXT_DEFAULT: obs_text_type = 0;
pub const obs_text_type_OBS_TEXT_PASSWORD: obs_text_type = 1;
pub const obs_text_type_OBS_TEXT_MULTILINE: obs_text_type = 2;
pub const obs_text_type_OBS_TEXT_INFO: obs_text_type = 3;
pub type obs_text_type = ::std::os::raw::c_int;
pub const obs_text_info_type_OBS_TEXT_INFO_NORMAL: obs_text_info_type = 0;
pub const obs_text_info_type_OBS_TEXT_INFO_WARNING: obs_text_info_type = 1;
pub const obs_text_info_type_OBS_TEXT_INFO_ERROR: obs_text_info_type = 2;
pub type obs_text_info_type = ::std::os::raw::c_int;
pub const obs_number_type_OBS_NUMBER_SCROLLER: obs_number_type = 0;
pub const obs_number_type_OBS_NUMBER_SLIDER: obs_number_type = 1;
pub type obs_number_type = ::std::os::raw::c_int;
pub const obs_group_type_OBS_COMBO_INVALID: obs_group_type = 0;
pub const obs_group_type_OBS_GROUP_NORMAL: obs_group_type = 1;
pub const obs_group_type_OBS_GROUP_CHECKABLE: obs_group_type = 2;
pub type obs_group_type = ::std::os::raw::c_int;
pub const obs_button_type_OBS_BUTTON_DEFAULT: obs_button_type = 0;
pub const obs_button_type_OBS_BUTTON_URL: obs_button_type = 1;
pub type obs_button_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_properties {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_property {
    _unused: [u8; 0],
}
pub type obs_properties_t = obs_properties;
pub type obs_property_t = obs_property;
#[doc = " Callback for when a button property is clicked.  If the properties\n need to be refreshed due to changes to the property layout, return true,\n otherwise return false."]
pub type obs_property_clicked_t = ::std::option::Option<
    unsafe extern "C" fn(
        props: *mut obs_properties_t,
        property: *mut obs_property_t,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " Optional callback for when a property is modified.  If the properties\n need to be refreshed due to changes to the property layout, return true,\n otherwise return false."]
pub type obs_property_modified_t = ::std::option::Option<
    unsafe extern "C" fn(
        props: *mut obs_properties_t,
        property: *mut obs_property_t,
        settings: *mut obs_data_t,
    ) -> bool,
>;
pub type obs_property_modified2_t = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        props: *mut obs_properties_t,
        property: *mut obs_property_t,
        settings: *mut obs_data_t,
    ) -> bool,
>;
pub const obs_interaction_flags_INTERACT_NONE: obs_interaction_flags = 0;
pub const obs_interaction_flags_INTERACT_CAPS_KEY: obs_interaction_flags = 1;
pub const obs_interaction_flags_INTERACT_SHIFT_KEY: obs_interaction_flags = 2;
pub const obs_interaction_flags_INTERACT_CONTROL_KEY: obs_interaction_flags = 4;
pub const obs_interaction_flags_INTERACT_ALT_KEY: obs_interaction_flags = 8;
pub const obs_interaction_flags_INTERACT_MOUSE_LEFT: obs_interaction_flags = 16;
pub const obs_interaction_flags_INTERACT_MOUSE_MIDDLE: obs_interaction_flags = 32;
pub const obs_interaction_flags_INTERACT_MOUSE_RIGHT: obs_interaction_flags = 64;
pub const obs_interaction_flags_INTERACT_COMMAND_KEY: obs_interaction_flags = 128;
pub const obs_interaction_flags_INTERACT_NUMLOCK_KEY: obs_interaction_flags = 256;
pub const obs_interaction_flags_INTERACT_IS_KEY_PAD: obs_interaction_flags = 512;
pub const obs_interaction_flags_INTERACT_IS_LEFT: obs_interaction_flags = 1024;
pub const obs_interaction_flags_INTERACT_IS_RIGHT: obs_interaction_flags = 2048;
pub type obs_interaction_flags = ::std::os::raw::c_int;
pub const obs_mouse_button_type_MOUSE_LEFT: obs_mouse_button_type = 0;
pub const obs_mouse_button_type_MOUSE_MIDDLE: obs_mouse_button_type = 1;
pub const obs_mouse_button_type_MOUSE_RIGHT: obs_mouse_button_type = 2;
pub type obs_mouse_button_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_mouse_event {
    pub modifiers: u32,
    pub x: i32,
    pub y: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_key_event {
    pub modifiers: u32,
    pub text: *mut ::std::os::raw::c_char,
    pub native_modifiers: u32,
    pub native_scancode: u32,
    pub native_vkey: u32,
}
impl Default for obs_key_event {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_context_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_display {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_view {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_scene {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_scene_item {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_output {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_encoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_encoder_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_service {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_module {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_fader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_volmeter {
    _unused: [u8; 0],
}
pub type obs_object_t = obs_context_data;
pub type obs_display_t = obs_display;
pub type obs_view_t = obs_view;
pub type obs_source_t = obs_source;
pub type obs_scene_t = obs_scene;
pub type obs_sceneitem_t = obs_scene_item;
pub type obs_output_t = obs_output;
pub type obs_encoder_t = obs_encoder;
pub type obs_encoder_group_t = obs_encoder_group;
pub type obs_service_t = obs_service;
pub type obs_module_t = obs_module;
pub type obs_fader_t = obs_fader;
pub type obs_volmeter_t = obs_volmeter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_weak_object {
    _unused: [u8; 0],
}
pub type obs_weak_object_t = obs_weak_object;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_weak_source {
    _unused: [u8; 0],
}
pub type obs_weak_source_t = obs_weak_source;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_weak_output {
    _unused: [u8; 0],
}
pub type obs_weak_output_t = obs_weak_output;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_weak_encoder {
    _unused: [u8; 0],
}
pub type obs_weak_encoder_t = obs_weak_encoder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_weak_service {
    _unused: [u8; 0],
}
pub type obs_weak_service_t = obs_weak_service;
pub type obs_missing_file_cb = ::std::option::Option<
    unsafe extern "C" fn(
        src: *mut ::std::os::raw::c_void,
        new_path: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_missing_file {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_missing_files {
    _unused: [u8; 0],
}
pub type obs_missing_file_t = obs_missing_file;
pub type obs_missing_files_t = obs_missing_files;
pub const obs_missing_file_src_OBS_MISSING_FILE_SOURCE: obs_missing_file_src = 0;
pub const obs_missing_file_src_OBS_MISSING_FILE_SCRIPT: obs_missing_file_src = 1;
pub type obs_missing_file_src = ::std::os::raw::c_int;
pub const obs_source_type_OBS_SOURCE_TYPE_INPUT: obs_source_type = 0;
pub const obs_source_type_OBS_SOURCE_TYPE_FILTER: obs_source_type = 1;
pub const obs_source_type_OBS_SOURCE_TYPE_TRANSITION: obs_source_type = 2;
pub const obs_source_type_OBS_SOURCE_TYPE_SCENE: obs_source_type = 3;
pub type obs_source_type = ::std::os::raw::c_int;
pub const obs_balance_type_OBS_BALANCE_TYPE_SINE_LAW: obs_balance_type = 0;
pub const obs_balance_type_OBS_BALANCE_TYPE_SQUARE_LAW: obs_balance_type = 1;
pub const obs_balance_type_OBS_BALANCE_TYPE_LINEAR: obs_balance_type = 2;
pub type obs_balance_type = ::std::os::raw::c_int;
pub const obs_icon_type_OBS_ICON_TYPE_UNKNOWN: obs_icon_type = 0;
pub const obs_icon_type_OBS_ICON_TYPE_IMAGE: obs_icon_type = 1;
pub const obs_icon_type_OBS_ICON_TYPE_COLOR: obs_icon_type = 2;
pub const obs_icon_type_OBS_ICON_TYPE_SLIDESHOW: obs_icon_type = 3;
pub const obs_icon_type_OBS_ICON_TYPE_AUDIO_INPUT: obs_icon_type = 4;
pub const obs_icon_type_OBS_ICON_TYPE_AUDIO_OUTPUT: obs_icon_type = 5;
pub const obs_icon_type_OBS_ICON_TYPE_DESKTOP_CAPTURE: obs_icon_type = 6;
pub const obs_icon_type_OBS_ICON_TYPE_WINDOW_CAPTURE: obs_icon_type = 7;
pub const obs_icon_type_OBS_ICON_TYPE_GAME_CAPTURE: obs_icon_type = 8;
pub const obs_icon_type_OBS_ICON_TYPE_CAMERA: obs_icon_type = 9;
pub const obs_icon_type_OBS_ICON_TYPE_TEXT: obs_icon_type = 10;
pub const obs_icon_type_OBS_ICON_TYPE_MEDIA: obs_icon_type = 11;
pub const obs_icon_type_OBS_ICON_TYPE_BROWSER: obs_icon_type = 12;
pub const obs_icon_type_OBS_ICON_TYPE_CUSTOM: obs_icon_type = 13;
pub const obs_icon_type_OBS_ICON_TYPE_PROCESS_AUDIO_OUTPUT: obs_icon_type = 14;
pub type obs_icon_type = ::std::os::raw::c_int;
pub const obs_media_state_OBS_MEDIA_STATE_NONE: obs_media_state = 0;
pub const obs_media_state_OBS_MEDIA_STATE_PLAYING: obs_media_state = 1;
pub const obs_media_state_OBS_MEDIA_STATE_OPENING: obs_media_state = 2;
pub const obs_media_state_OBS_MEDIA_STATE_BUFFERING: obs_media_state = 3;
pub const obs_media_state_OBS_MEDIA_STATE_PAUSED: obs_media_state = 4;
pub const obs_media_state_OBS_MEDIA_STATE_STOPPED: obs_media_state = 5;
pub const obs_media_state_OBS_MEDIA_STATE_ENDED: obs_media_state = 6;
pub const obs_media_state_OBS_MEDIA_STATE_ERROR: obs_media_state = 7;
pub type obs_media_state = ::std::os::raw::c_int;
#[doc = " @}"]
pub type obs_source_enum_proc_t = ::std::option::Option<
    unsafe extern "C" fn(parent: *mut obs_source_t, child: *mut obs_source_t, param: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_source_audio_mix {
    pub output: [audio_output_data; 6usize],
}
impl Default for obs_source_audio_mix {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Source definition structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_source_info {
    #[doc = " Unique string identifier for the source"]
    pub id: *const ::std::os::raw::c_char,
    #[doc = " Type of source.\n\n OBS_SOURCE_TYPE_INPUT for input sources,\n OBS_SOURCE_TYPE_FILTER for filter sources, and\n OBS_SOURCE_TYPE_TRANSITION for transition sources."]
    pub type_: obs_source_type,
    #[doc = " Source output flags"]
    pub output_flags: u32,
    #[doc = " Get the translated name of the source type\n\n @param  type_data  The type_data variable of this structure\n @return               The translated name of the source type"]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Creates the source data for the source\n\n @param  settings  Settings to initialize the source with\n @param  source    Source that this data is associated with\n @return           The data associated with this source"]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(settings: *mut obs_data_t, source: *mut obs_source_t) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Destroys the private data for the source\n\n Async sources must not call obs_source_output_video after returning\n from destroy"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Returns the width of the source.  Required if this is an input\n source and has non-async video"]
    pub get_width: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> u32>,
    #[doc = " Returns the height of the source.  Required if this is an input\n source and has non-async video"]
    pub get_height: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> u32>,
    #[doc = " Gets the default settings for this source\n\n @param[out]  settings  Data to assign default settings to\n @deprecated            Use get_defaults2 if type_data is needed"]
    pub get_defaults: ::std::option::Option<unsafe extern "C" fn(settings: *mut obs_data_t)>,
    #[doc = " Gets the property information of this source\n\n @return         The properties data\n @deprecated     Use get_properties2 if type_data is needed"]
    pub get_properties:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut obs_properties_t>,
    #[doc = " Updates the settings for this source\n\n @param data      Source data\n @param settings  New settings for this source"]
    pub update:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t)>,
    #[doc = " Called when the source has been activated in the main view"]
    pub activate: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Called when the source has been deactivated from the main view\n (no longer being played/displayed)"]
    pub deactivate: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Called when the source is visible"]
    pub show: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Called when the source is no longer visible"]
    pub hide: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Called each video frame with the time elapsed\n\n @param  data     Source data\n @param  seconds  Seconds elapsed since the last frame"]
    pub video_tick: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, seconds: f32)>,
    #[doc = " Called when rendering the source with the graphics subsystem.\n\n If this is an input/transition source, this is called to draw the\n source texture with the graphics subsystem using the specified\n effect.\n\n If this is a filter source, it wraps source draw calls (for\n example applying a custom effect with custom parameters to a\n source).  In this case, it's highly recommended to use the\n obs_source_process_filter function to automatically handle\n effect-based filter processing.  However, you can implement custom\n draw handling as desired as well.\n\n If the source output flags do not include SOURCE_CUSTOM_DRAW, all\n a source needs to do is set the \"image\" parameter of the effect to\n the desired texture, and then draw.  If the output flags include\n SOURCE_COLOR_MATRIX, you may optionally set the \"color_matrix\"\n parameter of the effect to a custom 4x4 conversion matrix (by\n default it will be set to an YUV->RGB conversion matrix)\n\n @param data    Source data\n @param effect  Effect to be used with this source.  If the source\n                output flags include SOURCE_CUSTOM_DRAW, this will\n                be NULL, and the source is expected to process with\n                an effect manually."]
    pub video_render:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, effect: *mut gs_effect_t)>,
    #[doc = " Called to filter raw async video data.\n\n @note          This function is only used with filter sources.\n\n @param  data   Filter data\n @param  frame  Video frame to filter\n @return        New video frame data.  This can defer video data to\n                be drawn later if time is needed for processing"]
    pub filter_video: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, frame: *mut obs_source_frame) -> *mut obs_source_frame,
    >,
    #[doc = " Called to filter raw audio data.\n\n @note          This function is only used with filter sources.\n\n @param  data   Filter data\n @param  audio  Audio data to filter.\n @return        Modified or new audio data.  You can directly modify\n                the data passed and return it, or you can defer audio\n                data for later if time is needed for processing.  If\n                you are returning new data, that data must exist\n                until the next call to the filter_audio callback or\n                until the filter is removed/destroyed."]
    pub filter_audio: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, audio: *mut obs_audio_data) -> *mut obs_audio_data,
    >,
    #[doc = " Called to enumerate all active sources being used within this\n source.  If the source has children that render audio/video it must\n implement this callback.\n\n @param  data           Filter data\n @param  enum_callback  Enumeration callback\n @param  param          User data to pass to callback"]
    pub enum_active_sources: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            enum_callback: obs_source_enum_proc_t,
            param: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Called when saving a source.  This is a separate function because\n sometimes a source needs to know when it is being saved so it\n doesn't always have to update the current settings until a certain\n point.\n\n @param  data      Source data\n @param  settings  Settings"]
    pub save: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t)>,
    #[doc = " Called when loading a source from saved data.  This should be called\n after all the loading sources have actually been created because\n sometimes there are sources that depend on each other.\n\n @param  data      Source data\n @param  settings  Settings"]
    pub load: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t)>,
    #[doc = " Called when interacting with a source and a mouse-down or mouse-up\n occurs.\n\n @param data         Source data\n @param event        Mouse event properties\n @param type         Mouse button pushed\n @param mouse_up     Mouse event type (true if mouse-up)\n @param click_count  Mouse click count (1 for single click, etc.)"]
    pub mouse_click: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            event: *const obs_mouse_event,
            type_: i32,
            mouse_up: bool,
            click_count: u32,
        ),
    >,
    #[doc = " Called when interacting with a source and a mouse-move occurs.\n\n @param data         Source data\n @param event        Mouse event properties\n @param mouse_leave  Mouse leave state (true if mouse left source)"]
    pub mouse_move: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const obs_mouse_event, mouse_leave: bool),
    >,
    #[doc = " Called when interacting with a source and a mouse-wheel occurs.\n\n @param data         Source data\n @param event        Mouse event properties\n @param x_delta      Movement delta in the horizontal direction\n @param y_delta      Movement delta in the vertical direction"]
    pub mouse_wheel: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            event: *const obs_mouse_event,
            x_delta: ::std::os::raw::c_int,
            y_delta: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Called when interacting with a source and gain focus/lost focus event\n occurs.\n\n @param data         Source data\n @param focus        Focus state (true if focus gained)"]
    pub focus: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, focus: bool)>,
    #[doc = " Called when interacting with a source and a key-up or key-down\n occurs.\n\n @param data         Source data\n @param event        Key event properties\n @param focus        Key event type (true if mouse-up)"]
    pub key_click: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const obs_key_event, key_up: bool),
    >,
    #[doc = " Called when the filter is removed from a source\n\n @param  data    Filter data\n @param  source  Source that the filter being removed from"]
    pub filter_remove:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, source: *mut obs_source_t)>,
    #[doc = " Private data associated with this entry"]
    pub type_data: *mut ::std::os::raw::c_void,
    #[doc = " If defined, called to free private data on shutdown"]
    pub free_type_data: ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
    pub audio_render: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            ts_out: *mut u64,
            audio_output: *mut obs_source_audio_mix,
            mixers: u32,
            channels: usize,
            sample_rate: usize,
        ) -> bool,
    >,
    #[doc = " Called to enumerate all active and inactive sources being used\n within this source.  If this callback isn't implemented,\n enum_active_sources will be called instead.\n\n This is typically used if a source can have inactive child sources.\n\n @param  data           Filter data\n @param  enum_callback  Enumeration callback\n @param  param          User data to pass to callback"]
    pub enum_all_sources: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            enum_callback: obs_source_enum_proc_t,
            param: *mut ::std::os::raw::c_void,
        ),
    >,
    pub transition_start: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub transition_stop: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Gets the default settings for this source\n\n If get_defaults is also defined both will be called, and the first\n call will be to get_defaults, then to get_defaults2.\n\n @param       type_data The type_data variable of this structure\n @param[out]  settings  Data to assign default settings to"]
    pub get_defaults2:
        ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t)>,
    #[doc = " Gets the property information of this source\n\n @param data      Source data\n @param type_data The type_data variable of this structure\n @return          The properties data"]
    pub get_properties2: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            type_data: *mut ::std::os::raw::c_void,
        ) -> *mut obs_properties_t,
    >,
    pub audio_mix: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            ts_out: *mut u64,
            audio_output: *mut audio_output_data,
            channels: usize,
            sample_rate: usize,
        ) -> bool,
    >,
    #[doc = " Icon type for the source"]
    pub icon_type: obs_icon_type,
    #[doc = " Media controls"]
    pub media_play_pause: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, pause: bool)>,
    pub media_restart: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub media_stop: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub media_next: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub media_previous: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub media_get_duration: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> i64>,
    pub media_get_time: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> i64>,
    pub media_set_time:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, miliseconds: i64)>,
    pub media_get_state:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> obs_media_state>,
    pub version: u32,
    pub unversioned_id: *const ::std::os::raw::c_char,
    #[doc = " Missing files"]
    pub missing_files:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut obs_missing_files_t>,
    #[doc = " Get color space"]
    pub video_get_color_space: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            count: usize,
            preferred_spaces: *const gs_color_space,
        ) -> gs_color_space,
    >,
    #[doc = " Called when the filter is added to a source\n\n @param  data    Filter data\n @param  source  Source that the filter is being added to"]
    pub filter_add:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, source: *mut obs_source_t)>,
}
impl Default for obs_source_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< The encoder provides an audio codec"]
pub const obs_encoder_type_OBS_ENCODER_AUDIO: obs_encoder_type = 0;
#[doc = "< The encoder provides a video codec"]
pub const obs_encoder_type_OBS_ENCODER_VIDEO: obs_encoder_type = 1;
#[doc = " Specifies the encoder type"]
pub type obs_encoder_type = ::std::os::raw::c_int;
#[doc = " Encoder output packet"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct encoder_packet {
    #[doc = "< Packet data"]
    pub data: *mut u8,
    #[doc = "< Packet size"]
    pub size: usize,
    #[doc = "< Presentation timestamp"]
    pub pts: i64,
    #[doc = "< Decode timestamp"]
    pub dts: i64,
    #[doc = "< Timebase numerator"]
    pub timebase_num: i32,
    #[doc = "< Timebase denominator"]
    pub timebase_den: i32,
    #[doc = "< Encoder type"]
    pub type_: obs_encoder_type,
    #[doc = "< Is a keyframe"]
    pub keyframe: bool,
    pub dts_usec: i64,
    pub sys_dts_usec: i64,
    #[doc = " Packet priority\n\n This is generally use by video encoders to specify the priority\n of the packet."]
    pub priority: ::std::os::raw::c_int,
    #[doc = " Dropped packet priority\n\n If this packet needs to be dropped, the next packet must be of this\n priority or higher to continue transmission."]
    pub drop_priority: ::std::os::raw::c_int,
    #[doc = " Audio track index (used with outputs)"]
    pub track_idx: usize,
    #[doc = " Encoder from which the track originated from"]
    pub encoder: *mut obs_encoder_t,
}
impl Default for encoder_packet {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Encoder input frame"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct encoder_frame {
    #[doc = " Data for the frame/audio"]
    pub data: [*mut u8; 8usize],
    #[doc = " size of each plane"]
    pub linesize: [u32; 8usize],
    #[doc = " Number of frames (audio only)"]
    pub frames: u32,
    #[doc = " Presentation timestamp"]
    pub pts: i64,
}
impl Default for encoder_frame {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Encoder region of interest"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct obs_encoder_roi {
    pub top: u32,
    pub bottom: u32,
    pub left: u32,
    pub right: u32,
    pub priority: f32,
}
#[doc = " Encoder input texture"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct encoder_texture {
    #[doc = " Shared texture handle, only set on Windows"]
    pub handle: u32,
    #[doc = " Textures, length determined by format"]
    pub tex: [*mut gs_texture; 4usize],
}
impl Default for encoder_texture {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Encoder interface\n\n Encoders have a limited usage with OBS.  You are not generally supposed to\n implement every encoder out there.  Generally, these are limited or specific\n encoders for h264/aac for streaming and recording.  It doesn't have to be\n *just* h264 or aac of course, but generally those are the expected encoders.\n\n That being said, other encoders will be kept in mind for future use."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_encoder_info {
    #[doc = " Specifies the named identifier of this encoder"]
    pub id: *const ::std::os::raw::c_char,
    #[doc = " Specifies the encoder type (video or audio)"]
    pub type_: obs_encoder_type,
    #[doc = " Specifies the codec"]
    pub codec: *const ::std::os::raw::c_char,
    #[doc = " Gets the full translated name of this encoder\n\n @param  type_data  The type_data variable of this structure\n @return            Translated name of the encoder"]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Creates the encoder with the specified settings\n\n @param  settings  Settings for the encoder\n @param  encoder   OBS encoder context\n @return           Data associated with this encoder context, or\n                   NULL if initialization failed."]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(settings: *mut obs_data_t, encoder: *mut obs_encoder_t) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Destroys the encoder data\n\n @param  data  Data associated with this encoder context"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Encodes frame(s), and outputs encoded packets as they become\n available.\n\n @param       data             Data associated with this encoder\n                               context\n @param[in]   frame            Raw audio/video data to encode\n @param[out]  packet           Encoder packet output, if any\n @param[out]  received_packet  Set to true if a packet was received,\n                               false otherwise\n @return                       true if successful, false otherwise."]
    pub encode: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            frame: *mut encoder_frame,
            packet: *mut encoder_packet,
            received_packet: *mut bool,
        ) -> bool,
    >,
    #[doc = " Audio encoder only:  Returns the frame size for this encoder"]
    pub get_frame_size: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> usize>,
    #[doc = " Gets the default settings for this encoder\n\n @param[out]  settings  Data to assign default settings to"]
    pub get_defaults: ::std::option::Option<unsafe extern "C" fn(settings: *mut obs_data_t)>,
    #[doc = " Gets the property information of this encoder\n\n @return         The properties data"]
    pub get_properties:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut obs_properties_t>,
    #[doc = " Updates the settings for this encoder (usually used for things like\n changing bitrate while active)\n\n @param  data      Data associated with this encoder context\n @param  settings  New settings for this encoder\n @return           true if successful, false otherwise"]
    pub update: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t) -> bool,
    >,
    #[doc = " Returns extra data associated with this encoder (usually header)\n\n @param  data             Data associated with this encoder context\n @param[out]  extra_data  Pointer to receive the extra data\n @param[out]  size        Pointer to receive the size of the extra\n                          data\n @return                  true if extra data available, false\n                          otherwise"]
    pub get_extra_data: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, extra_data: *mut *mut u8, size: *mut usize) -> bool,
    >,
    #[doc = " Gets the SEI data, if any\n\n @param       data      Data associated with this encoder context\n @param[out]  sei_data  Pointer to receive the SEI data\n @param[out]  size      Pointer to receive the SEI data size\n @return                true if SEI data available, false otherwise"]
    pub get_sei_data: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, sei_data: *mut *mut u8, size: *mut usize) -> bool,
    >,
    #[doc = " Returns desired audio format and sample information\n\n @param          data  Data associated with this encoder context\n @param[in/out]  info  Audio format information"]
    pub get_audio_info:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *mut audio_convert_info)>,
    #[doc = " Returns desired video format information\n\n @param          data  Data associated with this encoder context\n @param[in/out]  info  Video format information"]
    pub get_video_info:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *mut video_scale_info)>,
    pub type_data: *mut ::std::os::raw::c_void,
    pub free_type_data: ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
    pub caps: u32,
    #[doc = " Gets the default settings for this encoder\n\n If get_defaults is also defined both will be called, and the first\n call will be to get_defaults, then to get_defaults2.\n\n @param[out]  settings  Data to assign default settings to\n @param[in]   typedata  Type Data"]
    pub get_defaults2:
        ::std::option::Option<unsafe extern "C" fn(settings: *mut obs_data_t, type_data: *mut ::std::os::raw::c_void)>,
    #[doc = " Gets the property information of this encoder\n\n @param[in]   data      Pointer from create (or null)\n @param[in]   typedata  Type Data\n @return                The properties data"]
    pub get_properties2: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            type_data: *mut ::std::os::raw::c_void,
        ) -> *mut obs_properties_t,
    >,
    pub encode_texture: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            handle: u32,
            pts: i64,
            lock_key: u64,
            next_key: *mut u64,
            packet: *mut encoder_packet,
            received_packet: *mut bool,
        ) -> bool,
    >,
    pub encode_texture2: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            texture: *mut encoder_texture,
            pts: i64,
            lock_key: u64,
            next_key: *mut u64,
            packet: *mut encoder_packet,
            received_packet: *mut bool,
        ) -> bool,
    >,
}
impl Default for obs_encoder_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_output_info {
    pub id: *const ::std::os::raw::c_char,
    pub flags: u32,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(settings: *mut obs_data_t, output: *mut obs_output_t) -> *mut ::std::os::raw::c_void,
    >,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub start: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
    pub stop: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, ts: u64)>,
    pub raw_video:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, frame: *mut video_data)>,
    pub raw_audio:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, frames: *mut audio_data)>,
    pub encoded_packet:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, packet: *mut encoder_packet)>,
    pub update:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t)>,
    pub get_defaults: ::std::option::Option<unsafe extern "C" fn(settings: *mut obs_data_t)>,
    pub get_properties:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut obs_properties_t>,
    pub unused1: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub get_total_bytes: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> u64>,
    pub get_dropped_frames:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int>,
    pub type_data: *mut ::std::os::raw::c_void,
    pub free_type_data: ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
    pub get_congestion: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> f32>,
    pub get_connect_time_ms:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int>,
    pub encoded_video_codecs: *const ::std::os::raw::c_char,
    pub encoded_audio_codecs: *const ::std::os::raw::c_char,
    pub raw_audio2: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, idx: usize, frames: *mut audio_data),
    >,
    pub protocols: *const ::std::os::raw::c_char,
}
impl Default for obs_output_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_service_resolution {
    pub cx: ::std::os::raw::c_int,
    pub cy: ::std::os::raw::c_int,
}
pub const obs_service_connect_info_OBS_SERVICE_CONNECT_INFO_SERVER_URL: obs_service_connect_info = 0;
pub const obs_service_connect_info_OBS_SERVICE_CONNECT_INFO_STREAM_ID: obs_service_connect_info = 2;
pub const obs_service_connect_info_OBS_SERVICE_CONNECT_INFO_STREAM_KEY: obs_service_connect_info = 2;
pub const obs_service_connect_info_OBS_SERVICE_CONNECT_INFO_USERNAME: obs_service_connect_info = 4;
pub const obs_service_connect_info_OBS_SERVICE_CONNECT_INFO_PASSWORD: obs_service_connect_info = 6;
pub const obs_service_connect_info_OBS_SERVICE_CONNECT_INFO_ENCRYPT_PASSPHRASE: obs_service_connect_info = 8;
pub const obs_service_connect_info_OBS_SERVICE_CONNECT_INFO_BEARER_TOKEN: obs_service_connect_info = 10;
pub type obs_service_connect_info = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_service_info {
    pub id: *const ::std::os::raw::c_char,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(settings: *mut obs_data_t, service: *mut obs_service_t) -> *mut ::std::os::raw::c_void,
    >,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub activate:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t)>,
    pub deactivate: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub update:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t)>,
    pub get_defaults: ::std::option::Option<unsafe extern "C" fn(settings: *mut obs_data_t)>,
    pub get_properties:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut obs_properties_t>,
    #[doc = " Called when getting ready to start up an output, before the encoders\n and output are initialized\n\n @param  data    Internal service data\n @param  output  Output context\n @return         true to allow the output to start up,\n                 false to prevent output from starting up"]
    pub initialize: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, output: *mut obs_output_t) -> bool,
    >,
    pub get_url:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char>,
    pub get_key:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char>,
    pub get_username:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char>,
    pub get_password:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char>,
    pub deprecated_1: ::std::option::Option<unsafe extern "C" fn() -> bool>,
    pub apply_encoder_settings: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            video_encoder_settings: *mut obs_data_t,
            audio_encoder_settings: *mut obs_data_t,
        ),
    >,
    pub type_data: *mut ::std::os::raw::c_void,
    pub free_type_data: ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
    pub get_output_type:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char>,
    pub get_supported_resolutions: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            resolutions: *mut *mut obs_service_resolution,
            count: *mut usize,
        ),
    >,
    pub get_max_fps:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, fps: *mut ::std::os::raw::c_int)>,
    pub get_max_bitrate: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            video_bitrate: *mut ::std::os::raw::c_int,
            audio_bitrate: *mut ::std::os::raw::c_int,
        ),
    >,
    pub get_supported_video_codecs: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut *const ::std::os::raw::c_char,
    >,
    pub get_protocol:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char>,
    pub get_supported_audio_codecs: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut *const ::std::os::raw::c_char,
    >,
    pub get_connect_info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, type_: u32) -> *const ::std::os::raw::c_char,
    >,
    pub can_try_to_connect: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
}
impl Default for obs_service_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief A simple cubic fader for controlling audio levels\n\n This is a very common type of software fader since it yields good\n results while being quite performant.\n The input value is mapped to mul values with the simple formula x^3."]
pub const obs_fader_type_OBS_FADER_CUBIC: obs_fader_type = 0;
#[doc = " @brief A fader compliant to IEC 60-268-18\n\n This type of fader has several segments with different slopes that\n map deflection linearly to dB values. The segments are defined as\n in the following table:\n\n@code\nDeflection           | Volume\n------------------------------------------\n[ 100   %, 75   % ]  | [   0 dB,   -9 dB ]\n[  75   %, 50   % ]  | [  -9 dB,  -20 dB ]\n[  50   %, 30   % ]  | [ -20 dB,  -30 dB ]\n[  30   %, 15   % ]  | [ -30 dB,  -40 dB ]\n[  15   %,  7.5 % ]  | [ -40 dB,  -50 dB ]\n[   7.5 %,  2.5 % ]  | [ -50 dB,  -60 dB ]\n[   2.5 %,  0   % ]  | [ -60 dB, -inf dB ]\n@endcode"]
pub const obs_fader_type_OBS_FADER_IEC: obs_fader_type = 1;
#[doc = " @brief Logarithmic fader"]
pub const obs_fader_type_OBS_FADER_LOG: obs_fader_type = 2;
#[doc = " @brief Fader types"]
pub type obs_fader_type = ::std::os::raw::c_int;
#[doc = " @brief A simple peak meter measuring the maximum of all samples.\n\n This was a very common type of peak meter used for audio, but\n is not very accurate with regards to further audio processing."]
pub const obs_peak_meter_type_SAMPLE_PEAK_METER: obs_peak_meter_type = 0;
#[doc = " @brief An accurate peak meter measure the maximum of inter-samples.\n\n This meter is more computational intensive due to 4x oversampling\n to determine the true peak to an accuracy of +/- 0.5 dB."]
pub const obs_peak_meter_type_TRUE_PEAK_METER: obs_peak_meter_type = 1;
#[doc = " @brief Peak meter types"]
pub type obs_peak_meter_type = ::std::os::raw::c_int;
pub type obs_fader_changed_t = ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, db: f32)>;
pub type obs_volmeter_updated_t = ::std::option::Option<
    unsafe extern "C" fn(
        param: *mut ::std::os::raw::c_void,
        magnitude: *const f32,
        peak: *const f32,
        input_peak: *const f32,
    ),
>;
pub type obs_fader_conversion_t = ::std::option::Option<unsafe extern "C" fn(val: f32) -> f32>;
pub type obs_hotkey_id = usize;
pub type obs_hotkey_pair_id = usize;
pub const obs_key_OBS_KEY_NONE: obs_key = 0;
pub const obs_key_OBS_KEY_RETURN: obs_key = 1;
pub const obs_key_OBS_KEY_ENTER: obs_key = 2;
pub const obs_key_OBS_KEY_ESCAPE: obs_key = 3;
pub const obs_key_OBS_KEY_TAB: obs_key = 4;
pub const obs_key_OBS_KEY_BACKTAB: obs_key = 5;
pub const obs_key_OBS_KEY_BACKSPACE: obs_key = 6;
pub const obs_key_OBS_KEY_INSERT: obs_key = 7;
pub const obs_key_OBS_KEY_DELETE: obs_key = 8;
pub const obs_key_OBS_KEY_PAUSE: obs_key = 9;
pub const obs_key_OBS_KEY_PRINT: obs_key = 10;
pub const obs_key_OBS_KEY_SYSREQ: obs_key = 11;
pub const obs_key_OBS_KEY_CLEAR: obs_key = 12;
pub const obs_key_OBS_KEY_HOME: obs_key = 13;
pub const obs_key_OBS_KEY_END: obs_key = 14;
pub const obs_key_OBS_KEY_LEFT: obs_key = 15;
pub const obs_key_OBS_KEY_UP: obs_key = 16;
pub const obs_key_OBS_KEY_RIGHT: obs_key = 17;
pub const obs_key_OBS_KEY_DOWN: obs_key = 18;
pub const obs_key_OBS_KEY_PAGEUP: obs_key = 19;
pub const obs_key_OBS_KEY_PAGEDOWN: obs_key = 20;
pub const obs_key_OBS_KEY_SHIFT: obs_key = 21;
pub const obs_key_OBS_KEY_CONTROL: obs_key = 22;
pub const obs_key_OBS_KEY_META: obs_key = 23;
pub const obs_key_OBS_KEY_ALT: obs_key = 24;
pub const obs_key_OBS_KEY_ALTGR: obs_key = 25;
pub const obs_key_OBS_KEY_CAPSLOCK: obs_key = 26;
pub const obs_key_OBS_KEY_NUMLOCK: obs_key = 27;
pub const obs_key_OBS_KEY_SCROLLLOCK: obs_key = 28;
pub const obs_key_OBS_KEY_F1: obs_key = 29;
pub const obs_key_OBS_KEY_F2: obs_key = 30;
pub const obs_key_OBS_KEY_F3: obs_key = 31;
pub const obs_key_OBS_KEY_F4: obs_key = 32;
pub const obs_key_OBS_KEY_F5: obs_key = 33;
pub const obs_key_OBS_KEY_F6: obs_key = 34;
pub const obs_key_OBS_KEY_F7: obs_key = 35;
pub const obs_key_OBS_KEY_F8: obs_key = 36;
pub const obs_key_OBS_KEY_F9: obs_key = 37;
pub const obs_key_OBS_KEY_F10: obs_key = 38;
pub const obs_key_OBS_KEY_F11: obs_key = 39;
pub const obs_key_OBS_KEY_F12: obs_key = 40;
pub const obs_key_OBS_KEY_F13: obs_key = 41;
pub const obs_key_OBS_KEY_F14: obs_key = 42;
pub const obs_key_OBS_KEY_F15: obs_key = 43;
pub const obs_key_OBS_KEY_F16: obs_key = 44;
pub const obs_key_OBS_KEY_F17: obs_key = 45;
pub const obs_key_OBS_KEY_F18: obs_key = 46;
pub const obs_key_OBS_KEY_F19: obs_key = 47;
pub const obs_key_OBS_KEY_F20: obs_key = 48;
pub const obs_key_OBS_KEY_F21: obs_key = 49;
pub const obs_key_OBS_KEY_F22: obs_key = 50;
pub const obs_key_OBS_KEY_F23: obs_key = 51;
pub const obs_key_OBS_KEY_F24: obs_key = 52;
pub const obs_key_OBS_KEY_F25: obs_key = 53;
pub const obs_key_OBS_KEY_F26: obs_key = 54;
pub const obs_key_OBS_KEY_F27: obs_key = 55;
pub const obs_key_OBS_KEY_F28: obs_key = 56;
pub const obs_key_OBS_KEY_F29: obs_key = 57;
pub const obs_key_OBS_KEY_F30: obs_key = 58;
pub const obs_key_OBS_KEY_F31: obs_key = 59;
pub const obs_key_OBS_KEY_F32: obs_key = 60;
pub const obs_key_OBS_KEY_F33: obs_key = 61;
pub const obs_key_OBS_KEY_F34: obs_key = 62;
pub const obs_key_OBS_KEY_F35: obs_key = 63;
pub const obs_key_OBS_KEY_MENU: obs_key = 64;
pub const obs_key_OBS_KEY_HYPER_L: obs_key = 65;
pub const obs_key_OBS_KEY_HYPER_R: obs_key = 66;
pub const obs_key_OBS_KEY_HELP: obs_key = 67;
pub const obs_key_OBS_KEY_DIRECTION_L: obs_key = 68;
pub const obs_key_OBS_KEY_DIRECTION_R: obs_key = 69;
pub const obs_key_OBS_KEY_SPACE: obs_key = 70;
pub const obs_key_OBS_KEY_EXCLAM: obs_key = 71;
pub const obs_key_OBS_KEY_QUOTEDBL: obs_key = 72;
pub const obs_key_OBS_KEY_NUMBERSIGN: obs_key = 73;
pub const obs_key_OBS_KEY_DOLLAR: obs_key = 74;
pub const obs_key_OBS_KEY_PERCENT: obs_key = 75;
pub const obs_key_OBS_KEY_AMPERSAND: obs_key = 76;
pub const obs_key_OBS_KEY_APOSTROPHE: obs_key = 77;
pub const obs_key_OBS_KEY_PARENLEFT: obs_key = 78;
pub const obs_key_OBS_KEY_PARENRIGHT: obs_key = 79;
pub const obs_key_OBS_KEY_ASTERISK: obs_key = 80;
pub const obs_key_OBS_KEY_PLUS: obs_key = 81;
pub const obs_key_OBS_KEY_COMMA: obs_key = 82;
pub const obs_key_OBS_KEY_MINUS: obs_key = 83;
pub const obs_key_OBS_KEY_PERIOD: obs_key = 84;
pub const obs_key_OBS_KEY_SLASH: obs_key = 85;
pub const obs_key_OBS_KEY_0: obs_key = 86;
pub const obs_key_OBS_KEY_1: obs_key = 87;
pub const obs_key_OBS_KEY_2: obs_key = 88;
pub const obs_key_OBS_KEY_3: obs_key = 89;
pub const obs_key_OBS_KEY_4: obs_key = 90;
pub const obs_key_OBS_KEY_5: obs_key = 91;
pub const obs_key_OBS_KEY_6: obs_key = 92;
pub const obs_key_OBS_KEY_7: obs_key = 93;
pub const obs_key_OBS_KEY_8: obs_key = 94;
pub const obs_key_OBS_KEY_9: obs_key = 95;
pub const obs_key_OBS_KEY_NUMEQUAL: obs_key = 96;
pub const obs_key_OBS_KEY_NUMASTERISK: obs_key = 97;
pub const obs_key_OBS_KEY_NUMPLUS: obs_key = 98;
pub const obs_key_OBS_KEY_NUMCOMMA: obs_key = 99;
pub const obs_key_OBS_KEY_NUMMINUS: obs_key = 100;
pub const obs_key_OBS_KEY_NUMPERIOD: obs_key = 101;
pub const obs_key_OBS_KEY_NUMSLASH: obs_key = 102;
pub const obs_key_OBS_KEY_NUM0: obs_key = 103;
pub const obs_key_OBS_KEY_NUM1: obs_key = 104;
pub const obs_key_OBS_KEY_NUM2: obs_key = 105;
pub const obs_key_OBS_KEY_NUM3: obs_key = 106;
pub const obs_key_OBS_KEY_NUM4: obs_key = 107;
pub const obs_key_OBS_KEY_NUM5: obs_key = 108;
pub const obs_key_OBS_KEY_NUM6: obs_key = 109;
pub const obs_key_OBS_KEY_NUM7: obs_key = 110;
pub const obs_key_OBS_KEY_NUM8: obs_key = 111;
pub const obs_key_OBS_KEY_NUM9: obs_key = 112;
pub const obs_key_OBS_KEY_COLON: obs_key = 113;
pub const obs_key_OBS_KEY_SEMICOLON: obs_key = 114;
pub const obs_key_OBS_KEY_QUOTE: obs_key = 115;
pub const obs_key_OBS_KEY_LESS: obs_key = 116;
pub const obs_key_OBS_KEY_EQUAL: obs_key = 117;
pub const obs_key_OBS_KEY_GREATER: obs_key = 118;
pub const obs_key_OBS_KEY_QUESTION: obs_key = 119;
pub const obs_key_OBS_KEY_AT: obs_key = 120;
pub const obs_key_OBS_KEY_A: obs_key = 121;
pub const obs_key_OBS_KEY_B: obs_key = 122;
pub const obs_key_OBS_KEY_C: obs_key = 123;
pub const obs_key_OBS_KEY_D: obs_key = 124;
pub const obs_key_OBS_KEY_E: obs_key = 125;
pub const obs_key_OBS_KEY_F: obs_key = 126;
pub const obs_key_OBS_KEY_G: obs_key = 127;
pub const obs_key_OBS_KEY_H: obs_key = 128;
pub const obs_key_OBS_KEY_I: obs_key = 129;
pub const obs_key_OBS_KEY_J: obs_key = 130;
pub const obs_key_OBS_KEY_K: obs_key = 131;
pub const obs_key_OBS_KEY_L: obs_key = 132;
pub const obs_key_OBS_KEY_M: obs_key = 133;
pub const obs_key_OBS_KEY_N: obs_key = 134;
pub const obs_key_OBS_KEY_O: obs_key = 135;
pub const obs_key_OBS_KEY_P: obs_key = 136;
pub const obs_key_OBS_KEY_Q: obs_key = 137;
pub const obs_key_OBS_KEY_R: obs_key = 138;
pub const obs_key_OBS_KEY_S: obs_key = 139;
pub const obs_key_OBS_KEY_T: obs_key = 140;
pub const obs_key_OBS_KEY_U: obs_key = 141;
pub const obs_key_OBS_KEY_V: obs_key = 142;
pub const obs_key_OBS_KEY_W: obs_key = 143;
pub const obs_key_OBS_KEY_X: obs_key = 144;
pub const obs_key_OBS_KEY_Y: obs_key = 145;
pub const obs_key_OBS_KEY_Z: obs_key = 146;
pub const obs_key_OBS_KEY_BRACKETLEFT: obs_key = 147;
pub const obs_key_OBS_KEY_BACKSLASH: obs_key = 148;
pub const obs_key_OBS_KEY_BRACKETRIGHT: obs_key = 149;
pub const obs_key_OBS_KEY_ASCIICIRCUM: obs_key = 150;
pub const obs_key_OBS_KEY_UNDERSCORE: obs_key = 151;
pub const obs_key_OBS_KEY_QUOTELEFT: obs_key = 152;
pub const obs_key_OBS_KEY_BRACELEFT: obs_key = 153;
pub const obs_key_OBS_KEY_BAR: obs_key = 154;
pub const obs_key_OBS_KEY_BRACERIGHT: obs_key = 155;
pub const obs_key_OBS_KEY_ASCIITILDE: obs_key = 156;
pub const obs_key_OBS_KEY_NOBREAKSPACE: obs_key = 157;
pub const obs_key_OBS_KEY_EXCLAMDOWN: obs_key = 158;
pub const obs_key_OBS_KEY_CENT: obs_key = 159;
pub const obs_key_OBS_KEY_STERLING: obs_key = 160;
pub const obs_key_OBS_KEY_CURRENCY: obs_key = 161;
pub const obs_key_OBS_KEY_YEN: obs_key = 162;
pub const obs_key_OBS_KEY_BROKENBAR: obs_key = 163;
pub const obs_key_OBS_KEY_SECTION: obs_key = 164;
pub const obs_key_OBS_KEY_DIAERESIS: obs_key = 165;
pub const obs_key_OBS_KEY_COPYRIGHT: obs_key = 166;
pub const obs_key_OBS_KEY_ORDFEMININE: obs_key = 167;
pub const obs_key_OBS_KEY_GUILLEMOTLEFT: obs_key = 168;
pub const obs_key_OBS_KEY_NOTSIGN: obs_key = 169;
pub const obs_key_OBS_KEY_HYPHEN: obs_key = 170;
pub const obs_key_OBS_KEY_REGISTERED: obs_key = 171;
pub const obs_key_OBS_KEY_MACRON: obs_key = 172;
pub const obs_key_OBS_KEY_DEGREE: obs_key = 173;
pub const obs_key_OBS_KEY_PLUSMINUS: obs_key = 174;
pub const obs_key_OBS_KEY_TWOSUPERIOR: obs_key = 175;
pub const obs_key_OBS_KEY_THREESUPERIOR: obs_key = 176;
pub const obs_key_OBS_KEY_ACUTE: obs_key = 177;
pub const obs_key_OBS_KEY_MU: obs_key = 178;
pub const obs_key_OBS_KEY_PARAGRAPH: obs_key = 179;
pub const obs_key_OBS_KEY_PERIODCENTERED: obs_key = 180;
pub const obs_key_OBS_KEY_CEDILLA: obs_key = 181;
pub const obs_key_OBS_KEY_ONESUPERIOR: obs_key = 182;
pub const obs_key_OBS_KEY_MASCULINE: obs_key = 183;
pub const obs_key_OBS_KEY_GUILLEMOTRIGHT: obs_key = 184;
pub const obs_key_OBS_KEY_ONEQUARTER: obs_key = 185;
pub const obs_key_OBS_KEY_ONEHALF: obs_key = 186;
pub const obs_key_OBS_KEY_THREEQUARTERS: obs_key = 187;
pub const obs_key_OBS_KEY_QUESTIONDOWN: obs_key = 188;
pub const obs_key_OBS_KEY_AGRAVE: obs_key = 189;
pub const obs_key_OBS_KEY_AACUTE: obs_key = 190;
pub const obs_key_OBS_KEY_ACIRCUMFLEX: obs_key = 191;
pub const obs_key_OBS_KEY_ATILDE: obs_key = 192;
pub const obs_key_OBS_KEY_ADIAERESIS: obs_key = 193;
pub const obs_key_OBS_KEY_ARING: obs_key = 194;
pub const obs_key_OBS_KEY_AE: obs_key = 195;
pub const obs_key_OBS_KEY_CCEDILLA: obs_key = 196;
pub const obs_key_OBS_KEY_EGRAVE: obs_key = 197;
pub const obs_key_OBS_KEY_EACUTE: obs_key = 198;
pub const obs_key_OBS_KEY_ECIRCUMFLEX: obs_key = 199;
pub const obs_key_OBS_KEY_EDIAERESIS: obs_key = 200;
pub const obs_key_OBS_KEY_IGRAVE: obs_key = 201;
pub const obs_key_OBS_KEY_IACUTE: obs_key = 202;
pub const obs_key_OBS_KEY_ICIRCUMFLEX: obs_key = 203;
pub const obs_key_OBS_KEY_IDIAERESIS: obs_key = 204;
pub const obs_key_OBS_KEY_ETH: obs_key = 205;
pub const obs_key_OBS_KEY_NTILDE: obs_key = 206;
pub const obs_key_OBS_KEY_OGRAVE: obs_key = 207;
pub const obs_key_OBS_KEY_OACUTE: obs_key = 208;
pub const obs_key_OBS_KEY_OCIRCUMFLEX: obs_key = 209;
pub const obs_key_OBS_KEY_OTILDE: obs_key = 210;
pub const obs_key_OBS_KEY_ODIAERESIS: obs_key = 211;
pub const obs_key_OBS_KEY_MULTIPLY: obs_key = 212;
pub const obs_key_OBS_KEY_OOBLIQUE: obs_key = 213;
pub const obs_key_OBS_KEY_UGRAVE: obs_key = 214;
pub const obs_key_OBS_KEY_UACUTE: obs_key = 215;
pub const obs_key_OBS_KEY_UCIRCUMFLEX: obs_key = 216;
pub const obs_key_OBS_KEY_UDIAERESIS: obs_key = 217;
pub const obs_key_OBS_KEY_YACUTE: obs_key = 218;
pub const obs_key_OBS_KEY_THORN: obs_key = 219;
pub const obs_key_OBS_KEY_SSHARP: obs_key = 220;
pub const obs_key_OBS_KEY_DIVISION: obs_key = 221;
pub const obs_key_OBS_KEY_YDIAERESIS: obs_key = 222;
pub const obs_key_OBS_KEY_MULTI_KEY: obs_key = 223;
pub const obs_key_OBS_KEY_CODEINPUT: obs_key = 224;
pub const obs_key_OBS_KEY_SINGLECANDIDATE: obs_key = 225;
pub const obs_key_OBS_KEY_MULTIPLECANDIDATE: obs_key = 226;
pub const obs_key_OBS_KEY_PREVIOUSCANDIDATE: obs_key = 227;
pub const obs_key_OBS_KEY_MODE_SWITCH: obs_key = 228;
pub const obs_key_OBS_KEY_KANJI: obs_key = 229;
pub const obs_key_OBS_KEY_MUHENKAN: obs_key = 230;
pub const obs_key_OBS_KEY_HENKAN: obs_key = 231;
pub const obs_key_OBS_KEY_ROMAJI: obs_key = 232;
pub const obs_key_OBS_KEY_HIRAGANA: obs_key = 233;
pub const obs_key_OBS_KEY_KATAKANA: obs_key = 234;
pub const obs_key_OBS_KEY_HIRAGANA_KATAKANA: obs_key = 235;
pub const obs_key_OBS_KEY_ZENKAKU: obs_key = 236;
pub const obs_key_OBS_KEY_HANKAKU: obs_key = 237;
pub const obs_key_OBS_KEY_ZENKAKU_HANKAKU: obs_key = 238;
pub const obs_key_OBS_KEY_TOUROKU: obs_key = 239;
pub const obs_key_OBS_KEY_MASSYO: obs_key = 240;
pub const obs_key_OBS_KEY_KANA_LOCK: obs_key = 241;
pub const obs_key_OBS_KEY_KANA_SHIFT: obs_key = 242;
pub const obs_key_OBS_KEY_EISU_SHIFT: obs_key = 243;
pub const obs_key_OBS_KEY_EISU_TOGGLE: obs_key = 244;
pub const obs_key_OBS_KEY_HANGUL: obs_key = 245;
pub const obs_key_OBS_KEY_HANGUL_START: obs_key = 246;
pub const obs_key_OBS_KEY_HANGUL_END: obs_key = 247;
pub const obs_key_OBS_KEY_HANGUL_HANJA: obs_key = 248;
pub const obs_key_OBS_KEY_HANGUL_JAMO: obs_key = 249;
pub const obs_key_OBS_KEY_HANGUL_ROMAJA: obs_key = 250;
pub const obs_key_OBS_KEY_HANGUL_JEONJA: obs_key = 251;
pub const obs_key_OBS_KEY_HANGUL_BANJA: obs_key = 252;
pub const obs_key_OBS_KEY_HANGUL_PREHANJA: obs_key = 253;
pub const obs_key_OBS_KEY_HANGUL_POSTHANJA: obs_key = 254;
pub const obs_key_OBS_KEY_HANGUL_SPECIAL: obs_key = 255;
pub const obs_key_OBS_KEY_DEAD_GRAVE: obs_key = 256;
pub const obs_key_OBS_KEY_DEAD_ACUTE: obs_key = 257;
pub const obs_key_OBS_KEY_DEAD_CIRCUMFLEX: obs_key = 258;
pub const obs_key_OBS_KEY_DEAD_TILDE: obs_key = 259;
pub const obs_key_OBS_KEY_DEAD_MACRON: obs_key = 260;
pub const obs_key_OBS_KEY_DEAD_BREVE: obs_key = 261;
pub const obs_key_OBS_KEY_DEAD_ABOVEDOT: obs_key = 262;
pub const obs_key_OBS_KEY_DEAD_DIAERESIS: obs_key = 263;
pub const obs_key_OBS_KEY_DEAD_ABOVERING: obs_key = 264;
pub const obs_key_OBS_KEY_DEAD_DOUBLEACUTE: obs_key = 265;
pub const obs_key_OBS_KEY_DEAD_CARON: obs_key = 266;
pub const obs_key_OBS_KEY_DEAD_CEDILLA: obs_key = 267;
pub const obs_key_OBS_KEY_DEAD_OGONEK: obs_key = 268;
pub const obs_key_OBS_KEY_DEAD_IOTA: obs_key = 269;
pub const obs_key_OBS_KEY_DEAD_VOICED_SOUND: obs_key = 270;
pub const obs_key_OBS_KEY_DEAD_SEMIVOICED_SOUND: obs_key = 271;
pub const obs_key_OBS_KEY_DEAD_BELOWDOT: obs_key = 272;
pub const obs_key_OBS_KEY_DEAD_HOOK: obs_key = 273;
pub const obs_key_OBS_KEY_DEAD_HORN: obs_key = 274;
pub const obs_key_OBS_KEY_BACK: obs_key = 275;
pub const obs_key_OBS_KEY_FORWARD: obs_key = 276;
pub const obs_key_OBS_KEY_STOP: obs_key = 277;
pub const obs_key_OBS_KEY_REFRESH: obs_key = 278;
pub const obs_key_OBS_KEY_VOLUMEDOWN: obs_key = 279;
pub const obs_key_OBS_KEY_VOLUMEMUTE: obs_key = 280;
pub const obs_key_OBS_KEY_VOLUMEUP: obs_key = 281;
pub const obs_key_OBS_KEY_BASSBOOST: obs_key = 282;
pub const obs_key_OBS_KEY_BASSUP: obs_key = 283;
pub const obs_key_OBS_KEY_BASSDOWN: obs_key = 284;
pub const obs_key_OBS_KEY_TREBLEUP: obs_key = 285;
pub const obs_key_OBS_KEY_TREBLEDOWN: obs_key = 286;
pub const obs_key_OBS_KEY_MEDIAPLAY: obs_key = 287;
pub const obs_key_OBS_KEY_MEDIASTOP: obs_key = 288;
pub const obs_key_OBS_KEY_MEDIAPREVIOUS: obs_key = 289;
pub const obs_key_OBS_KEY_MEDIANEXT: obs_key = 290;
pub const obs_key_OBS_KEY_MEDIARECORD: obs_key = 291;
pub const obs_key_OBS_KEY_MEDIAPAUSE: obs_key = 292;
pub const obs_key_OBS_KEY_MEDIATOGGLEPLAYPAUSE: obs_key = 293;
pub const obs_key_OBS_KEY_HOMEPAGE: obs_key = 294;
pub const obs_key_OBS_KEY_FAVORITES: obs_key = 295;
pub const obs_key_OBS_KEY_SEARCH: obs_key = 296;
pub const obs_key_OBS_KEY_STANDBY: obs_key = 297;
pub const obs_key_OBS_KEY_OPENURL: obs_key = 298;
pub const obs_key_OBS_KEY_LAUNCHMAIL: obs_key = 299;
pub const obs_key_OBS_KEY_LAUNCHMEDIA: obs_key = 300;
pub const obs_key_OBS_KEY_LAUNCH0: obs_key = 301;
pub const obs_key_OBS_KEY_LAUNCH1: obs_key = 302;
pub const obs_key_OBS_KEY_LAUNCH2: obs_key = 303;
pub const obs_key_OBS_KEY_LAUNCH3: obs_key = 304;
pub const obs_key_OBS_KEY_LAUNCH4: obs_key = 305;
pub const obs_key_OBS_KEY_LAUNCH5: obs_key = 306;
pub const obs_key_OBS_KEY_LAUNCH6: obs_key = 307;
pub const obs_key_OBS_KEY_LAUNCH7: obs_key = 308;
pub const obs_key_OBS_KEY_LAUNCH8: obs_key = 309;
pub const obs_key_OBS_KEY_LAUNCH9: obs_key = 310;
pub const obs_key_OBS_KEY_LAUNCHA: obs_key = 311;
pub const obs_key_OBS_KEY_LAUNCHB: obs_key = 312;
pub const obs_key_OBS_KEY_LAUNCHC: obs_key = 313;
pub const obs_key_OBS_KEY_LAUNCHD: obs_key = 314;
pub const obs_key_OBS_KEY_LAUNCHE: obs_key = 315;
pub const obs_key_OBS_KEY_LAUNCHF: obs_key = 316;
pub const obs_key_OBS_KEY_LAUNCHG: obs_key = 317;
pub const obs_key_OBS_KEY_LAUNCHH: obs_key = 318;
pub const obs_key_OBS_KEY_MONBRIGHTNESSUP: obs_key = 319;
pub const obs_key_OBS_KEY_MONBRIGHTNESSDOWN: obs_key = 320;
pub const obs_key_OBS_KEY_KEYBOARDLIGHTONOFF: obs_key = 321;
pub const obs_key_OBS_KEY_KEYBOARDBRIGHTNESSUP: obs_key = 322;
pub const obs_key_OBS_KEY_KEYBOARDBRIGHTNESSDOWN: obs_key = 323;
pub const obs_key_OBS_KEY_POWEROFF: obs_key = 324;
pub const obs_key_OBS_KEY_WAKEUP: obs_key = 325;
pub const obs_key_OBS_KEY_EJECT: obs_key = 326;
pub const obs_key_OBS_KEY_SCREENSAVER: obs_key = 327;
pub const obs_key_OBS_KEY_WWW: obs_key = 328;
pub const obs_key_OBS_KEY_MEMO: obs_key = 329;
pub const obs_key_OBS_KEY_LIGHTBULB: obs_key = 330;
pub const obs_key_OBS_KEY_SHOP: obs_key = 331;
pub const obs_key_OBS_KEY_HISTORY: obs_key = 332;
pub const obs_key_OBS_KEY_ADDFAVORITE: obs_key = 333;
pub const obs_key_OBS_KEY_HOTLINKS: obs_key = 334;
pub const obs_key_OBS_KEY_BRIGHTNESSADJUST: obs_key = 335;
pub const obs_key_OBS_KEY_FINANCE: obs_key = 336;
pub const obs_key_OBS_KEY_COMMUNITY: obs_key = 337;
pub const obs_key_OBS_KEY_AUDIOREWIND: obs_key = 338;
pub const obs_key_OBS_KEY_BACKFORWARD: obs_key = 339;
pub const obs_key_OBS_KEY_APPLICATIONLEFT: obs_key = 340;
pub const obs_key_OBS_KEY_APPLICATIONRIGHT: obs_key = 341;
pub const obs_key_OBS_KEY_BOOK: obs_key = 342;
pub const obs_key_OBS_KEY_CD: obs_key = 343;
pub const obs_key_OBS_KEY_CALCULATOR: obs_key = 344;
pub const obs_key_OBS_KEY_TODOLIST: obs_key = 345;
pub const obs_key_OBS_KEY_CLEARGRAB: obs_key = 346;
pub const obs_key_OBS_KEY_CLOSE: obs_key = 347;
pub const obs_key_OBS_KEY_COPY: obs_key = 348;
pub const obs_key_OBS_KEY_CUT: obs_key = 349;
pub const obs_key_OBS_KEY_DISPLAY: obs_key = 350;
pub const obs_key_OBS_KEY_DOS: obs_key = 351;
pub const obs_key_OBS_KEY_DOCUMENTS: obs_key = 352;
pub const obs_key_OBS_KEY_EXCEL: obs_key = 353;
pub const obs_key_OBS_KEY_EXPLORER: obs_key = 354;
pub const obs_key_OBS_KEY_GAME: obs_key = 355;
pub const obs_key_OBS_KEY_GO: obs_key = 356;
pub const obs_key_OBS_KEY_ITOUCH: obs_key = 357;
pub const obs_key_OBS_KEY_LOGOFF: obs_key = 358;
pub const obs_key_OBS_KEY_MARKET: obs_key = 359;
pub const obs_key_OBS_KEY_MEETING: obs_key = 360;
pub const obs_key_OBS_KEY_MENUKB: obs_key = 361;
pub const obs_key_OBS_KEY_MENUPB: obs_key = 362;
pub const obs_key_OBS_KEY_MYSITES: obs_key = 363;
pub const obs_key_OBS_KEY_NEWS: obs_key = 364;
pub const obs_key_OBS_KEY_OFFICEHOME: obs_key = 365;
pub const obs_key_OBS_KEY_OPTION: obs_key = 366;
pub const obs_key_OBS_KEY_PASTE: obs_key = 367;
pub const obs_key_OBS_KEY_PHONE: obs_key = 368;
pub const obs_key_OBS_KEY_CALENDAR: obs_key = 369;
pub const obs_key_OBS_KEY_REPLY: obs_key = 370;
pub const obs_key_OBS_KEY_RELOAD: obs_key = 371;
pub const obs_key_OBS_KEY_ROTATEWINDOWS: obs_key = 372;
pub const obs_key_OBS_KEY_ROTATIONPB: obs_key = 373;
pub const obs_key_OBS_KEY_ROTATIONKB: obs_key = 374;
pub const obs_key_OBS_KEY_SAVE: obs_key = 375;
pub const obs_key_OBS_KEY_SEND: obs_key = 376;
pub const obs_key_OBS_KEY_SPELL: obs_key = 377;
pub const obs_key_OBS_KEY_SPLITSCREEN: obs_key = 378;
pub const obs_key_OBS_KEY_SUPPORT: obs_key = 379;
pub const obs_key_OBS_KEY_TASKPANE: obs_key = 380;
pub const obs_key_OBS_KEY_TERMINAL: obs_key = 381;
pub const obs_key_OBS_KEY_TOOLS: obs_key = 382;
pub const obs_key_OBS_KEY_TRAVEL: obs_key = 383;
pub const obs_key_OBS_KEY_VIDEO: obs_key = 384;
pub const obs_key_OBS_KEY_WORD: obs_key = 385;
pub const obs_key_OBS_KEY_XFER: obs_key = 386;
pub const obs_key_OBS_KEY_ZOOMIN: obs_key = 387;
pub const obs_key_OBS_KEY_ZOOMOUT: obs_key = 388;
pub const obs_key_OBS_KEY_AWAY: obs_key = 389;
pub const obs_key_OBS_KEY_MESSENGER: obs_key = 390;
pub const obs_key_OBS_KEY_WEBCAM: obs_key = 391;
pub const obs_key_OBS_KEY_MAILFORWARD: obs_key = 392;
pub const obs_key_OBS_KEY_PICTURES: obs_key = 393;
pub const obs_key_OBS_KEY_MUSIC: obs_key = 394;
pub const obs_key_OBS_KEY_BATTERY: obs_key = 395;
pub const obs_key_OBS_KEY_BLUETOOTH: obs_key = 396;
pub const obs_key_OBS_KEY_WLAN: obs_key = 397;
pub const obs_key_OBS_KEY_UWB: obs_key = 398;
pub const obs_key_OBS_KEY_AUDIOFORWARD: obs_key = 399;
pub const obs_key_OBS_KEY_AUDIOREPEAT: obs_key = 400;
pub const obs_key_OBS_KEY_AUDIORANDOMPLAY: obs_key = 401;
pub const obs_key_OBS_KEY_SUBTITLE: obs_key = 402;
pub const obs_key_OBS_KEY_AUDIOCYCLETRACK: obs_key = 403;
pub const obs_key_OBS_KEY_TIME: obs_key = 404;
pub const obs_key_OBS_KEY_HIBERNATE: obs_key = 405;
pub const obs_key_OBS_KEY_VIEW: obs_key = 406;
pub const obs_key_OBS_KEY_TOPMENU: obs_key = 407;
pub const obs_key_OBS_KEY_POWERDOWN: obs_key = 408;
pub const obs_key_OBS_KEY_SUSPEND: obs_key = 409;
pub const obs_key_OBS_KEY_CONTRASTADJUST: obs_key = 410;
pub const obs_key_OBS_KEY_MEDIALAST: obs_key = 411;
pub const obs_key_OBS_KEY_CALL: obs_key = 412;
pub const obs_key_OBS_KEY_CAMERA: obs_key = 413;
pub const obs_key_OBS_KEY_CAMERAFOCUS: obs_key = 414;
pub const obs_key_OBS_KEY_CONTEXT1: obs_key = 415;
pub const obs_key_OBS_KEY_CONTEXT2: obs_key = 416;
pub const obs_key_OBS_KEY_CONTEXT3: obs_key = 417;
pub const obs_key_OBS_KEY_CONTEXT4: obs_key = 418;
pub const obs_key_OBS_KEY_FLIP: obs_key = 419;
pub const obs_key_OBS_KEY_HANGUP: obs_key = 420;
pub const obs_key_OBS_KEY_NO: obs_key = 421;
pub const obs_key_OBS_KEY_SELECT: obs_key = 422;
pub const obs_key_OBS_KEY_YES: obs_key = 423;
pub const obs_key_OBS_KEY_TOGGLECALLHANGUP: obs_key = 424;
pub const obs_key_OBS_KEY_VOICEDIAL: obs_key = 425;
pub const obs_key_OBS_KEY_LASTNUMBERREDIAL: obs_key = 426;
pub const obs_key_OBS_KEY_EXECUTE: obs_key = 427;
pub const obs_key_OBS_KEY_PRINTER: obs_key = 428;
pub const obs_key_OBS_KEY_PLAY: obs_key = 429;
pub const obs_key_OBS_KEY_SLEEP: obs_key = 430;
pub const obs_key_OBS_KEY_ZOOM: obs_key = 431;
pub const obs_key_OBS_KEY_CANCEL: obs_key = 432;
pub const obs_key_OBS_KEY_MOUSE1: obs_key = 433;
pub const obs_key_OBS_KEY_MOUSE2: obs_key = 434;
pub const obs_key_OBS_KEY_MOUSE3: obs_key = 435;
pub const obs_key_OBS_KEY_MOUSE4: obs_key = 436;
pub const obs_key_OBS_KEY_MOUSE5: obs_key = 437;
pub const obs_key_OBS_KEY_MOUSE6: obs_key = 438;
pub const obs_key_OBS_KEY_MOUSE7: obs_key = 439;
pub const obs_key_OBS_KEY_MOUSE8: obs_key = 440;
pub const obs_key_OBS_KEY_MOUSE9: obs_key = 441;
pub const obs_key_OBS_KEY_MOUSE10: obs_key = 442;
pub const obs_key_OBS_KEY_MOUSE11: obs_key = 443;
pub const obs_key_OBS_KEY_MOUSE12: obs_key = 444;
pub const obs_key_OBS_KEY_MOUSE13: obs_key = 445;
pub const obs_key_OBS_KEY_MOUSE14: obs_key = 446;
pub const obs_key_OBS_KEY_MOUSE15: obs_key = 447;
pub const obs_key_OBS_KEY_MOUSE16: obs_key = 448;
pub const obs_key_OBS_KEY_MOUSE17: obs_key = 449;
pub const obs_key_OBS_KEY_MOUSE18: obs_key = 450;
pub const obs_key_OBS_KEY_MOUSE19: obs_key = 451;
pub const obs_key_OBS_KEY_MOUSE20: obs_key = 452;
pub const obs_key_OBS_KEY_MOUSE21: obs_key = 453;
pub const obs_key_OBS_KEY_MOUSE22: obs_key = 454;
pub const obs_key_OBS_KEY_MOUSE23: obs_key = 455;
pub const obs_key_OBS_KEY_MOUSE24: obs_key = 456;
pub const obs_key_OBS_KEY_MOUSE25: obs_key = 457;
pub const obs_key_OBS_KEY_MOUSE26: obs_key = 458;
pub const obs_key_OBS_KEY_MOUSE27: obs_key = 459;
pub const obs_key_OBS_KEY_MOUSE28: obs_key = 460;
pub const obs_key_OBS_KEY_MOUSE29: obs_key = 461;
pub const obs_key_OBS_KEY_BACKSLASH_RT102: obs_key = 462;
pub const obs_key_OBS_KEY_OPEN: obs_key = 463;
pub const obs_key_OBS_KEY_FIND: obs_key = 464;
pub const obs_key_OBS_KEY_REDO: obs_key = 465;
pub const obs_key_OBS_KEY_UNDO: obs_key = 466;
pub const obs_key_OBS_KEY_FRONT: obs_key = 467;
pub const obs_key_OBS_KEY_PROPS: obs_key = 468;
pub const obs_key_OBS_KEY_VK_CANCEL: obs_key = 469;
pub const obs_key_OBS_KEY_0x07: obs_key = 470;
pub const obs_key_OBS_KEY_0x0A: obs_key = 471;
pub const obs_key_OBS_KEY_0x0B: obs_key = 472;
pub const obs_key_OBS_KEY_0x0E: obs_key = 473;
pub const obs_key_OBS_KEY_0x0F: obs_key = 474;
pub const obs_key_OBS_KEY_0x16: obs_key = 475;
pub const obs_key_OBS_KEY_VK_JUNJA: obs_key = 476;
pub const obs_key_OBS_KEY_VK_FINAL: obs_key = 477;
pub const obs_key_OBS_KEY_0x1A: obs_key = 478;
pub const obs_key_OBS_KEY_VK_ACCEPT: obs_key = 479;
pub const obs_key_OBS_KEY_VK_MODECHANGE: obs_key = 480;
pub const obs_key_OBS_KEY_VK_SELECT: obs_key = 481;
pub const obs_key_OBS_KEY_VK_PRINT: obs_key = 482;
pub const obs_key_OBS_KEY_VK_EXECUTE: obs_key = 483;
pub const obs_key_OBS_KEY_VK_HELP: obs_key = 484;
pub const obs_key_OBS_KEY_0x30: obs_key = 485;
pub const obs_key_OBS_KEY_0x31: obs_key = 486;
pub const obs_key_OBS_KEY_0x32: obs_key = 487;
pub const obs_key_OBS_KEY_0x33: obs_key = 488;
pub const obs_key_OBS_KEY_0x34: obs_key = 489;
pub const obs_key_OBS_KEY_0x35: obs_key = 490;
pub const obs_key_OBS_KEY_0x36: obs_key = 491;
pub const obs_key_OBS_KEY_0x37: obs_key = 492;
pub const obs_key_OBS_KEY_0x38: obs_key = 493;
pub const obs_key_OBS_KEY_0x39: obs_key = 494;
pub const obs_key_OBS_KEY_0x3A: obs_key = 495;
pub const obs_key_OBS_KEY_0x3B: obs_key = 496;
pub const obs_key_OBS_KEY_0x3C: obs_key = 497;
pub const obs_key_OBS_KEY_0x3D: obs_key = 498;
pub const obs_key_OBS_KEY_0x3E: obs_key = 499;
pub const obs_key_OBS_KEY_0x3F: obs_key = 500;
pub const obs_key_OBS_KEY_0x40: obs_key = 501;
pub const obs_key_OBS_KEY_0x41: obs_key = 502;
pub const obs_key_OBS_KEY_0x42: obs_key = 503;
pub const obs_key_OBS_KEY_0x43: obs_key = 504;
pub const obs_key_OBS_KEY_0x44: obs_key = 505;
pub const obs_key_OBS_KEY_0x45: obs_key = 506;
pub const obs_key_OBS_KEY_0x46: obs_key = 507;
pub const obs_key_OBS_KEY_0x47: obs_key = 508;
pub const obs_key_OBS_KEY_0x48: obs_key = 509;
pub const obs_key_OBS_KEY_0x49: obs_key = 510;
pub const obs_key_OBS_KEY_0x4A: obs_key = 511;
pub const obs_key_OBS_KEY_0x4B: obs_key = 512;
pub const obs_key_OBS_KEY_0x4C: obs_key = 513;
pub const obs_key_OBS_KEY_0x4D: obs_key = 514;
pub const obs_key_OBS_KEY_0x4E: obs_key = 515;
pub const obs_key_OBS_KEY_0x4F: obs_key = 516;
pub const obs_key_OBS_KEY_0x50: obs_key = 517;
pub const obs_key_OBS_KEY_0x51: obs_key = 518;
pub const obs_key_OBS_KEY_0x52: obs_key = 519;
pub const obs_key_OBS_KEY_0x53: obs_key = 520;
pub const obs_key_OBS_KEY_0x54: obs_key = 521;
pub const obs_key_OBS_KEY_0x55: obs_key = 522;
pub const obs_key_OBS_KEY_0x56: obs_key = 523;
pub const obs_key_OBS_KEY_0x57: obs_key = 524;
pub const obs_key_OBS_KEY_0x58: obs_key = 525;
pub const obs_key_OBS_KEY_0x59: obs_key = 526;
pub const obs_key_OBS_KEY_0x5A: obs_key = 527;
pub const obs_key_OBS_KEY_VK_LWIN: obs_key = 528;
pub const obs_key_OBS_KEY_VK_RWIN: obs_key = 529;
pub const obs_key_OBS_KEY_VK_APPS: obs_key = 530;
pub const obs_key_OBS_KEY_0x5E: obs_key = 531;
pub const obs_key_OBS_KEY_VK_SLEEP: obs_key = 532;
pub const obs_key_OBS_KEY_VK_SEPARATOR: obs_key = 533;
pub const obs_key_OBS_KEY_0x88: obs_key = 534;
pub const obs_key_OBS_KEY_0x89: obs_key = 535;
pub const obs_key_OBS_KEY_0x8A: obs_key = 536;
pub const obs_key_OBS_KEY_0x8B: obs_key = 537;
pub const obs_key_OBS_KEY_0x8C: obs_key = 538;
pub const obs_key_OBS_KEY_0x8D: obs_key = 539;
pub const obs_key_OBS_KEY_0x8E: obs_key = 540;
pub const obs_key_OBS_KEY_0x8F: obs_key = 541;
pub const obs_key_OBS_KEY_VK_OEM_FJ_JISHO: obs_key = 542;
pub const obs_key_OBS_KEY_VK_OEM_FJ_LOYA: obs_key = 543;
pub const obs_key_OBS_KEY_VK_OEM_FJ_ROYA: obs_key = 544;
pub const obs_key_OBS_KEY_0x97: obs_key = 545;
pub const obs_key_OBS_KEY_0x98: obs_key = 546;
pub const obs_key_OBS_KEY_0x99: obs_key = 547;
pub const obs_key_OBS_KEY_0x9A: obs_key = 548;
pub const obs_key_OBS_KEY_0x9B: obs_key = 549;
pub const obs_key_OBS_KEY_0x9C: obs_key = 550;
pub const obs_key_OBS_KEY_0x9D: obs_key = 551;
pub const obs_key_OBS_KEY_0x9E: obs_key = 552;
pub const obs_key_OBS_KEY_0x9F: obs_key = 553;
pub const obs_key_OBS_KEY_VK_LSHIFT: obs_key = 554;
pub const obs_key_OBS_KEY_VK_RSHIFT: obs_key = 555;
pub const obs_key_OBS_KEY_VK_LCONTROL: obs_key = 556;
pub const obs_key_OBS_KEY_VK_RCONTROL: obs_key = 557;
pub const obs_key_OBS_KEY_VK_LMENU: obs_key = 558;
pub const obs_key_OBS_KEY_VK_RMENU: obs_key = 559;
pub const obs_key_OBS_KEY_VK_BROWSER_BACK: obs_key = 560;
pub const obs_key_OBS_KEY_VK_BROWSER_FORWARD: obs_key = 561;
pub const obs_key_OBS_KEY_VK_BROWSER_REFRESH: obs_key = 562;
pub const obs_key_OBS_KEY_VK_BROWSER_STOP: obs_key = 563;
pub const obs_key_OBS_KEY_VK_BROWSER_SEARCH: obs_key = 564;
pub const obs_key_OBS_KEY_VK_BROWSER_FAVORITES: obs_key = 565;
pub const obs_key_OBS_KEY_VK_BROWSER_HOME: obs_key = 566;
pub const obs_key_OBS_KEY_VK_VOLUME_MUTE: obs_key = 567;
pub const obs_key_OBS_KEY_VK_VOLUME_DOWN: obs_key = 568;
pub const obs_key_OBS_KEY_VK_VOLUME_UP: obs_key = 569;
pub const obs_key_OBS_KEY_VK_MEDIA_NEXT_TRACK: obs_key = 570;
pub const obs_key_OBS_KEY_VK_MEDIA_PREV_TRACK: obs_key = 571;
pub const obs_key_OBS_KEY_VK_MEDIA_STOP: obs_key = 572;
pub const obs_key_OBS_KEY_VK_MEDIA_PLAY_PAUSE: obs_key = 573;
pub const obs_key_OBS_KEY_VK_LAUNCH_MAIL: obs_key = 574;
pub const obs_key_OBS_KEY_VK_LAUNCH_MEDIA_SELECT: obs_key = 575;
pub const obs_key_OBS_KEY_VK_LAUNCH_APP1: obs_key = 576;
pub const obs_key_OBS_KEY_VK_LAUNCH_APP2: obs_key = 577;
pub const obs_key_OBS_KEY_0xB8: obs_key = 578;
pub const obs_key_OBS_KEY_0xB9: obs_key = 579;
pub const obs_key_OBS_KEY_0xC1: obs_key = 580;
pub const obs_key_OBS_KEY_0xC2: obs_key = 581;
pub const obs_key_OBS_KEY_0xC3: obs_key = 582;
pub const obs_key_OBS_KEY_0xC4: obs_key = 583;
pub const obs_key_OBS_KEY_0xC5: obs_key = 584;
pub const obs_key_OBS_KEY_0xC6: obs_key = 585;
pub const obs_key_OBS_KEY_0xC7: obs_key = 586;
pub const obs_key_OBS_KEY_0xC8: obs_key = 587;
pub const obs_key_OBS_KEY_0xC9: obs_key = 588;
pub const obs_key_OBS_KEY_0xCA: obs_key = 589;
pub const obs_key_OBS_KEY_0xCB: obs_key = 590;
pub const obs_key_OBS_KEY_0xCC: obs_key = 591;
pub const obs_key_OBS_KEY_0xCD: obs_key = 592;
pub const obs_key_OBS_KEY_0xCE: obs_key = 593;
pub const obs_key_OBS_KEY_0xCF: obs_key = 594;
pub const obs_key_OBS_KEY_0xD0: obs_key = 595;
pub const obs_key_OBS_KEY_0xD1: obs_key = 596;
pub const obs_key_OBS_KEY_0xD2: obs_key = 597;
pub const obs_key_OBS_KEY_0xD3: obs_key = 598;
pub const obs_key_OBS_KEY_0xD4: obs_key = 599;
pub const obs_key_OBS_KEY_0xD5: obs_key = 600;
pub const obs_key_OBS_KEY_0xD6: obs_key = 601;
pub const obs_key_OBS_KEY_0xD7: obs_key = 602;
pub const obs_key_OBS_KEY_0xD8: obs_key = 603;
pub const obs_key_OBS_KEY_0xD9: obs_key = 604;
pub const obs_key_OBS_KEY_0xDA: obs_key = 605;
pub const obs_key_OBS_KEY_VK_OEM_8: obs_key = 606;
pub const obs_key_OBS_KEY_0xE0: obs_key = 607;
pub const obs_key_OBS_KEY_VK_OEM_AX: obs_key = 608;
pub const obs_key_OBS_KEY_VK_ICO_HELP: obs_key = 609;
pub const obs_key_OBS_KEY_VK_ICO_00: obs_key = 610;
pub const obs_key_OBS_KEY_VK_PROCESSKEY: obs_key = 611;
pub const obs_key_OBS_KEY_VK_ICO_CLEAR: obs_key = 612;
pub const obs_key_OBS_KEY_VK_PACKET: obs_key = 613;
pub const obs_key_OBS_KEY_0xE8: obs_key = 614;
pub const obs_key_OBS_KEY_VK_OEM_RESET: obs_key = 615;
pub const obs_key_OBS_KEY_VK_OEM_JUMP: obs_key = 616;
pub const obs_key_OBS_KEY_VK_OEM_PA1: obs_key = 617;
pub const obs_key_OBS_KEY_VK_OEM_PA2: obs_key = 618;
pub const obs_key_OBS_KEY_VK_OEM_PA3: obs_key = 619;
pub const obs_key_OBS_KEY_VK_OEM_WSCTRL: obs_key = 620;
pub const obs_key_OBS_KEY_VK_OEM_CUSEL: obs_key = 621;
pub const obs_key_OBS_KEY_VK_OEM_ATTN: obs_key = 622;
pub const obs_key_OBS_KEY_VK_OEM_FINISH: obs_key = 623;
pub const obs_key_OBS_KEY_VK_OEM_COPY: obs_key = 624;
pub const obs_key_OBS_KEY_VK_OEM_AUTO: obs_key = 625;
pub const obs_key_OBS_KEY_VK_OEM_ENLW: obs_key = 626;
pub const obs_key_OBS_KEY_VK_ATTN: obs_key = 627;
pub const obs_key_OBS_KEY_VK_CRSEL: obs_key = 628;
pub const obs_key_OBS_KEY_VK_EXSEL: obs_key = 629;
pub const obs_key_OBS_KEY_VK_EREOF: obs_key = 630;
pub const obs_key_OBS_KEY_VK_PLAY: obs_key = 631;
pub const obs_key_OBS_KEY_VK_ZOOM: obs_key = 632;
pub const obs_key_OBS_KEY_VK_NONAME: obs_key = 633;
pub const obs_key_OBS_KEY_VK_PA1: obs_key = 634;
pub const obs_key_OBS_KEY_VK_OEM_CLEAR: obs_key = 635;
pub const obs_key_OBS_KEY_LAST_VALUE: obs_key = 636;
pub type obs_key = ::std::os::raw::c_int;
pub use self::obs_key as obs_key_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_key_combination {
    pub modifiers: u32,
    pub key: obs_key_t,
}
impl Default for obs_key_combination {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type obs_key_combination_t = obs_key_combination;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_hotkey {
    _unused: [u8; 0],
}
pub type obs_hotkey_t = obs_hotkey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_hotkey_binding {
    _unused: [u8; 0],
}
pub type obs_hotkey_binding_t = obs_hotkey_binding;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_FRONTEND: obs_hotkey_registerer_type = 0;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_SOURCE: obs_hotkey_registerer_type = 1;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_OUTPUT: obs_hotkey_registerer_type = 2;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_ENCODER: obs_hotkey_registerer_type = 3;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_SERVICE: obs_hotkey_registerer_type = 4;
pub type obs_hotkey_registerer_type = ::std::os::raw::c_int;
pub use self::obs_hotkey_registerer_type as obs_hotkey_registerer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_hotkeys_translations {
    pub insert: *const ::std::os::raw::c_char,
    pub del: *const ::std::os::raw::c_char,
    pub home: *const ::std::os::raw::c_char,
    pub end: *const ::std::os::raw::c_char,
    pub page_up: *const ::std::os::raw::c_char,
    pub page_down: *const ::std::os::raw::c_char,
    pub num_lock: *const ::std::os::raw::c_char,
    pub scroll_lock: *const ::std::os::raw::c_char,
    pub caps_lock: *const ::std::os::raw::c_char,
    pub backspace: *const ::std::os::raw::c_char,
    pub tab: *const ::std::os::raw::c_char,
    pub print: *const ::std::os::raw::c_char,
    pub pause: *const ::std::os::raw::c_char,
    pub left: *const ::std::os::raw::c_char,
    pub right: *const ::std::os::raw::c_char,
    pub up: *const ::std::os::raw::c_char,
    pub down: *const ::std::os::raw::c_char,
    pub shift: *const ::std::os::raw::c_char,
    pub alt: *const ::std::os::raw::c_char,
    pub control: *const ::std::os::raw::c_char,
    pub meta: *const ::std::os::raw::c_char,
    pub menu: *const ::std::os::raw::c_char,
    pub space: *const ::std::os::raw::c_char,
    pub numpad_num: *const ::std::os::raw::c_char,
    pub numpad_divide: *const ::std::os::raw::c_char,
    pub numpad_multiply: *const ::std::os::raw::c_char,
    pub numpad_minus: *const ::std::os::raw::c_char,
    pub numpad_plus: *const ::std::os::raw::c_char,
    pub numpad_decimal: *const ::std::os::raw::c_char,
    pub apple_keypad_num: *const ::std::os::raw::c_char,
    pub apple_keypad_divide: *const ::std::os::raw::c_char,
    pub apple_keypad_multiply: *const ::std::os::raw::c_char,
    pub apple_keypad_minus: *const ::std::os::raw::c_char,
    pub apple_keypad_plus: *const ::std::os::raw::c_char,
    pub apple_keypad_decimal: *const ::std::os::raw::c_char,
    pub apple_keypad_equal: *const ::std::os::raw::c_char,
    pub mouse_num: *const ::std::os::raw::c_char,
    pub escape: *const ::std::os::raw::c_char,
}
impl Default for obs_hotkeys_translations {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type obs_hotkey_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        id: obs_hotkey_id,
        hotkey: *mut obs_hotkey_t,
        pressed: bool,
    ),
>;
pub type obs_hotkey_active_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        id: obs_hotkey_pair_id,
        hotkey: *mut obs_hotkey_t,
        pressed: bool,
    ) -> bool,
>;
pub type obs_hotkey_enum_func = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: obs_hotkey_id, key: *mut obs_hotkey_t) -> bool,
>;
pub type obs_hotkey_binding_enum_func = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, idx: usize, binding: *mut obs_hotkey_binding_t) -> bool,
>;
pub type obs_hotkey_callback_router_func =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: obs_hotkey_id, pressed: bool)>;
pub type obs_hotkey_atomic_update_func = ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dstr {
    _unused: [u8; 0],
}
pub const obs_order_movement_OBS_ORDER_MOVE_UP: obs_order_movement = 0;
pub const obs_order_movement_OBS_ORDER_MOVE_DOWN: obs_order_movement = 1;
pub const obs_order_movement_OBS_ORDER_MOVE_TOP: obs_order_movement = 2;
pub const obs_order_movement_OBS_ORDER_MOVE_BOTTOM: obs_order_movement = 3;
#[doc = " Used for changing the order of items (for example, filters in a source,\n or items in a scene)"]
pub type obs_order_movement = ::std::os::raw::c_int;
pub const obs_allow_direct_render_OBS_NO_DIRECT_RENDERING: obs_allow_direct_render = 0;
pub const obs_allow_direct_render_OBS_ALLOW_DIRECT_RENDERING: obs_allow_direct_render = 1;
#[doc = " Used with obs_source_process_filter to specify whether the filter should\n render the source directly with the specified effect, or whether it should\n render it to a texture"]
pub type obs_allow_direct_render = ::std::os::raw::c_int;
pub const obs_scale_type_OBS_SCALE_DISABLE: obs_scale_type = 0;
pub const obs_scale_type_OBS_SCALE_POINT: obs_scale_type = 1;
pub const obs_scale_type_OBS_SCALE_BICUBIC: obs_scale_type = 2;
pub const obs_scale_type_OBS_SCALE_BILINEAR: obs_scale_type = 3;
pub const obs_scale_type_OBS_SCALE_LANCZOS: obs_scale_type = 4;
pub const obs_scale_type_OBS_SCALE_AREA: obs_scale_type = 5;
pub type obs_scale_type = ::std::os::raw::c_int;
pub const obs_blending_method_OBS_BLEND_METHOD_DEFAULT: obs_blending_method = 0;
pub const obs_blending_method_OBS_BLEND_METHOD_SRGB_OFF: obs_blending_method = 1;
pub type obs_blending_method = ::std::os::raw::c_int;
pub const obs_blending_type_OBS_BLEND_NORMAL: obs_blending_type = 0;
pub const obs_blending_type_OBS_BLEND_ADDITIVE: obs_blending_type = 1;
pub const obs_blending_type_OBS_BLEND_SUBTRACT: obs_blending_type = 2;
pub const obs_blending_type_OBS_BLEND_SCREEN: obs_blending_type = 3;
pub const obs_blending_type_OBS_BLEND_MULTIPLY: obs_blending_type = 4;
pub const obs_blending_type_OBS_BLEND_LIGHTEN: obs_blending_type = 5;
pub const obs_blending_type_OBS_BLEND_DARKEN: obs_blending_type = 6;
pub type obs_blending_type = ::std::os::raw::c_int;
#[doc = "< no bounds"]
pub const obs_bounds_type_OBS_BOUNDS_NONE: obs_bounds_type = 0;
#[doc = "< stretch (ignores base scale)"]
pub const obs_bounds_type_OBS_BOUNDS_STRETCH: obs_bounds_type = 1;
#[doc = "< scales to inner rectangle"]
pub const obs_bounds_type_OBS_BOUNDS_SCALE_INNER: obs_bounds_type = 2;
#[doc = "< scales to outer rectangle"]
pub const obs_bounds_type_OBS_BOUNDS_SCALE_OUTER: obs_bounds_type = 3;
#[doc = "< scales to the width"]
pub const obs_bounds_type_OBS_BOUNDS_SCALE_TO_WIDTH: obs_bounds_type = 4;
#[doc = "< scales to the height"]
pub const obs_bounds_type_OBS_BOUNDS_SCALE_TO_HEIGHT: obs_bounds_type = 5;
#[doc = "< no scaling, maximum size only"]
pub const obs_bounds_type_OBS_BOUNDS_MAX_ONLY: obs_bounds_type = 6;
#[doc = " Used with scene items to indicate the type of bounds to use for scene items.\n Mostly determines how the image will be scaled within those bounds, or\n whether to use bounds at all."]
pub type obs_bounds_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct obs_transform_info {
    pub pos: vec2,
    pub rot: f32,
    pub scale: vec2,
    pub alignment: u32,
    pub bounds_type: obs_bounds_type,
    pub bounds_alignment: u32,
    pub bounds: vec2,
    pub crop_to_bounds: bool,
}
impl Default for obs_transform_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Video initialization structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_video_info {
    #[doc = " Graphics module to use (usually \"libobs-opengl\" or \"libobs-d3d11\")"]
    pub graphics_module: *const ::std::os::raw::c_char,
    #[doc = "< Output FPS numerator"]
    pub fps_num: u32,
    #[doc = "< Output FPS denominator"]
    pub fps_den: u32,
    #[doc = "< Base compositing width"]
    pub base_width: u32,
    #[doc = "< Base compositing height"]
    pub base_height: u32,
    #[doc = "< Output width"]
    pub output_width: u32,
    #[doc = "< Output height"]
    pub output_height: u32,
    #[doc = "< Output format"]
    pub output_format: video_format,
    #[doc = " Video adapter index to use (NOTE: avoid for optimus laptops)"]
    pub adapter: u32,
    #[doc = " Use shaders to convert to different color formats"]
    pub gpu_conversion: bool,
    #[doc = "< YUV type (if YUV)"]
    pub colorspace: video_colorspace,
    #[doc = "< YUV range (if YUV)"]
    pub range: video_range_type,
    #[doc = "< How to scale if scaling"]
    pub scale_type: obs_scale_type,
}
impl Default for obs_video_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Audio initialization structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_audio_info {
    pub samples_per_sec: u32,
    pub speakers: speaker_layout,
}
impl Default for obs_audio_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_audio_info2 {
    pub samples_per_sec: u32,
    pub speakers: speaker_layout,
    pub max_buffering_ms: u32,
    pub fixed_buffering: bool,
}
impl Default for obs_audio_info2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Sent to source filters via the filter_audio callback to allow filtering of\n audio data"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_audio_data {
    pub data: [*mut u8; 8usize],
    pub frames: u32,
    pub timestamp: u64,
}
impl Default for obs_audio_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Source audio output structure.  Used with obs_source_output_audio to output\n source audio.  Audio is automatically resampled and remixed as necessary."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_source_audio {
    pub data: [*const u8; 8usize],
    pub frames: u32,
    pub speakers: speaker_layout,
    pub format: audio_format,
    pub samples_per_sec: u32,
    pub timestamp: u64,
}
impl Default for obs_source_audio {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_source_cea_708 {
    pub data: *const u8,
    pub packets: u32,
    pub timestamp: u64,
}
impl Default for obs_source_cea_708 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Source asynchronous video output structure.  Used with\n obs_source_output_video to output asynchronous video.  Video is buffered as\n necessary to play according to timestamps.  When used with audio output,\n audio is synced to video as it is played.\n\n If a YUV format is specified, it will be automatically upsampled and\n converted to RGB via shader on the graphics processor.\n\n NOTE: Non-YUV formats will always be treated as full range with this\n structure!  Use obs_source_frame2 along with obs_source_output_video2\n instead if partial range support is desired for non-YUV video formats."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct obs_source_frame {
    pub data: [*mut u8; 8usize],
    pub linesize: [u32; 8usize],
    pub width: u32,
    pub height: u32,
    pub timestamp: u64,
    pub format: video_format,
    pub color_matrix: [f32; 16usize],
    pub full_range: bool,
    pub max_luminance: u16,
    pub color_range_min: [f32; 3usize],
    pub color_range_max: [f32; 3usize],
    pub flip: bool,
    pub flags: u8,
    pub trc: u8,
    pub refs: ::std::os::raw::c_long,
    pub prev_frame: bool,
}
impl Default for obs_source_frame {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct obs_source_frame2 {
    pub data: [*mut u8; 8usize],
    pub linesize: [u32; 8usize],
    pub width: u32,
    pub height: u32,
    pub timestamp: u64,
    pub format: video_format,
    pub range: video_range_type,
    pub color_matrix: [f32; 16usize],
    pub color_range_min: [f32; 3usize],
    pub color_range_max: [f32; 3usize],
    pub flip: bool,
    pub flags: u8,
    pub trc: u8,
}
impl Default for obs_source_frame2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Access to the argc/argv used to start OBS. What you see is what you get."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_cmdline_args {
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *mut ::std::os::raw::c_char,
}
impl Default for obs_cmdline_args {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_module_failure_info {
    pub failed_modules: *mut *mut ::std::os::raw::c_char,
    pub count: usize,
}
impl Default for obs_module_failure_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_module_info {
    pub bin_path: *const ::std::os::raw::c_char,
    pub data_path: *const ::std::os::raw::c_char,
}
impl Default for obs_module_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type obs_find_module_callback_t =
    ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, info: *const obs_module_info)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_module_info2 {
    pub bin_path: *const ::std::os::raw::c_char,
    pub data_path: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
}
impl Default for obs_module_info2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type obs_find_module_callback2_t =
    ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, info: *const obs_module_info2)>;
pub type obs_enum_module_callback_t =
    ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, module: *mut obs_module_t)>;
#[doc = "< RGB/YUV"]
pub const obs_base_effect_OBS_EFFECT_DEFAULT: obs_base_effect = 0;
#[doc = "< RGB/YUV (using texture_rect)"]
pub const obs_base_effect_OBS_EFFECT_DEFAULT_RECT: obs_base_effect = 1;
#[doc = "< RGB/YUV (alpha set to 1.0)"]
pub const obs_base_effect_OBS_EFFECT_OPAQUE: obs_base_effect = 2;
#[doc = "< RGB/YUV (solid color only)"]
pub const obs_base_effect_OBS_EFFECT_SOLID: obs_base_effect = 3;
#[doc = "< Bicubic downscale"]
pub const obs_base_effect_OBS_EFFECT_BICUBIC: obs_base_effect = 4;
#[doc = "< Lanczos downscale"]
pub const obs_base_effect_OBS_EFFECT_LANCZOS: obs_base_effect = 5;
#[doc = "< Bilinear low resolution downscale"]
pub const obs_base_effect_OBS_EFFECT_BILINEAR_LOWRES: obs_base_effect = 6;
#[doc = "< Premultiplied alpha"]
pub const obs_base_effect_OBS_EFFECT_PREMULTIPLIED_ALPHA: obs_base_effect = 7;
#[doc = "< RGB/YUV (repeating)"]
pub const obs_base_effect_OBS_EFFECT_REPEAT: obs_base_effect = 8;
#[doc = "< Area rescale"]
pub const obs_base_effect_OBS_EFFECT_AREA: obs_base_effect = 9;
pub type obs_base_effect = ::std::os::raw::c_int;
pub type obs_load_source_cb =
    ::std::option::Option<unsafe extern "C" fn(private_data: *mut ::std::os::raw::c_void, source: *mut obs_source_t)>;
pub type obs_save_source_filter_cb =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, source: *mut obs_source_t) -> bool>;
pub const obs_obj_type_OBS_OBJ_TYPE_INVALID: obs_obj_type = 0;
pub const obs_obj_type_OBS_OBJ_TYPE_SOURCE: obs_obj_type = 1;
pub const obs_obj_type_OBS_OBJ_TYPE_OUTPUT: obs_obj_type = 2;
pub const obs_obj_type_OBS_OBJ_TYPE_ENCODER: obs_obj_type = 3;
pub const obs_obj_type_OBS_OBJ_TYPE_SERVICE: obs_obj_type = 4;
pub type obs_obj_type = ::std::os::raw::c_int;
pub type obs_enum_audio_device_cb = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        id: *const ::std::os::raw::c_char,
    ) -> bool,
>;
pub type obs_task_t = ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>;
pub const obs_task_type_OBS_TASK_UI: obs_task_type = 0;
pub const obs_task_type_OBS_TASK_GRAPHICS: obs_task_type = 1;
pub const obs_task_type_OBS_TASK_AUDIO: obs_task_type = 2;
pub const obs_task_type_OBS_TASK_DESTROY: obs_task_type = 3;
pub type obs_task_type = ::std::os::raw::c_int;
pub type obs_task_handler_t =
    ::std::option::Option<unsafe extern "C" fn(task: obs_task_t, param: *mut ::std::os::raw::c_void, wait: bool)>;
pub type obs_source_audio_capture_t = ::std::option::Option<
    unsafe extern "C" fn(
        param: *mut ::std::os::raw::c_void,
        source: *mut obs_source_t,
        audio_data: *const audio_data,
        muted: bool,
    ),
>;
pub type obs_source_caption_t = ::std::option::Option<
    unsafe extern "C" fn(
        param: *mut ::std::os::raw::c_void,
        source: *mut obs_source_t,
        captions: *const obs_source_cea_708,
    ),
>;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_DISABLE: obs_deinterlace_mode = 0;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_DISCARD: obs_deinterlace_mode = 1;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_RETRO: obs_deinterlace_mode = 2;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_BLEND: obs_deinterlace_mode = 3;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_BLEND_2X: obs_deinterlace_mode = 4;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_LINEAR: obs_deinterlace_mode = 5;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_LINEAR_2X: obs_deinterlace_mode = 6;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_YADIF: obs_deinterlace_mode = 7;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_YADIF_2X: obs_deinterlace_mode = 8;
pub type obs_deinterlace_mode = ::std::os::raw::c_int;
pub const obs_deinterlace_field_order_OBS_DEINTERLACE_FIELD_ORDER_TOP: obs_deinterlace_field_order = 0;
pub const obs_deinterlace_field_order_OBS_DEINTERLACE_FIELD_ORDER_BOTTOM: obs_deinterlace_field_order = 1;
pub type obs_deinterlace_field_order = ::std::os::raw::c_int;
pub const obs_monitoring_type_OBS_MONITORING_TYPE_NONE: obs_monitoring_type = 0;
pub const obs_monitoring_type_OBS_MONITORING_TYPE_MONITOR_ONLY: obs_monitoring_type = 1;
pub const obs_monitoring_type_OBS_MONITORING_TYPE_MONITOR_AND_OUTPUT: obs_monitoring_type = 2;
pub type obs_monitoring_type = ::std::os::raw::c_int;
pub const obs_transition_target_OBS_TRANSITION_SOURCE_A: obs_transition_target = 0;
pub const obs_transition_target_OBS_TRANSITION_SOURCE_B: obs_transition_target = 1;
pub type obs_transition_target = ::std::os::raw::c_int;
pub const obs_transition_mode_OBS_TRANSITION_MODE_AUTO: obs_transition_mode = 0;
pub const obs_transition_mode_OBS_TRANSITION_MODE_MANUAL: obs_transition_mode = 1;
pub type obs_transition_mode = ::std::os::raw::c_int;
pub const obs_transition_scale_type_OBS_TRANSITION_SCALE_MAX_ONLY: obs_transition_scale_type = 0;
pub const obs_transition_scale_type_OBS_TRANSITION_SCALE_ASPECT: obs_transition_scale_type = 1;
pub const obs_transition_scale_type_OBS_TRANSITION_SCALE_STRETCH: obs_transition_scale_type = 2;
pub type obs_transition_scale_type = ::std::os::raw::c_int;
pub type obs_transition_video_render_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        a: *mut gs_texture_t,
        b: *mut gs_texture_t,
        t: f32,
        cx: u32,
        cy: u32,
    ),
>;
pub type obs_transition_audio_mix_callback_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, t: f32) -> f32>;
#[doc = "< Source refs only"]
pub const obs_scene_duplicate_type_OBS_SCENE_DUP_REFS: obs_scene_duplicate_type = 0;
#[doc = "< Fully duplicate"]
pub const obs_scene_duplicate_type_OBS_SCENE_DUP_COPY: obs_scene_duplicate_type = 1;
#[doc = "< Source refs only (as private)"]
pub const obs_scene_duplicate_type_OBS_SCENE_DUP_PRIVATE_REFS: obs_scene_duplicate_type = 2;
#[doc = "< Fully duplicate (as private)"]
pub const obs_scene_duplicate_type_OBS_SCENE_DUP_PRIVATE_COPY: obs_scene_duplicate_type = 3;
pub type obs_scene_duplicate_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_sceneitem_order_info {
    pub group: *mut obs_sceneitem_t,
    pub item: *mut obs_sceneitem_t,
}
impl Default for obs_sceneitem_order_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type obs_scene_atomic_update_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, scene: *mut obs_scene_t)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct obs_sceneitem_crop {
    pub left: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub static mut __security_cookie: usize;
    pub fn base_get_log_handler(handler: *mut log_handler_t, param: *mut *mut ::std::os::raw::c_void);
    pub fn base_set_log_handler(handler: log_handler_t, param: *mut ::std::os::raw::c_void);
    pub fn base_set_crash_handler(
        handler: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char, arg2: va_list, arg3: *mut ::std::os::raw::c_void),
        >,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn blogva(log_level: ::std::os::raw::c_int, format: *const ::std::os::raw::c_char, args: va_list);
    pub fn blog(log_level: ::std::os::raw::c_int, format: *const ::std::os::raw::c_char, ...);
    pub fn bcrash(format: *const ::std::os::raw::c_char, ...) -> !;
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
    pub fn strchr(_Str: *const ::std::os::raw::c_char, _Val: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn strrchr(_Str: *const ::std::os::raw::c_char, _Ch: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn wcschr(
        _Str: *const ::std::os::raw::c_ushort,
        _Ch: ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
    pub fn iswalnum(_C: wint_t) -> ::std::os::raw::c_int;
    pub fn iswalpha(_C: wint_t) -> ::std::os::raw::c_int;
    pub fn iswascii(_C: wint_t) -> ::std::os::raw::c_int;
    pub fn iswblank(_C: wint_t) -> ::std::os::raw::c_int;
    pub fn iswcntrl(_C: wint_t) -> ::std::os::raw::c_int;
    pub fn iswdigit(_C: wint_t) -> ::std::os::raw::c_int;
    pub fn iswgraph(_C: wint_t) -> ::std::os::raw::c_int;
    pub fn iswlower(_C: wint_t) -> ::std::os::raw::c_int;
    pub fn iswprint(_C: wint_t) -> ::std::os::raw::c_int;
    pub fn iswpunct(_C: wint_t) -> ::std::os::raw::c_int;
    pub fn iswspace(_C: wint_t) -> ::std::os::raw::c_int;
    pub fn iswupper(_C: wint_t) -> ::std::os::raw::c_int;
    pub fn iswxdigit(_C: wint_t) -> ::std::os::raw::c_int;
    pub fn towupper(_C: wint_t) -> wint_t;
    pub fn towlower(_C: wint_t) -> wint_t;
    pub fn iswctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
    pub fn isleadbyte(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn is_wctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
    pub fn fputwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
    pub fn getwchar() -> wint_t;
    pub fn fgetws(_Buffer: *mut wchar_t, _BufferCount: ::std::os::raw::c_int, _Stream: *mut FILE) -> *mut wchar_t;
    pub fn fputws(_Buffer: *const wchar_t, _Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn putwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
    pub fn putwchar(_Character: wchar_t) -> wint_t;
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
    pub fn wcscat_s(_Destination: *mut wchar_t, _SizeInWords: rsize_t, _Source: *const wchar_t) -> errno_t;
    pub fn wcscpy_s(_Destination: *mut wchar_t, _SizeInWords: rsize_t, _Source: *const wchar_t) -> errno_t;
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
    pub fn wcstok_s(_String: *mut wchar_t, _Delimiter: *const wchar_t, _Context: *mut *mut wchar_t) -> *mut wchar_t;
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
    pub fn wcscmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
    pub fn wcslen(_String: *const ::std::os::raw::c_ushort) -> ::std::os::raw::c_ulonglong;
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: usize) -> usize;
    pub fn wcsncat(_Destination: *mut wchar_t, _Source: *const wchar_t, _Count: usize) -> *mut wchar_t;
    pub fn wcsncmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
    pub fn wcsncpy(_Destination: *mut wchar_t, _Source: *const wchar_t, _Count: usize) -> *mut wchar_t;
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
    pub fn wcstok(_String: *mut wchar_t, _Delimiter: *const wchar_t, _Context: *mut *mut wchar_t) -> *mut wchar_t;
    pub fn wcsxfrm(_Destination: *mut wchar_t, _Source: *const wchar_t, _MaxCount: usize) -> usize;
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
    pub fn wcsnicmp(_String1: *const wchar_t, _String2: *const wchar_t, _MaxCount: usize) -> ::std::os::raw::c_int;
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
    pub fn wcsftime(_Buffer: *mut wchar_t, _SizeInWords: usize, _Format: *const wchar_t, _Tm: *const tm) -> usize;
    pub fn btowc(_Ch: ::std::os::raw::c_int) -> wint_t;
    pub fn mbrlen(_Ch: *const ::std::os::raw::c_char, _SizeInBytes: usize, _State: *mut mbstate_t) -> usize;
    pub fn mbrtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _State: *mut mbstate_t,
    ) -> usize;
    pub fn mbsrtowcs_s(
        _Retval: *mut usize,
        _Dst: *mut wchar_t,
        _Size: usize,
        _PSrc: *mut *const ::std::os::raw::c_char,
        _N: usize,
        _State: *mut mbstate_t,
    ) -> errno_t;
    pub fn mbsrtowcs(
        _Dest: *mut wchar_t,
        _PSrc: *mut *const ::std::os::raw::c_char,
        _Count: usize,
        _State: *mut mbstate_t,
    ) -> usize;
    pub fn wcrtomb_s(
        _Retval: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Ch: wchar_t,
        _State: *mut mbstate_t,
    ) -> errno_t;
    pub fn wcrtomb(_Dest: *mut ::std::os::raw::c_char, _Source: wchar_t, _State: *mut mbstate_t) -> usize;
    pub fn wcsrtombs_s(
        _Retval: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Src: *mut *const wchar_t,
        _Size: usize,
        _State: *mut mbstate_t,
    ) -> errno_t;
    pub fn wcsrtombs(
        _Dest: *mut ::std::os::raw::c_char,
        _PSource: *mut *const wchar_t,
        _Count: usize,
        _State: *mut mbstate_t,
    ) -> usize;
    pub fn wctob(_WCh: wint_t) -> ::std::os::raw::c_int;
    pub fn wmemcpy_s(_S1: *mut wchar_t, _N1: rsize_t, _S2: *const wchar_t, _N: rsize_t) -> errno_t;
    pub fn wmemmove_s(_S1: *mut wchar_t, _N1: rsize_t, _S2: *const wchar_t, _N: rsize_t) -> errno_t;
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
    pub fn strcpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
    pub fn strcat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
    pub fn strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
    pub fn strncat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
    pub fn strncpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
    pub fn strtok_s(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strcat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strcmp(_Str1: *const ::std::os::raw::c_char, _Str2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn strcoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn strcpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
    pub fn strerror(_ErrorMessage: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulonglong;
    pub fn strncat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
    pub fn strncpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
    pub fn strtok(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strxfrm(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
    pub fn strdup(_String: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
    pub fn strnset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strrev(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn strset(_String: *mut ::std::os::raw::c_char, _Value: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn base_set_allocator(defs: *mut base_allocator);
    pub fn bmalloc(size: usize) -> *mut ::std::os::raw::c_void;
    pub fn brealloc(ptr: *mut ::std::os::raw::c_void, size: usize) -> *mut ::std::os::raw::c_void;
    pub fn bfree(ptr: *mut ::std::os::raw::c_void);
    pub fn base_get_alignment() -> ::std::os::raw::c_int;
    pub fn bnum_allocs() -> ::std::os::raw::c_long;
    pub fn bmemdup(ptr: *const ::std::os::raw::c_void, size: usize) -> *mut ::std::os::raw::c_void;
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
    pub fn free(_Block: *mut ::std::os::raw::c_void);
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
    pub fn exit(_Code: ::std::os::raw::c_int) -> !;
    pub fn quick_exit(_Code: ::std::os::raw::c_int) -> !;
    pub fn abort() -> !;
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
    pub fn at_quick_exit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
    pub fn abs(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn labs(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
    pub fn llabs(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long) -> ldiv_t;
    pub fn lldiv(_Numerator: ::std::os::raw::c_longlong, _Denominator: ::std::os::raw::c_longlong) -> lldiv_t;
    pub fn srand(_Seed: ::std::os::raw::c_uint);
    pub fn rand() -> ::std::os::raw::c_int;
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
    pub fn strtof(_String: *const ::std::os::raw::c_char, _EndPtr: *mut *mut ::std::os::raw::c_char) -> f32;
    pub fn strtod(_String: *const ::std::os::raw::c_char, _EndPtr: *mut *mut ::std::os::raw::c_char) -> f64;
    pub fn strtold(_String: *const ::std::os::raw::c_char, _EndPtr: *mut *mut ::std::os::raw::c_char) -> f64;
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
    pub fn mbstowcs(_Dest: *mut wchar_t, _Source: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
    pub fn wcstombs(_Dest: *mut ::std::os::raw::c_char, _Source: *const wchar_t, _MaxCount: usize) -> usize;
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
    pub fn profile_register_root(name: *const ::std::os::raw::c_char, expected_time_between_calls: u64);
    pub fn profile_start(name: *const ::std::os::raw::c_char);
    pub fn profile_end(name: *const ::std::os::raw::c_char);
    pub fn profile_reenable_thread();
    pub fn profiler_start();
    pub fn profiler_stop();
    pub fn profiler_print(snap: *mut profiler_snapshot_t);
    pub fn profiler_print_time_between_calls(snap: *mut profiler_snapshot_t);
    pub fn profiler_free();
    pub fn profiler_name_store_create() -> *mut profiler_name_store_t;
    pub fn profiler_name_store_free(store: *mut profiler_name_store_t);
    pub fn profile_store_name(
        store: *mut profiler_name_store_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *const ::std::os::raw::c_char;
    pub fn profile_snapshot_create() -> *mut profiler_snapshot_t;
    pub fn profile_snapshot_free(snap: *mut profiler_snapshot_t);
    pub fn profiler_snapshot_dump_csv(
        snap: *const profiler_snapshot_t,
        filename: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn profiler_snapshot_dump_csv_gz(
        snap: *const profiler_snapshot_t,
        filename: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn profiler_snapshot_num_roots(snap: *mut profiler_snapshot_t) -> usize;
    pub fn profiler_snapshot_enumerate_roots(
        snap: *mut profiler_snapshot_t,
        func: profiler_entry_enum_func,
        context: *mut ::std::os::raw::c_void,
    );
    pub fn profiler_snapshot_filter_roots(
        snap: *mut profiler_snapshot_t,
        func: profiler_name_filter_func,
        data: *mut ::std::os::raw::c_void,
    );
    pub fn profiler_snapshot_num_children(entry: *mut profiler_snapshot_entry_t) -> usize;
    pub fn profiler_snapshot_enumerate_children(
        entry: *mut profiler_snapshot_entry_t,
        func: profiler_entry_enum_func,
        context: *mut ::std::os::raw::c_void,
    );
    pub fn profiler_snapshot_entry_name(entry: *mut profiler_snapshot_entry_t) -> *const ::std::os::raw::c_char;
    pub fn profiler_snapshot_entry_times(entry: *mut profiler_snapshot_entry_t) -> *mut profiler_time_entries_t;
    pub fn profiler_snapshot_entry_min_time(entry: *mut profiler_snapshot_entry_t) -> u64;
    pub fn profiler_snapshot_entry_max_time(entry: *mut profiler_snapshot_entry_t) -> u64;
    pub fn profiler_snapshot_entry_overall_count(entry: *mut profiler_snapshot_entry_t) -> u64;
    pub fn profiler_snapshot_entry_times_between_calls(
        entry: *mut profiler_snapshot_entry_t,
    ) -> *mut profiler_time_entries_t;
    pub fn profiler_snapshot_entry_expected_time_between_calls(entry: *mut profiler_snapshot_entry_t) -> u64;
    pub fn profiler_snapshot_entry_min_time_between_calls(entry: *mut profiler_snapshot_entry_t) -> u64;
    pub fn profiler_snapshot_entry_max_time_between_calls(entry: *mut profiler_snapshot_entry_t) -> u64;
    pub fn profiler_snapshot_entry_overall_between_calls_count(entry: *mut profiler_snapshot_entry_t) -> u64;
    pub fn text_lookup_create(path: *const ::std::os::raw::c_char) -> *mut lookup_t;
    pub fn text_lookup_add(lookup: *mut lookup_t, path: *const ::std::os::raw::c_char) -> bool;
    pub fn text_lookup_destroy(lookup: *mut lookup_t);
    pub fn text_lookup_getstr(
        lookup: *mut lookup_t,
        lookup_val: *const ::std::os::raw::c_char,
        out: *mut *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn input_getbuttonstate(input: *mut input_t, button: u32) -> ::std::os::raw::c_int;
    pub fn gs_shader_destroy(shader: *mut gs_shader_t);
    pub fn gs_shader_get_num_params(shader: *const gs_shader_t) -> ::std::os::raw::c_int;
    pub fn gs_shader_get_param_by_idx(shader: *mut gs_shader_t, param: u32) -> *mut gs_sparam_t;
    pub fn gs_shader_get_param_by_name(
        shader: *mut gs_shader_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_sparam_t;
    pub fn gs_shader_get_viewproj_matrix(shader: *const gs_shader_t) -> *mut gs_sparam_t;
    pub fn gs_shader_get_world_matrix(shader: *const gs_shader_t) -> *mut gs_sparam_t;
    pub fn gs_shader_get_param_info(param: *const gs_sparam_t, info: *mut gs_shader_param_info);
    pub fn gs_shader_set_bool(param: *mut gs_sparam_t, val: bool);
    pub fn gs_shader_set_float(param: *mut gs_sparam_t, val: f32);
    pub fn gs_shader_set_int(param: *mut gs_sparam_t, val: ::std::os::raw::c_int);
    pub fn gs_shader_set_matrix3(param: *mut gs_sparam_t, val: *const matrix3);
    pub fn gs_shader_set_matrix4(param: *mut gs_sparam_t, val: *const matrix4);
    pub fn gs_shader_set_vec2(param: *mut gs_sparam_t, val: *const vec2);
    pub fn gs_shader_set_vec3(param: *mut gs_sparam_t, val: *const vec3);
    pub fn gs_shader_set_vec4(param: *mut gs_sparam_t, val: *const vec4);
    pub fn gs_shader_set_texture(param: *mut gs_sparam_t, val: *mut gs_texture_t);
    pub fn gs_shader_set_val(param: *mut gs_sparam_t, val: *const ::std::os::raw::c_void, size: usize);
    pub fn gs_shader_set_default(param: *mut gs_sparam_t);
    pub fn gs_shader_set_next_sampler(param: *mut gs_sparam_t, sampler: *mut gs_samplerstate_t);
    pub fn gs_effect_destroy(effect: *mut gs_effect_t);
    pub fn gs_effect_get_technique(
        effect: *const gs_effect_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_technique_t;
    pub fn gs_effect_get_current_technique(effect: *const gs_effect_t) -> *mut gs_technique_t;
    pub fn gs_technique_begin(technique: *mut gs_technique_t) -> usize;
    pub fn gs_technique_end(technique: *mut gs_technique_t);
    pub fn gs_technique_begin_pass(technique: *mut gs_technique_t, pass: usize) -> bool;
    pub fn gs_technique_begin_pass_by_name(technique: *mut gs_technique_t, name: *const ::std::os::raw::c_char)
        -> bool;
    pub fn gs_technique_end_pass(technique: *mut gs_technique_t);
    pub fn gs_technique_get_pass_by_idx(technique: *const gs_technique_t, pass: usize) -> *mut gs_epass_t;
    pub fn gs_technique_get_pass_by_name(
        technique: *const gs_technique_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_epass_t;
    pub fn gs_effect_get_num_params(effect: *const gs_effect_t) -> usize;
    pub fn gs_effect_get_param_by_idx(effect: *const gs_effect_t, param: usize) -> *mut gs_eparam_t;
    pub fn gs_effect_get_param_by_name(
        effect: *const gs_effect_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_eparam_t;
    pub fn gs_param_get_num_annotations(param: *const gs_eparam_t) -> usize;
    pub fn gs_param_get_annotation_by_idx(param: *const gs_eparam_t, annotation: usize) -> *mut gs_eparam_t;
    pub fn gs_param_get_annotation_by_name(
        param: *const gs_eparam_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_eparam_t;
    #[doc = " Helper function to simplify effect usage.  Use with a while loop that\n contains drawing functions.  Automatically handles techniques, passes, and\n unloading."]
    pub fn gs_effect_loop(effect: *mut gs_effect_t, name: *const ::std::os::raw::c_char) -> bool;
    #[doc = " used internally"]
    pub fn gs_effect_update_params(effect: *mut gs_effect_t);
    pub fn gs_effect_get_viewproj_matrix(effect: *const gs_effect_t) -> *mut gs_eparam_t;
    pub fn gs_effect_get_world_matrix(effect: *const gs_effect_t) -> *mut gs_eparam_t;
    pub fn gs_effect_get_param_info(param: *const gs_eparam_t, info: *mut gs_effect_param_info);
    pub fn gs_effect_set_bool(param: *mut gs_eparam_t, val: bool);
    pub fn gs_effect_set_float(param: *mut gs_eparam_t, val: f32);
    pub fn gs_effect_set_int(param: *mut gs_eparam_t, val: ::std::os::raw::c_int);
    pub fn gs_effect_set_matrix4(param: *mut gs_eparam_t, val: *const matrix4);
    pub fn gs_effect_set_vec2(param: *mut gs_eparam_t, val: *const vec2);
    pub fn gs_effect_set_vec3(param: *mut gs_eparam_t, val: *const vec3);
    pub fn gs_effect_set_vec4(param: *mut gs_eparam_t, val: *const vec4);
    pub fn gs_effect_set_texture(param: *mut gs_eparam_t, val: *mut gs_texture_t);
    pub fn gs_effect_set_texture_srgb(param: *mut gs_eparam_t, val: *mut gs_texture_t);
    pub fn gs_effect_set_val(param: *mut gs_eparam_t, val: *const ::std::os::raw::c_void, size: usize);
    pub fn gs_effect_set_default(param: *mut gs_eparam_t);
    pub fn gs_effect_get_val_size(param: *mut gs_eparam_t) -> usize;
    pub fn gs_effect_get_val(param: *mut gs_eparam_t) -> *mut ::std::os::raw::c_void;
    pub fn gs_effect_get_default_val_size(param: *mut gs_eparam_t) -> usize;
    pub fn gs_effect_get_default_val(param: *mut gs_eparam_t) -> *mut ::std::os::raw::c_void;
    pub fn gs_effect_set_next_sampler(param: *mut gs_eparam_t, sampler: *mut gs_samplerstate_t);
    pub fn gs_effect_set_color(param: *mut gs_eparam_t, argb: u32);
    pub fn gs_texrender_create(format: gs_color_format, zsformat: gs_zstencil_format) -> *mut gs_texrender_t;
    pub fn gs_texrender_destroy(texrender: *mut gs_texrender_t);
    pub fn gs_texrender_begin(texrender: *mut gs_texrender_t, cx: u32, cy: u32) -> bool;
    pub fn gs_texrender_begin_with_color_space(
        texrender: *mut gs_texrender_t,
        cx: u32,
        cy: u32,
        space: gs_color_space,
    ) -> bool;
    pub fn gs_texrender_end(texrender: *mut gs_texrender_t);
    pub fn gs_texrender_reset(texrender: *mut gs_texrender_t);
    pub fn gs_texrender_get_texture(texrender: *const gs_texrender_t) -> *mut gs_texture_t;
    pub fn gs_texrender_get_format(texrender: *const gs_texrender_t) -> gs_color_format;
    pub fn gs_get_device_name() -> *const ::std::os::raw::c_char;
    pub fn gs_get_device_type() -> ::std::os::raw::c_int;
    pub fn gs_get_adapter_count() -> u32;
    pub fn gs_enum_adapters(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                param: *mut ::std::os::raw::c_void,
                name: *const ::std::os::raw::c_char,
                id: u32,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn gs_create(
        graphics: *mut *mut graphics_t,
        module: *const ::std::os::raw::c_char,
        adapter: u32,
    ) -> ::std::os::raw::c_int;
    pub fn gs_destroy(graphics: *mut graphics_t);
    pub fn gs_enter_context(graphics: *mut graphics_t);
    pub fn gs_leave_context();
    pub fn gs_get_context() -> *mut graphics_t;
    pub fn gs_get_device_obj() -> *mut ::std::os::raw::c_void;
    pub fn gs_matrix_push();
    pub fn gs_matrix_pop();
    pub fn gs_matrix_identity();
    pub fn gs_matrix_transpose();
    pub fn gs_matrix_set(matrix: *const matrix4);
    pub fn gs_matrix_get(dst: *mut matrix4);
    pub fn gs_matrix_mul(matrix: *const matrix4);
    pub fn gs_matrix_rotquat(rot: *const quat);
    pub fn gs_matrix_rotaa(rot: *const axisang);
    pub fn gs_matrix_translate(pos: *const vec3);
    pub fn gs_matrix_scale(scale: *const vec3);
    pub fn gs_matrix_rotaa4f(x: f32, y: f32, z: f32, angle: f32);
    pub fn gs_matrix_translate3f(x: f32, y: f32, z: f32);
    pub fn gs_matrix_scale3f(x: f32, y: f32, z: f32);
    pub fn gs_render_start(b_new: bool);
    pub fn gs_render_stop(mode: gs_draw_mode);
    pub fn gs_render_save() -> *mut gs_vertbuffer_t;
    pub fn gs_vertex2f(x: f32, y: f32);
    pub fn gs_vertex3f(x: f32, y: f32, z: f32);
    pub fn gs_normal3f(x: f32, y: f32, z: f32);
    pub fn gs_color(color: u32);
    pub fn gs_texcoord(x: f32, y: f32, unit: ::std::os::raw::c_int);
    pub fn gs_vertex2v(v: *const vec2);
    pub fn gs_vertex3v(v: *const vec3);
    pub fn gs_normal3v(v: *const vec3);
    pub fn gs_color4v(v: *const vec4);
    pub fn gs_texcoord2v(v: *const vec2, unit: ::std::os::raw::c_int);
    pub fn gs_get_input() -> *mut input_t;
    pub fn gs_get_effect() -> *mut gs_effect_t;
    pub fn gs_effect_create_from_file(
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_effect_t;
    pub fn gs_effect_create(
        effect_string: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_effect_t;
    pub fn gs_vertexshader_create_from_file(
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_shader_t;
    pub fn gs_pixelshader_create_from_file(
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_shader_t;
    pub fn gs_texture_create_from_file(file: *const ::std::os::raw::c_char) -> *mut gs_texture_t;
    pub fn gs_create_texture_file_data(
        file: *const ::std::os::raw::c_char,
        format: *mut gs_color_format,
        cx: *mut u32,
        cy: *mut u32,
    ) -> *mut u8;
    pub fn gs_create_texture_file_data2(
        file: *const ::std::os::raw::c_char,
        alpha_mode: gs_image_alpha_mode,
        format: *mut gs_color_format,
        cx: *mut u32,
        cy: *mut u32,
    ) -> *mut u8;
    pub fn gs_create_texture_file_data3(
        file: *const ::std::os::raw::c_char,
        alpha_mode: gs_image_alpha_mode,
        format: *mut gs_color_format,
        cx: *mut u32,
        cy: *mut u32,
        space: *mut gs_color_space,
    ) -> *mut u8;
    #[doc = " Draws a 2D sprite\n\n   If width or height is 0, the width or height of the texture will be used.\n The flip value specifies whether the texture should be flipped on the U or V\n axis with GS_FLIP_U and GS_FLIP_V."]
    pub fn gs_draw_sprite(tex: *mut gs_texture_t, flip: u32, width: u32, height: u32);
    pub fn gs_draw_sprite_subregion(tex: *mut gs_texture_t, flip: u32, x: u32, y: u32, cx: u32, cy: u32);
    pub fn gs_draw_cube_backdrop(
        cubetex: *mut gs_texture_t,
        rot: *const quat,
        left: f32,
        right: f32,
        top: f32,
        bottom: f32,
        znear: f32,
    );
    #[doc = " sets the viewport to current swap chain size"]
    pub fn gs_reset_viewport();
    #[doc = " sets default screen-sized orthographic mode"]
    pub fn gs_set_2d_mode();
    #[doc = " sets default screen-sized perspective mode"]
    pub fn gs_set_3d_mode(fovy: f64, znear: f64, zvar: f64);
    pub fn gs_viewport_push();
    pub fn gs_viewport_pop();
    pub fn gs_texture_set_image(tex: *mut gs_texture_t, data: *const u8, linesize: u32, invert: bool);
    pub fn gs_cubetexture_set_image(
        cubetex: *mut gs_texture_t,
        side: u32,
        data: *const ::std::os::raw::c_void,
        linesize: u32,
        invert: bool,
    );
    pub fn gs_perspective(fovy: f32, aspect: f32, znear: f32, zfar: f32);
    pub fn gs_blend_state_push();
    pub fn gs_blend_state_pop();
    pub fn gs_reset_blend_state();
    pub fn gs_swapchain_create(data: *const gs_init_data) -> *mut gs_swapchain_t;
    pub fn gs_resize(x: u32, y: u32);
    pub fn gs_update_color_space();
    pub fn gs_get_size(x: *mut u32, y: *mut u32);
    pub fn gs_get_width() -> u32;
    pub fn gs_get_height() -> u32;
    pub fn gs_texture_create(
        width: u32,
        height: u32,
        color_format: gs_color_format,
        levels: u32,
        data: *mut *const u8,
        flags: u32,
    ) -> *mut gs_texture_t;
    pub fn gs_cubetexture_create(
        size: u32,
        color_format: gs_color_format,
        levels: u32,
        data: *mut *const u8,
        flags: u32,
    ) -> *mut gs_texture_t;
    pub fn gs_voltexture_create(
        width: u32,
        height: u32,
        depth: u32,
        color_format: gs_color_format,
        levels: u32,
        data: *mut *const u8,
        flags: u32,
    ) -> *mut gs_texture_t;
    pub fn gs_zstencil_create(width: u32, height: u32, format: gs_zstencil_format) -> *mut gs_zstencil_t;
    pub fn gs_stagesurface_create(width: u32, height: u32, color_format: gs_color_format) -> *mut gs_stagesurf_t;
    pub fn gs_samplerstate_create(info: *const gs_sampler_info) -> *mut gs_samplerstate_t;
    pub fn gs_vertexshader_create(
        shader: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_shader_t;
    pub fn gs_pixelshader_create(
        shader: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_shader_t;
    pub fn gs_vertexbuffer_create(data: *mut gs_vb_data, flags: u32) -> *mut gs_vertbuffer_t;
    pub fn gs_indexbuffer_create(
        type_: gs_index_type,
        indices: *mut ::std::os::raw::c_void,
        num: usize,
        flags: u32,
    ) -> *mut gs_indexbuffer_t;
    pub fn gs_timer_create() -> *mut gs_timer_t;
    pub fn gs_timer_range_create() -> *mut gs_timer_range_t;
    pub fn gs_get_texture_type(texture: *const gs_texture_t) -> gs_texture_type;
    pub fn gs_load_vertexbuffer(vertbuffer: *mut gs_vertbuffer_t);
    pub fn gs_load_indexbuffer(indexbuffer: *mut gs_indexbuffer_t);
    pub fn gs_load_texture(tex: *mut gs_texture_t, unit: ::std::os::raw::c_int);
    pub fn gs_load_samplerstate(samplerstate: *mut gs_samplerstate_t, unit: ::std::os::raw::c_int);
    pub fn gs_load_vertexshader(vertshader: *mut gs_shader_t);
    pub fn gs_load_pixelshader(pixelshader: *mut gs_shader_t);
    pub fn gs_load_default_samplerstate(b_3d: bool, unit: ::std::os::raw::c_int);
    pub fn gs_get_vertex_shader() -> *mut gs_shader_t;
    pub fn gs_get_pixel_shader() -> *mut gs_shader_t;
    pub fn gs_get_color_space() -> gs_color_space;
    pub fn gs_get_render_target() -> *mut gs_texture_t;
    pub fn gs_get_zstencil_target() -> *mut gs_zstencil_t;
    pub fn gs_set_render_target(tex: *mut gs_texture_t, zstencil: *mut gs_zstencil_t);
    pub fn gs_set_render_target_with_color_space(
        tex: *mut gs_texture_t,
        zstencil: *mut gs_zstencil_t,
        space: gs_color_space,
    );
    pub fn gs_set_cube_render_target(
        cubetex: *mut gs_texture_t,
        side: ::std::os::raw::c_int,
        zstencil: *mut gs_zstencil_t,
    );
    pub fn gs_enable_framebuffer_srgb(enable: bool);
    pub fn gs_framebuffer_srgb_enabled() -> bool;
    pub fn gs_get_linear_srgb() -> bool;
    pub fn gs_set_linear_srgb(linear_srgb: bool) -> bool;
    pub fn gs_copy_texture(dst: *mut gs_texture_t, src: *mut gs_texture_t);
    pub fn gs_copy_texture_region(
        dst: *mut gs_texture_t,
        dst_x: u32,
        dst_y: u32,
        src: *mut gs_texture_t,
        src_x: u32,
        src_y: u32,
        src_w: u32,
        src_h: u32,
    );
    pub fn gs_stage_texture(dst: *mut gs_stagesurf_t, src: *mut gs_texture_t);
    pub fn gs_begin_frame();
    pub fn gs_begin_scene();
    pub fn gs_draw(draw_mode: gs_draw_mode, start_vert: u32, num_verts: u32);
    pub fn gs_end_scene();
    pub fn gs_load_swapchain(swapchain: *mut gs_swapchain_t);
    pub fn gs_clear(clear_flags: u32, color: *const vec4, depth: f32, stencil: u8);
    pub fn gs_is_present_ready() -> bool;
    pub fn gs_present();
    pub fn gs_flush();
    pub fn gs_set_cull_mode(mode: gs_cull_mode);
    pub fn gs_get_cull_mode() -> gs_cull_mode;
    pub fn gs_enable_blending(enable: bool);
    pub fn gs_enable_depth_test(enable: bool);
    pub fn gs_enable_stencil_test(enable: bool);
    pub fn gs_enable_stencil_write(enable: bool);
    pub fn gs_enable_color(red: bool, green: bool, blue: bool, alpha: bool);
    pub fn gs_blend_function(src: gs_blend_type, dest: gs_blend_type);
    pub fn gs_blend_function_separate(
        src_c: gs_blend_type,
        dest_c: gs_blend_type,
        src_a: gs_blend_type,
        dest_a: gs_blend_type,
    );
    pub fn gs_blend_op(op: gs_blend_op_type);
    pub fn gs_depth_function(test: gs_depth_test);
    pub fn gs_stencil_function(side: gs_stencil_side, test: gs_depth_test);
    pub fn gs_stencil_op(
        side: gs_stencil_side,
        fail: gs_stencil_op_type,
        zfail: gs_stencil_op_type,
        zpass: gs_stencil_op_type,
    );
    pub fn gs_set_viewport(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
    pub fn gs_get_viewport(rect: *mut gs_rect);
    pub fn gs_set_scissor_rect(rect: *const gs_rect);
    pub fn gs_ortho(left: f32, right: f32, top: f32, bottom: f32, znear: f32, zfar: f32);
    pub fn gs_frustum(left: f32, right: f32, top: f32, bottom: f32, znear: f32, zfar: f32);
    pub fn gs_projection_push();
    pub fn gs_projection_pop();
    pub fn gs_swapchain_destroy(swapchain: *mut gs_swapchain_t);
    pub fn gs_texture_destroy(tex: *mut gs_texture_t);
    pub fn gs_texture_get_width(tex: *const gs_texture_t) -> u32;
    pub fn gs_texture_get_height(tex: *const gs_texture_t) -> u32;
    pub fn gs_texture_get_color_format(tex: *const gs_texture_t) -> gs_color_format;
    pub fn gs_texture_map(tex: *mut gs_texture_t, ptr: *mut *mut u8, linesize: *mut u32) -> bool;
    pub fn gs_texture_unmap(tex: *mut gs_texture_t);
    #[doc = " special-case function (GL only) - specifies whether the texture is a\n GL_TEXTURE_RECTANGLE type, which doesn't use normalized texture\n coordinates, doesn't support mipmapping, and requires address clamping"]
    pub fn gs_texture_is_rect(tex: *const gs_texture_t) -> bool;
    #[doc = " Gets a pointer to the context-specific object associated with the texture.\n For example, for GL, this is a GLuint*.  For D3D11, ID3D11Texture2D*."]
    pub fn gs_texture_get_obj(tex: *mut gs_texture_t) -> *mut ::std::os::raw::c_void;
    pub fn gs_cubetexture_destroy(cubetex: *mut gs_texture_t);
    pub fn gs_cubetexture_get_size(cubetex: *const gs_texture_t) -> u32;
    pub fn gs_cubetexture_get_color_format(cubetex: *const gs_texture_t) -> gs_color_format;
    pub fn gs_voltexture_destroy(voltex: *mut gs_texture_t);
    pub fn gs_voltexture_get_width(voltex: *const gs_texture_t) -> u32;
    pub fn gs_voltexture_get_height(voltex: *const gs_texture_t) -> u32;
    pub fn gs_voltexture_get_depth(voltex: *const gs_texture_t) -> u32;
    pub fn gs_voltexture_get_color_format(voltex: *const gs_texture_t) -> gs_color_format;
    pub fn gs_stagesurface_destroy(stagesurf: *mut gs_stagesurf_t);
    pub fn gs_stagesurface_get_width(stagesurf: *const gs_stagesurf_t) -> u32;
    pub fn gs_stagesurface_get_height(stagesurf: *const gs_stagesurf_t) -> u32;
    pub fn gs_stagesurface_get_color_format(stagesurf: *const gs_stagesurf_t) -> gs_color_format;
    pub fn gs_stagesurface_map(stagesurf: *mut gs_stagesurf_t, data: *mut *mut u8, linesize: *mut u32) -> bool;
    pub fn gs_stagesurface_unmap(stagesurf: *mut gs_stagesurf_t);
    pub fn gs_zstencil_destroy(zstencil: *mut gs_zstencil_t);
    pub fn gs_samplerstate_destroy(samplerstate: *mut gs_samplerstate_t);
    pub fn gs_vertexbuffer_destroy(vertbuffer: *mut gs_vertbuffer_t);
    pub fn gs_vertexbuffer_flush(vertbuffer: *mut gs_vertbuffer_t);
    pub fn gs_vertexbuffer_flush_direct(vertbuffer: *mut gs_vertbuffer_t, data: *const gs_vb_data);
    pub fn gs_vertexbuffer_get_data(vertbuffer: *const gs_vertbuffer_t) -> *mut gs_vb_data;
    pub fn gs_indexbuffer_destroy(indexbuffer: *mut gs_indexbuffer_t);
    pub fn gs_indexbuffer_flush(indexbuffer: *mut gs_indexbuffer_t);
    pub fn gs_indexbuffer_flush_direct(indexbuffer: *mut gs_indexbuffer_t, data: *const ::std::os::raw::c_void);
    pub fn gs_indexbuffer_get_data(indexbuffer: *const gs_indexbuffer_t) -> *mut ::std::os::raw::c_void;
    pub fn gs_indexbuffer_get_num_indices(indexbuffer: *const gs_indexbuffer_t) -> usize;
    pub fn gs_indexbuffer_get_type(indexbuffer: *const gs_indexbuffer_t) -> gs_index_type;
    pub fn gs_timer_destroy(timer: *mut gs_timer_t);
    pub fn gs_timer_begin(timer: *mut gs_timer_t);
    pub fn gs_timer_end(timer: *mut gs_timer_t);
    pub fn gs_timer_get_data(timer: *mut gs_timer_t, ticks: *mut u64) -> bool;
    pub fn gs_timer_range_destroy(timer: *mut gs_timer_range_t);
    pub fn gs_timer_range_begin(range: *mut gs_timer_range_t);
    pub fn gs_timer_range_end(range: *mut gs_timer_range_t);
    pub fn gs_timer_range_get_data(range: *mut gs_timer_range_t, disjoint: *mut bool, frequency: *mut u64) -> bool;
    pub fn gs_nv12_available() -> bool;
    pub fn gs_p010_available() -> bool;
    pub fn gs_texture_create_nv12(
        tex_y: *mut *mut gs_texture_t,
        tex_uv: *mut *mut gs_texture_t,
        width: u32,
        height: u32,
        flags: u32,
    ) -> bool;
    pub fn gs_texture_create_p010(
        tex_y: *mut *mut gs_texture_t,
        tex_uv: *mut *mut gs_texture_t,
        width: u32,
        height: u32,
        flags: u32,
    ) -> bool;
    pub fn gs_is_monitor_hdr(monitor: *mut ::std::os::raw::c_void) -> bool;
    pub fn gs_debug_marker_begin(color: *const f32, markername: *const ::std::os::raw::c_char);
    pub fn gs_debug_marker_begin_format(color: *const f32, format: *const ::std::os::raw::c_char, ...);
    pub fn gs_debug_marker_end();
    pub fn gs_gdi_texture_available() -> bool;
    pub fn gs_shared_texture_available() -> bool;
    #[doc = " Gets information about the monitor at the specific index, returns false\n when there is no monitor at the specified index"]
    pub fn gs_get_duplicator_monitor_info(
        monitor_idx: ::std::os::raw::c_int,
        monitor_info: *mut gs_monitor_info,
    ) -> bool;
    pub fn gs_duplicator_get_monitor_index(monitor: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
    #[doc = " creates a windows 8+ output duplicator (monitor capture)"]
    pub fn gs_duplicator_create(monitor_idx: ::std::os::raw::c_int) -> *mut gs_duplicator_t;
    pub fn gs_duplicator_destroy(duplicator: *mut gs_duplicator_t);
    pub fn gs_duplicator_update_frame(duplicator: *mut gs_duplicator_t) -> bool;
    pub fn gs_duplicator_get_texture(duplicator: *mut gs_duplicator_t) -> *mut gs_texture_t;
    pub fn gs_duplicator_get_color_space(duplicator: *mut gs_duplicator_t) -> gs_color_space;
    pub fn gs_duplicator_get_sdr_white_level(duplicator: *mut gs_duplicator_t) -> f32;
    pub fn gs_can_adapter_fast_clear() -> bool;
    #[doc = " creates a windows GDI-lockable texture"]
    pub fn gs_texture_create_gdi(width: u32, height: u32) -> *mut gs_texture_t;
    pub fn gs_texture_get_dc(gdi_tex: *mut gs_texture_t) -> *mut ::std::os::raw::c_void;
    pub fn gs_texture_release_dc(gdi_tex: *mut gs_texture_t);
    #[doc = " creates a windows shared texture from a texture handle"]
    pub fn gs_texture_open_shared(handle: u32) -> *mut gs_texture_t;
    pub fn gs_texture_open_nt_shared(handle: u32) -> *mut gs_texture_t;
    pub fn gs_texture_get_shared_handle(tex: *mut gs_texture_t) -> u32;
    pub fn gs_texture_wrap_obj(obj: *mut ::std::os::raw::c_void) -> *mut gs_texture_t;
    #[doc = " acquires a lock on a keyed mutex texture.\n returns -1 on generic failure, ETIMEDOUT if timed out"]
    pub fn gs_texture_acquire_sync(tex: *mut gs_texture_t, key: u64, ms: u32) -> ::std::os::raw::c_int;
    #[doc = " releases a lock on a keyed mutex texture to another device.\n return 0 on success, -1 on error"]
    pub fn gs_texture_release_sync(tex: *mut gs_texture_t, key: u64) -> ::std::os::raw::c_int;
    pub fn gs_stagesurface_create_nv12(width: u32, height: u32) -> *mut gs_stagesurf_t;
    pub fn gs_stagesurface_create_p010(width: u32, height: u32) -> *mut gs_stagesurf_t;
    pub fn gs_register_loss_callbacks(callbacks: *const gs_device_loss);
    pub fn gs_unregister_loss_callbacks(data: *mut ::std::os::raw::c_void);
    pub static _HUGE: f64;
    pub static _Denorm_C: _float_const;
    pub static _Inf_C: _float_const;
    pub static _Nan_C: _float_const;
    pub static _Snan_C: _float_const;
    pub static _Hugeval_C: _float_const;
    pub static _FDenorm_C: _float_const;
    pub static _FInf_C: _float_const;
    pub static _FNan_C: _float_const;
    pub static _FSnan_C: _float_const;
    pub static _LDenorm_C: _float_const;
    pub static _LInf_C: _float_const;
    pub static _LNan_C: _float_const;
    pub static _LSnan_C: _float_const;
    pub static _Eps_C: _float_const;
    pub static _Rteps_C: _float_const;
    pub static _FEps_C: _float_const;
    pub static _FRteps_C: _float_const;
    pub static _LEps_C: _float_const;
    pub static _LRteps_C: _float_const;
    pub static _Zero_C: f64;
    pub static _Xbig_C: f64;
    pub static _FZero_C: f32;
    pub static _FXbig_C: f32;
    pub static _LZero_C: f64;
    pub static _LXbig_C: f64;
    pub fn acos(_X: f64) -> f64;
    pub fn asin(_X: f64) -> f64;
    pub fn atan(_X: f64) -> f64;
    pub fn atan2(_Y: f64, _X: f64) -> f64;
    pub fn cos(_X: f64) -> f64;
    pub fn cosh(_X: f64) -> f64;
    pub fn exp(_X: f64) -> f64;
    pub fn fabs(_X: f64) -> f64;
    pub fn fmod(_X: f64, _Y: f64) -> f64;
    pub fn log(_X: f64) -> f64;
    pub fn log10(_X: f64) -> f64;
    pub fn pow(_X: f64, _Y: f64) -> f64;
    pub fn sin(_X: f64) -> f64;
    pub fn sinh(_X: f64) -> f64;
    pub fn sqrt(_X: f64) -> f64;
    pub fn tan(_X: f64) -> f64;
    pub fn tanh(_X: f64) -> f64;
    pub fn acosh(_X: f64) -> f64;
    pub fn asinh(_X: f64) -> f64;
    pub fn atanh(_X: f64) -> f64;
    pub fn cbrt(_X: f64) -> f64;
    pub fn ceil(_X: f64) -> f64;
    pub fn copysign(_Number: f64, _Sign: f64) -> f64;
    pub fn erf(_X: f64) -> f64;
    pub fn erfc(_X: f64) -> f64;
    pub fn exp2(_X: f64) -> f64;
    pub fn expm1(_X: f64) -> f64;
    pub fn fdim(_X: f64, _Y: f64) -> f64;
    pub fn floor(_X: f64) -> f64;
    pub fn fma(_X: f64, _Y: f64, _Z: f64) -> f64;
    pub fn fmax(_X: f64, _Y: f64) -> f64;
    pub fn fmin(_X: f64, _Y: f64) -> f64;
    pub fn frexp(_X: f64, _Y: *mut ::std::os::raw::c_int) -> f64;
    pub fn hypot(_X: f64, _Y: f64) -> f64;
    pub fn ilogb(_X: f64) -> ::std::os::raw::c_int;
    pub fn ldexp(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
    pub fn lgamma(_X: f64) -> f64;
    pub fn llrint(_X: f64) -> ::std::os::raw::c_longlong;
    pub fn llround(_X: f64) -> ::std::os::raw::c_longlong;
    pub fn log1p(_X: f64) -> f64;
    pub fn log2(_X: f64) -> f64;
    pub fn logb(_X: f64) -> f64;
    pub fn lrint(_X: f64) -> ::std::os::raw::c_long;
    pub fn lround(_X: f64) -> ::std::os::raw::c_long;
    pub fn modf(_X: f64, _Y: *mut f64) -> f64;
    pub fn nan(_X: *const ::std::os::raw::c_char) -> f64;
    pub fn nearbyint(_X: f64) -> f64;
    pub fn nextafter(_X: f64, _Y: f64) -> f64;
    pub fn nexttoward(_X: f64, _Y: f64) -> f64;
    pub fn remainder(_X: f64, _Y: f64) -> f64;
    pub fn remquo(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
    pub fn rint(_X: f64) -> f64;
    pub fn round(_X: f64) -> f64;
    pub fn scalbln(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
    pub fn scalbn(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
    pub fn tgamma(_X: f64) -> f64;
    pub fn trunc(_X: f64) -> f64;
    pub fn acoshf(_X: f32) -> f32;
    pub fn asinhf(_X: f32) -> f32;
    pub fn atanhf(_X: f32) -> f32;
    pub fn cbrtf(_X: f32) -> f32;
    pub fn copysignf(_Number: f32, _Sign: f32) -> f32;
    pub fn erff(_X: f32) -> f32;
    pub fn erfcf(_X: f32) -> f32;
    pub fn expm1f(_X: f32) -> f32;
    pub fn exp2f(_X: f32) -> f32;
    pub fn fdimf(_X: f32, _Y: f32) -> f32;
    pub fn fmaf(_X: f32, _Y: f32, _Z: f32) -> f32;
    pub fn fmaxf(_X: f32, _Y: f32) -> f32;
    pub fn fminf(_X: f32, _Y: f32) -> f32;
    pub fn ilogbf(_X: f32) -> ::std::os::raw::c_int;
    pub fn lgammaf(_X: f32) -> f32;
    pub fn llrintf(_X: f32) -> ::std::os::raw::c_longlong;
    pub fn llroundf(_X: f32) -> ::std::os::raw::c_longlong;
    pub fn log1pf(_X: f32) -> f32;
    pub fn log2f(_X: f32) -> f32;
    pub fn logbf(_X: f32) -> f32;
    pub fn lrintf(_X: f32) -> ::std::os::raw::c_long;
    pub fn lroundf(_X: f32) -> ::std::os::raw::c_long;
    pub fn nanf(_X: *const ::std::os::raw::c_char) -> f32;
    pub fn nearbyintf(_X: f32) -> f32;
    pub fn nextafterf(_X: f32, _Y: f32) -> f32;
    pub fn nexttowardf(_X: f32, _Y: f64) -> f32;
    pub fn remainderf(_X: f32, _Y: f32) -> f32;
    pub fn remquof(_X: f32, _Y: f32, _Z: *mut ::std::os::raw::c_int) -> f32;
    pub fn rintf(_X: f32) -> f32;
    pub fn roundf(_X: f32) -> f32;
    pub fn scalblnf(_X: f32, _Y: ::std::os::raw::c_long) -> f32;
    pub fn scalbnf(_X: f32, _Y: ::std::os::raw::c_int) -> f32;
    pub fn tgammaf(_X: f32) -> f32;
    pub fn truncf(_X: f32) -> f32;
    pub fn acosf(_X: f32) -> f32;
    pub fn asinf(_X: f32) -> f32;
    pub fn atan2f(_Y: f32, _X: f32) -> f32;
    pub fn atanf(_X: f32) -> f32;
    pub fn ceilf(_X: f32) -> f32;
    pub fn cosf(_X: f32) -> f32;
    pub fn coshf(_X: f32) -> f32;
    pub fn expf(_X: f32) -> f32;
    pub fn floorf(_X: f32) -> f32;
    pub fn fmodf(_X: f32, _Y: f32) -> f32;
    pub fn log10f(_X: f32) -> f32;
    pub fn logf(_X: f32) -> f32;
    pub fn modff(_X: f32, _Y: *mut f32) -> f32;
    pub fn powf(_X: f32, _Y: f32) -> f32;
    pub fn sinf(_X: f32) -> f32;
    pub fn sinhf(_X: f32) -> f32;
    pub fn sqrtf(_X: f32) -> f32;
    pub fn tanf(_X: f32) -> f32;
    pub fn tanhf(_X: f32) -> f32;
    pub fn acoshl(_X: f64) -> f64;
    pub fn asinhl(_X: f64) -> f64;
    pub fn atanhl(_X: f64) -> f64;
    pub fn cbrtl(_X: f64) -> f64;
    pub fn copysignl(_Number: f64, _Sign: f64) -> f64;
    pub fn erfl(_X: f64) -> f64;
    pub fn erfcl(_X: f64) -> f64;
    pub fn exp2l(_X: f64) -> f64;
    pub fn expm1l(_X: f64) -> f64;
    pub fn fdiml(_X: f64, _Y: f64) -> f64;
    pub fn fmal(_X: f64, _Y: f64, _Z: f64) -> f64;
    pub fn fmaxl(_X: f64, _Y: f64) -> f64;
    pub fn fminl(_X: f64, _Y: f64) -> f64;
    pub fn ilogbl(_X: f64) -> ::std::os::raw::c_int;
    pub fn lgammal(_X: f64) -> f64;
    pub fn llrintl(_X: f64) -> ::std::os::raw::c_longlong;
    pub fn llroundl(_X: f64) -> ::std::os::raw::c_longlong;
    pub fn log1pl(_X: f64) -> f64;
    pub fn log2l(_X: f64) -> f64;
    pub fn logbl(_X: f64) -> f64;
    pub fn lrintl(_X: f64) -> ::std::os::raw::c_long;
    pub fn lroundl(_X: f64) -> ::std::os::raw::c_long;
    pub fn nanl(_X: *const ::std::os::raw::c_char) -> f64;
    pub fn nearbyintl(_X: f64) -> f64;
    pub fn nextafterl(_X: f64, _Y: f64) -> f64;
    pub fn nexttowardl(_X: f64, _Y: f64) -> f64;
    pub fn remainderl(_X: f64, _Y: f64) -> f64;
    pub fn remquol(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
    pub fn rintl(_X: f64) -> f64;
    pub fn roundl(_X: f64) -> f64;
    pub fn scalblnl(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
    pub fn scalbnl(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
    pub fn tgammal(_X: f64) -> f64;
    pub fn truncl(_X: f64) -> f64;
    pub static mut HUGE: f64;
    pub fn j0(_X: f64) -> f64;
    pub fn j1(_X: f64) -> f64;
    pub fn jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
    pub fn y0(_X: f64) -> f64;
    pub fn y1(_X: f64) -> f64;
    pub fn yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
    pub fn vec2_abs(dst: *mut vec2, v: *const vec2);
    pub fn vec2_floor(dst: *mut vec2, v: *const vec2);
    pub fn vec2_ceil(dst: *mut vec2, v: *const vec2);
    pub fn vec2_close(v1: *const vec2, v2: *const vec2, epsilon: f32) -> ::std::os::raw::c_int;
    pub fn vec2_norm(dst: *mut vec2, v: *const vec2);
    pub fn vec4_from_vec3(dst: *mut vec4, v: *const vec3);
    pub fn vec4_transform(dst: *mut vec4, v: *const vec4, m: *const matrix4);
    pub fn vec3_from_vec4(dst: *mut vec3, v: *const vec4);
    pub fn vec3_plane_dist(v: *const vec3, p: *const plane) -> f32;
    pub fn vec3_transform(dst: *mut vec3, v: *const vec3, m: *const matrix4);
    pub fn vec3_rotate(dst: *mut vec3, v: *const vec3, m: *const matrix3);
    pub fn vec3_transform3x4(dst: *mut vec3, v: *const vec3, m: *const matrix3);
    pub fn vec3_mirror(dst: *mut vec3, v: *const vec3, p: *const plane);
    pub fn vec3_mirrorv(dst: *mut vec3, v: *const vec3, vec: *const vec3);
    pub fn vec3_rand(dst: *mut vec3, positive_only: ::std::os::raw::c_int);
    pub fn audio_output_open(audio: *mut *mut audio_t, info: *mut audio_output_info) -> ::std::os::raw::c_int;
    pub fn audio_output_close(audio: *mut audio_t);
    pub fn audio_output_connect(
        video: *mut audio_t,
        mix_idx: usize,
        conversion: *const audio_convert_info,
        callback: audio_output_callback_t,
        param: *mut ::std::os::raw::c_void,
    ) -> bool;
    pub fn audio_output_disconnect(
        video: *mut audio_t,
        mix_idx: usize,
        callback: audio_output_callback_t,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn audio_output_active(audio: *const audio_t) -> bool;
    pub fn audio_output_get_block_size(audio: *const audio_t) -> usize;
    pub fn audio_output_get_planes(audio: *const audio_t) -> usize;
    pub fn audio_output_get_channels(audio: *const audio_t) -> usize;
    pub fn audio_output_get_sample_rate(audio: *const audio_t) -> u32;
    pub fn audio_output_get_info(audio: *const audio_t) -> *const audio_output_info;
    pub fn video_format_from_fourcc(fourcc: u32) -> video_format;
    pub fn video_format_get_parameters(
        color_space: video_colorspace,
        range: video_range_type,
        matrix: *mut f32,
        min_range: *mut f32,
        max_range: *mut f32,
    ) -> bool;
    pub fn video_format_get_parameters_for_format(
        color_space: video_colorspace,
        range: video_range_type,
        format: video_format,
        matrix: *mut f32,
        min_range: *mut f32,
        max_range: *mut f32,
    ) -> bool;
    pub fn video_output_open(video: *mut *mut video_t, info: *mut video_output_info) -> ::std::os::raw::c_int;
    pub fn video_output_close(video: *mut video_t);
    pub fn video_output_connect(
        video: *mut video_t,
        conversion: *const video_scale_info,
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, frame: *mut video_data),
        >,
        param: *mut ::std::os::raw::c_void,
    ) -> bool;
    pub fn video_output_connect2(
        video: *mut video_t,
        conversion: *const video_scale_info,
        frame_rate_divisor: u32,
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, frame: *mut video_data),
        >,
        param: *mut ::std::os::raw::c_void,
    ) -> bool;
    pub fn video_output_disconnect(
        video: *mut video_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, frame: *mut video_data),
        >,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn video_output_active(video: *const video_t) -> bool;
    pub fn video_output_get_info(video: *const video_t) -> *const video_output_info;
    pub fn video_output_lock_frame(
        video: *mut video_t,
        frame: *mut video_frame,
        count: ::std::os::raw::c_int,
        timestamp: u64,
    ) -> bool;
    pub fn video_output_unlock_frame(video: *mut video_t);
    pub fn video_output_get_frame_time(video: *const video_t) -> u64;
    pub fn video_output_stop(video: *mut video_t);
    pub fn video_output_stopped(video: *mut video_t) -> bool;
    pub fn video_output_get_format(video: *const video_t) -> video_format;
    pub fn video_output_get_width(video: *const video_t) -> u32;
    pub fn video_output_get_height(video: *const video_t) -> u32;
    pub fn video_output_get_frame_rate(video: *const video_t) -> f64;
    pub fn video_output_get_skipped_frames(video: *const video_t) -> u32;
    pub fn video_output_get_total_frames(video: *const video_t) -> u32;
    pub fn video_output_inc_texture_encoders(video: *mut video_t);
    pub fn video_output_dec_texture_encoders(video: *mut video_t);
    pub fn video_output_inc_texture_frames(video: *mut video_t);
    pub fn video_output_inc_texture_skipped_frames(video: *mut video_t);
    pub fn video_output_create_with_frame_rate_divisor(video: *mut video_t, divisor: u32) -> *mut video_t;
    pub fn video_output_free_frame_rate_divisor(video: *mut video_t);
    pub fn calldata_get_data(
        data: *const calldata_t,
        name: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> bool;
    pub fn calldata_set_data(
        data: *mut calldata_t,
        name: *const ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_void,
        new_size: usize,
    );
    pub fn calldata_get_string(
        data: *const calldata_t,
        name: *const ::std::os::raw::c_char,
        str_: *mut *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn signal_handler_create() -> *mut signal_handler_t;
    pub fn signal_handler_destroy(handler: *mut signal_handler_t);
    pub fn signal_handler_add(handler: *mut signal_handler_t, signal_decl: *const ::std::os::raw::c_char) -> bool;
    pub fn signal_handler_connect(
        handler: *mut signal_handler_t,
        signal: *const ::std::os::raw::c_char,
        callback: signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
    pub fn signal_handler_connect_ref(
        handler: *mut signal_handler_t,
        signal: *const ::std::os::raw::c_char,
        callback: signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
    pub fn signal_handler_disconnect(
        handler: *mut signal_handler_t,
        signal: *const ::std::os::raw::c_char,
        callback: signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
    pub fn signal_handler_connect_global(
        handler: *mut signal_handler_t,
        callback: global_signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
    pub fn signal_handler_disconnect_global(
        handler: *mut signal_handler_t,
        callback: global_signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
    pub fn signal_handler_remove_current();
    pub fn signal_handler_signal(
        handler: *mut signal_handler_t,
        signal: *const ::std::os::raw::c_char,
        params: *mut calldata_t,
    );
    pub fn proc_handler_create() -> *mut proc_handler_t;
    pub fn proc_handler_destroy(handler: *mut proc_handler_t);
    pub fn proc_handler_add(
        handler: *mut proc_handler_t,
        decl_string: *const ::std::os::raw::c_char,
        proc_: proc_handler_proc_t,
        data: *mut ::std::os::raw::c_void,
    );
    #[doc = " Calls a function in a procedure handler.  Returns false if the named\n procedure is not found."]
    pub fn proc_handler_call(
        handler: *mut proc_handler_t,
        name: *const ::std::os::raw::c_char,
        params: *mut calldata_t,
    ) -> bool;
    pub fn obs_data_create() -> *mut obs_data_t;
    pub fn obs_data_create_from_json(json_string: *const ::std::os::raw::c_char) -> *mut obs_data_t;
    pub fn obs_data_create_from_json_file(json_file: *const ::std::os::raw::c_char) -> *mut obs_data_t;
    pub fn obs_data_create_from_json_file_safe(
        json_file: *const ::std::os::raw::c_char,
        backup_ext: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_t;
    pub fn obs_data_addref(data: *mut obs_data_t);
    pub fn obs_data_release(data: *mut obs_data_t);
    pub fn obs_data_get_json(data: *mut obs_data_t) -> *const ::std::os::raw::c_char;
    pub fn obs_data_get_json_with_defaults(data: *mut obs_data_t) -> *const ::std::os::raw::c_char;
    pub fn obs_data_get_json_pretty(data: *mut obs_data_t) -> *const ::std::os::raw::c_char;
    pub fn obs_data_get_json_pretty_with_defaults(data: *mut obs_data_t) -> *const ::std::os::raw::c_char;
    pub fn obs_data_get_last_json(data: *mut obs_data_t) -> *const ::std::os::raw::c_char;
    pub fn obs_data_save_json(data: *mut obs_data_t, file: *const ::std::os::raw::c_char) -> bool;
    pub fn obs_data_save_json_safe(
        data: *mut obs_data_t,
        file: *const ::std::os::raw::c_char,
        temp_ext: *const ::std::os::raw::c_char,
        backup_ext: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn obs_data_save_json_pretty_safe(
        data: *mut obs_data_t,
        file: *const ::std::os::raw::c_char,
        temp_ext: *const ::std::os::raw::c_char,
        backup_ext: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn obs_data_apply(target: *mut obs_data_t, apply_data: *mut obs_data_t);
    pub fn obs_data_erase(data: *mut obs_data_t, name: *const ::std::os::raw::c_char);
    pub fn obs_data_clear(data: *mut obs_data_t);
    pub fn obs_data_set_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
    pub fn obs_data_set_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    );
    pub fn obs_data_set_double(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: f64);
    pub fn obs_data_set_bool(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: bool);
    pub fn obs_data_set_obj(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, obj: *mut obs_data_t);
    pub fn obs_data_set_array(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, array: *mut obs_data_array_t);
    pub fn obs_data_get_defaults(data: *mut obs_data_t) -> *mut obs_data_t;
    pub fn obs_data_set_default_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
    pub fn obs_data_set_default_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    );
    pub fn obs_data_set_default_double(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: f64);
    pub fn obs_data_set_default_bool(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: bool);
    pub fn obs_data_set_default_obj(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, obj: *mut obs_data_t);
    pub fn obs_data_set_default_array(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        arr: *mut obs_data_array_t,
    );
    pub fn obs_data_set_autoselect_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
    pub fn obs_data_set_autoselect_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    );
    pub fn obs_data_set_autoselect_double(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: f64);
    pub fn obs_data_set_autoselect_bool(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: bool);
    pub fn obs_data_set_autoselect_obj(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        obj: *mut obs_data_t,
    );
    pub fn obs_data_set_autoselect_array(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        arr: *mut obs_data_array_t,
    );
    pub fn obs_data_get_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
    pub fn obs_data_get_int(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
    pub fn obs_data_get_double(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> f64;
    pub fn obs_data_get_bool(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> bool;
    pub fn obs_data_get_obj(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> *mut obs_data_t;
    pub fn obs_data_get_array(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> *mut obs_data_array_t;
    pub fn obs_data_get_default_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
    pub fn obs_data_get_default_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
    pub fn obs_data_get_default_double(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> f64;
    pub fn obs_data_get_default_bool(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> bool;
    pub fn obs_data_get_default_obj(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> *mut obs_data_t;
    pub fn obs_data_get_default_array(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_array_t;
    pub fn obs_data_get_autoselect_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
    pub fn obs_data_get_autoselect_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
    pub fn obs_data_get_autoselect_double(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> f64;
    pub fn obs_data_get_autoselect_bool(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> bool;
    pub fn obs_data_get_autoselect_obj(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> *mut obs_data_t;
    pub fn obs_data_get_autoselect_array(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_array_t;
    pub fn obs_data_array_create() -> *mut obs_data_array_t;
    pub fn obs_data_array_addref(array: *mut obs_data_array_t);
    pub fn obs_data_array_release(array: *mut obs_data_array_t);
    pub fn obs_data_array_count(array: *mut obs_data_array_t) -> usize;
    pub fn obs_data_array_item(array: *mut obs_data_array_t, idx: usize) -> *mut obs_data_t;
    pub fn obs_data_array_push_back(array: *mut obs_data_array_t, obj: *mut obs_data_t) -> usize;
    pub fn obs_data_array_insert(array: *mut obs_data_array_t, idx: usize, obj: *mut obs_data_t);
    pub fn obs_data_array_push_back_array(array: *mut obs_data_array_t, array2: *mut obs_data_array_t);
    pub fn obs_data_array_erase(array: *mut obs_data_array_t, idx: usize);
    pub fn obs_data_array_enum(
        array: *mut obs_data_array_t,
        cb: ::std::option::Option<unsafe extern "C" fn(data: *mut obs_data_t, param: *mut ::std::os::raw::c_void)>,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_data_has_user_value(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> bool;
    pub fn obs_data_has_default_value(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> bool;
    pub fn obs_data_has_autoselect_value(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> bool;
    pub fn obs_data_item_has_user_value(data: *mut obs_data_item_t) -> bool;
    pub fn obs_data_item_has_default_value(data: *mut obs_data_item_t) -> bool;
    pub fn obs_data_item_has_autoselect_value(data: *mut obs_data_item_t) -> bool;
    pub fn obs_data_unset_user_value(data: *mut obs_data_t, name: *const ::std::os::raw::c_char);
    pub fn obs_data_unset_default_value(data: *mut obs_data_t, name: *const ::std::os::raw::c_char);
    pub fn obs_data_unset_autoselect_value(data: *mut obs_data_t, name: *const ::std::os::raw::c_char);
    pub fn obs_data_item_unset_user_value(data: *mut obs_data_item_t);
    pub fn obs_data_item_unset_default_value(data: *mut obs_data_item_t);
    pub fn obs_data_item_unset_autoselect_value(data: *mut obs_data_item_t);
    pub fn obs_data_first(data: *mut obs_data_t) -> *mut obs_data_item_t;
    pub fn obs_data_item_byname(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> *mut obs_data_item_t;
    pub fn obs_data_item_next(item: *mut *mut obs_data_item_t) -> bool;
    pub fn obs_data_item_release(item: *mut *mut obs_data_item_t);
    pub fn obs_data_item_remove(item: *mut *mut obs_data_item_t);
    pub fn obs_data_item_gettype(item: *mut obs_data_item_t) -> obs_data_type;
    pub fn obs_data_item_numtype(item: *mut obs_data_item_t) -> obs_data_number_type;
    pub fn obs_data_item_get_name(item: *mut obs_data_item_t) -> *const ::std::os::raw::c_char;
    pub fn obs_data_item_set_string(item: *mut *mut obs_data_item_t, val: *const ::std::os::raw::c_char);
    pub fn obs_data_item_set_int(item: *mut *mut obs_data_item_t, val: ::std::os::raw::c_longlong);
    pub fn obs_data_item_set_double(item: *mut *mut obs_data_item_t, val: f64);
    pub fn obs_data_item_set_bool(item: *mut *mut obs_data_item_t, val: bool);
    pub fn obs_data_item_set_obj(item: *mut *mut obs_data_item_t, val: *mut obs_data_t);
    pub fn obs_data_item_set_array(item: *mut *mut obs_data_item_t, val: *mut obs_data_array_t);
    pub fn obs_data_item_set_default_string(item: *mut *mut obs_data_item_t, val: *const ::std::os::raw::c_char);
    pub fn obs_data_item_set_default_int(item: *mut *mut obs_data_item_t, val: ::std::os::raw::c_longlong);
    pub fn obs_data_item_set_default_double(item: *mut *mut obs_data_item_t, val: f64);
    pub fn obs_data_item_set_default_bool(item: *mut *mut obs_data_item_t, val: bool);
    pub fn obs_data_item_set_default_obj(item: *mut *mut obs_data_item_t, val: *mut obs_data_t);
    pub fn obs_data_item_set_default_array(item: *mut *mut obs_data_item_t, val: *mut obs_data_array_t);
    pub fn obs_data_item_set_autoselect_string(item: *mut *mut obs_data_item_t, val: *const ::std::os::raw::c_char);
    pub fn obs_data_item_set_autoselect_int(item: *mut *mut obs_data_item_t, val: ::std::os::raw::c_longlong);
    pub fn obs_data_item_set_autoselect_double(item: *mut *mut obs_data_item_t, val: f64);
    pub fn obs_data_item_set_autoselect_bool(item: *mut *mut obs_data_item_t, val: bool);
    pub fn obs_data_item_set_autoselect_obj(item: *mut *mut obs_data_item_t, val: *mut obs_data_t);
    pub fn obs_data_item_set_autoselect_array(item: *mut *mut obs_data_item_t, val: *mut obs_data_array_t);
    pub fn obs_data_item_get_string(item: *mut obs_data_item_t) -> *const ::std::os::raw::c_char;
    pub fn obs_data_item_get_int(item: *mut obs_data_item_t) -> ::std::os::raw::c_longlong;
    pub fn obs_data_item_get_double(item: *mut obs_data_item_t) -> f64;
    pub fn obs_data_item_get_bool(item: *mut obs_data_item_t) -> bool;
    pub fn obs_data_item_get_obj(item: *mut obs_data_item_t) -> *mut obs_data_t;
    pub fn obs_data_item_get_array(item: *mut obs_data_item_t) -> *mut obs_data_array_t;
    pub fn obs_data_item_get_default_string(item: *mut obs_data_item_t) -> *const ::std::os::raw::c_char;
    pub fn obs_data_item_get_default_int(item: *mut obs_data_item_t) -> ::std::os::raw::c_longlong;
    pub fn obs_data_item_get_default_double(item: *mut obs_data_item_t) -> f64;
    pub fn obs_data_item_get_default_bool(item: *mut obs_data_item_t) -> bool;
    pub fn obs_data_item_get_default_obj(item: *mut obs_data_item_t) -> *mut obs_data_t;
    pub fn obs_data_item_get_default_array(item: *mut obs_data_item_t) -> *mut obs_data_array_t;
    pub fn obs_data_item_get_autoselect_string(item: *mut obs_data_item_t) -> *const ::std::os::raw::c_char;
    pub fn obs_data_item_get_autoselect_int(item: *mut obs_data_item_t) -> ::std::os::raw::c_longlong;
    pub fn obs_data_item_get_autoselect_double(item: *mut obs_data_item_t) -> f64;
    pub fn obs_data_item_get_autoselect_bool(item: *mut obs_data_item_t) -> bool;
    pub fn obs_data_item_get_autoselect_obj(item: *mut obs_data_item_t) -> *mut obs_data_t;
    pub fn obs_data_item_get_autoselect_array(item: *mut obs_data_item_t) -> *mut obs_data_array_t;
    pub fn obs_data_set_vec2(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *const vec2);
    pub fn obs_data_set_vec3(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *const vec3);
    pub fn obs_data_set_vec4(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *const vec4);
    pub fn obs_data_set_quat(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *const quat);
    pub fn obs_data_set_default_vec2(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *const vec2);
    pub fn obs_data_set_default_vec3(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *const vec3);
    pub fn obs_data_set_default_vec4(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *const vec4);
    pub fn obs_data_set_default_quat(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *const quat);
    pub fn obs_data_set_autoselect_vec2(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *const vec2);
    pub fn obs_data_set_autoselect_vec3(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *const vec3);
    pub fn obs_data_set_autoselect_vec4(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *const vec4);
    pub fn obs_data_set_autoselect_quat(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *const quat);
    pub fn obs_data_get_vec2(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *mut vec2);
    pub fn obs_data_get_vec3(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *mut vec3);
    pub fn obs_data_get_vec4(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *mut vec4);
    pub fn obs_data_get_quat(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *mut quat);
    pub fn obs_data_get_default_vec2(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *mut vec2);
    pub fn obs_data_get_default_vec3(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *mut vec3);
    pub fn obs_data_get_default_vec4(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *mut vec4);
    pub fn obs_data_get_default_quat(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *mut quat);
    pub fn obs_data_get_autoselect_vec2(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *mut vec2);
    pub fn obs_data_get_autoselect_vec3(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *mut vec3);
    pub fn obs_data_get_autoselect_vec4(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *mut vec4);
    pub fn obs_data_get_autoselect_quat(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: *mut quat);
    pub fn obs_data_set_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
    pub fn obs_data_set_default_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
    pub fn obs_data_set_autoselect_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
    pub fn obs_data_get_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn obs_data_get_default_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn obs_data_get_autoselect_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn obs_data_item_set_frames_per_second(
        item: *mut *mut obs_data_item_t,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
    pub fn obs_data_item_set_default_frames_per_second(
        item: *mut *mut obs_data_item_t,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
    pub fn obs_data_item_set_autoselect_frames_per_second(
        item: *mut *mut obs_data_item_t,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
    pub fn obs_data_item_get_frames_per_second(
        item: *mut obs_data_item_t,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn obs_data_item_get_default_frames_per_second(
        item: *mut obs_data_item_t,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn obs_data_item_get_autoselect_frames_per_second(
        item: *mut obs_data_item_t,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn obs_properties_create() -> *mut obs_properties_t;
    pub fn obs_properties_create_param(
        param: *mut ::std::os::raw::c_void,
        destroy: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>,
    ) -> *mut obs_properties_t;
    pub fn obs_properties_destroy(props: *mut obs_properties_t);
    pub fn obs_properties_set_flags(props: *mut obs_properties_t, flags: u32);
    pub fn obs_properties_get_flags(props: *mut obs_properties_t) -> u32;
    pub fn obs_properties_set_param(
        props: *mut obs_properties_t,
        param: *mut ::std::os::raw::c_void,
        destroy: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>,
    );
    pub fn obs_properties_get_param(props: *mut obs_properties_t) -> *mut ::std::os::raw::c_void;
    pub fn obs_properties_first(props: *mut obs_properties_t) -> *mut obs_property_t;
    pub fn obs_properties_get(
        props: *mut obs_properties_t,
        property: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
    pub fn obs_properties_get_parent(props: *mut obs_properties_t) -> *mut obs_properties_t;
    #[doc = " Remove a property from a properties list.\n\n Removes a property from a properties list. Only valid in either\n get_properties or modified_callback(2). modified_callback(2) must return\n true so that all UI properties are rebuilt and returning false is undefined\n behavior.\n\n @param props Properties to remove from.\n @param property Name of the property to remove."]
    pub fn obs_properties_remove_by_name(props: *mut obs_properties_t, property: *const ::std::os::raw::c_char);
    #[doc = " Applies settings to the properties by calling all the necessary\n modification callbacks"]
    pub fn obs_properties_apply_settings(props: *mut obs_properties_t, settings: *mut obs_data_t);
    pub fn obs_properties_add_bool(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
    pub fn obs_properties_add_int(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
        step: ::std::os::raw::c_int,
    ) -> *mut obs_property_t;
    pub fn obs_properties_add_float(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        min: f64,
        max: f64,
        step: f64,
    ) -> *mut obs_property_t;
    pub fn obs_properties_add_int_slider(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
        step: ::std::os::raw::c_int,
    ) -> *mut obs_property_t;
    pub fn obs_properties_add_float_slider(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        min: f64,
        max: f64,
        step: f64,
    ) -> *mut obs_property_t;
    pub fn obs_properties_add_text(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_text_type,
    ) -> *mut obs_property_t;
    #[doc = " Adds a 'path' property.  Can be a directory or a file.\n\n If target is a file path, the filters should be this format, separated by\n double semicolons, and extensions separated by space:\n   \"Example types 1 and 2 (*.ex1 *.ex2);;Example type 3 (*.ex3)\"\n\n @param  props        Properties object\n @param  name         Settings name\n @param  description  Description (display name) of the property\n @param  type         Type of path (directory or file)\n @param  filter       If type is a file path, then describes the file filter\n                      that the user can browse.  Items are separated via\n                      double semicolons.  If multiple file types in a\n                      filter, separate with space."]
    pub fn obs_properties_add_path(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_path_type,
        filter: *const ::std::os::raw::c_char,
        default_path: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
    pub fn obs_properties_add_list(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_combo_type,
        format: obs_combo_format,
    ) -> *mut obs_property_t;
    pub fn obs_properties_add_color(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
    pub fn obs_properties_add_color_alpha(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
    pub fn obs_properties_add_button(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        text: *const ::std::os::raw::c_char,
        callback: obs_property_clicked_t,
    ) -> *mut obs_property_t;
    pub fn obs_properties_add_button2(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        text: *const ::std::os::raw::c_char,
        callback: obs_property_clicked_t,
        priv_: *mut ::std::os::raw::c_void,
    ) -> *mut obs_property_t;
    #[doc = " Adds a font selection property.\n\n A font is an obs_data sub-object which contains the following items:\n   face:   face name string\n   style:  style name string\n   size:   size integer\n   flags:  font flags integer (OBS_FONT_* defined above)"]
    pub fn obs_properties_add_font(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
    pub fn obs_properties_add_editable_list(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_editable_list_type,
        filter: *const ::std::os::raw::c_char,
        default_path: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
    pub fn obs_properties_add_frame_rate(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
    pub fn obs_properties_add_group(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_group_type,
        group: *mut obs_properties_t,
    ) -> *mut obs_property_t;
    pub fn obs_property_set_modified_callback(p: *mut obs_property_t, modified: obs_property_modified_t);
    pub fn obs_property_set_modified_callback2(
        p: *mut obs_property_t,
        modified: obs_property_modified2_t,
        priv_: *mut ::std::os::raw::c_void,
    );
    pub fn obs_property_modified(p: *mut obs_property_t, settings: *mut obs_data_t) -> bool;
    pub fn obs_property_button_clicked(p: *mut obs_property_t, obj: *mut ::std::os::raw::c_void) -> bool;
    pub fn obs_property_set_visible(p: *mut obs_property_t, visible: bool);
    pub fn obs_property_set_enabled(p: *mut obs_property_t, enabled: bool);
    pub fn obs_property_set_description(p: *mut obs_property_t, description: *const ::std::os::raw::c_char);
    pub fn obs_property_set_long_description(p: *mut obs_property_t, long_description: *const ::std::os::raw::c_char);
    pub fn obs_property_name(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
    pub fn obs_property_description(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
    pub fn obs_property_long_description(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
    pub fn obs_property_get_type(p: *mut obs_property_t) -> obs_property_type;
    pub fn obs_property_enabled(p: *mut obs_property_t) -> bool;
    pub fn obs_property_visible(p: *mut obs_property_t) -> bool;
    pub fn obs_property_next(p: *mut *mut obs_property_t) -> bool;
    pub fn obs_property_int_min(p: *mut obs_property_t) -> ::std::os::raw::c_int;
    pub fn obs_property_int_max(p: *mut obs_property_t) -> ::std::os::raw::c_int;
    pub fn obs_property_int_step(p: *mut obs_property_t) -> ::std::os::raw::c_int;
    pub fn obs_property_int_type(p: *mut obs_property_t) -> obs_number_type;
    pub fn obs_property_int_suffix(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
    pub fn obs_property_float_min(p: *mut obs_property_t) -> f64;
    pub fn obs_property_float_max(p: *mut obs_property_t) -> f64;
    pub fn obs_property_float_step(p: *mut obs_property_t) -> f64;
    pub fn obs_property_float_type(p: *mut obs_property_t) -> obs_number_type;
    pub fn obs_property_float_suffix(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
    pub fn obs_property_text_type(p: *mut obs_property_t) -> obs_text_type;
    pub fn obs_property_text_monospace(p: *mut obs_property_t) -> bool;
    pub fn obs_property_text_info_type(p: *mut obs_property_t) -> obs_text_info_type;
    pub fn obs_property_text_info_word_wrap(p: *mut obs_property_t) -> bool;
    pub fn obs_property_path_type(p: *mut obs_property_t) -> obs_path_type;
    pub fn obs_property_path_filter(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
    pub fn obs_property_path_default_path(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
    pub fn obs_property_list_type(p: *mut obs_property_t) -> obs_combo_type;
    pub fn obs_property_list_format(p: *mut obs_property_t) -> obs_combo_format;
    pub fn obs_property_int_set_limits(
        p: *mut obs_property_t,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
        step: ::std::os::raw::c_int,
    );
    pub fn obs_property_float_set_limits(p: *mut obs_property_t, min: f64, max: f64, step: f64);
    pub fn obs_property_int_set_suffix(p: *mut obs_property_t, suffix: *const ::std::os::raw::c_char);
    pub fn obs_property_float_set_suffix(p: *mut obs_property_t, suffix: *const ::std::os::raw::c_char);
    pub fn obs_property_text_set_monospace(p: *mut obs_property_t, monospace: bool);
    pub fn obs_property_text_set_info_type(p: *mut obs_property_t, type_: obs_text_info_type);
    pub fn obs_property_text_set_info_word_wrap(p: *mut obs_property_t, word_wrap: bool);
    pub fn obs_property_button_set_type(p: *mut obs_property_t, type_: obs_button_type);
    pub fn obs_property_button_set_url(p: *mut obs_property_t, url: *mut ::std::os::raw::c_char);
    pub fn obs_property_list_clear(p: *mut obs_property_t);
    pub fn obs_property_list_add_string(
        p: *mut obs_property_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> usize;
    pub fn obs_property_list_add_int(
        p: *mut obs_property_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    ) -> usize;
    pub fn obs_property_list_add_float(p: *mut obs_property_t, name: *const ::std::os::raw::c_char, val: f64) -> usize;
    pub fn obs_property_list_add_bool(p: *mut obs_property_t, name: *const ::std::os::raw::c_char, val: bool) -> usize;
    pub fn obs_property_list_insert_string(
        p: *mut obs_property_t,
        idx: usize,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
    pub fn obs_property_list_insert_int(
        p: *mut obs_property_t,
        idx: usize,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    );
    pub fn obs_property_list_insert_float(
        p: *mut obs_property_t,
        idx: usize,
        name: *const ::std::os::raw::c_char,
        val: f64,
    );
    pub fn obs_property_list_insert_bool(
        p: *mut obs_property_t,
        idx: usize,
        name: *const ::std::os::raw::c_char,
        val: bool,
    );
    pub fn obs_property_list_item_disable(p: *mut obs_property_t, idx: usize, disabled: bool);
    pub fn obs_property_list_item_disabled(p: *mut obs_property_t, idx: usize) -> bool;
    pub fn obs_property_list_item_remove(p: *mut obs_property_t, idx: usize);
    pub fn obs_property_list_item_count(p: *mut obs_property_t) -> usize;
    pub fn obs_property_list_item_name(p: *mut obs_property_t, idx: usize) -> *const ::std::os::raw::c_char;
    pub fn obs_property_list_item_string(p: *mut obs_property_t, idx: usize) -> *const ::std::os::raw::c_char;
    pub fn obs_property_list_item_int(p: *mut obs_property_t, idx: usize) -> ::std::os::raw::c_longlong;
    pub fn obs_property_list_item_float(p: *mut obs_property_t, idx: usize) -> f64;
    pub fn obs_property_list_item_bool(p: *mut obs_property_t, idx: usize) -> bool;
    pub fn obs_property_editable_list_type(p: *mut obs_property_t) -> obs_editable_list_type;
    pub fn obs_property_editable_list_filter(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
    pub fn obs_property_editable_list_default_path(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
    pub fn obs_property_frame_rate_clear(p: *mut obs_property_t);
    pub fn obs_property_frame_rate_options_clear(p: *mut obs_property_t);
    pub fn obs_property_frame_rate_fps_ranges_clear(p: *mut obs_property_t);
    pub fn obs_property_frame_rate_option_add(
        p: *mut obs_property_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> usize;
    pub fn obs_property_frame_rate_fps_range_add(
        p: *mut obs_property_t,
        min: media_frames_per_second,
        max: media_frames_per_second,
    ) -> usize;
    pub fn obs_property_frame_rate_option_insert(
        p: *mut obs_property_t,
        idx: usize,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    );
    pub fn obs_property_frame_rate_fps_range_insert(
        p: *mut obs_property_t,
        idx: usize,
        min: media_frames_per_second,
        max: media_frames_per_second,
    );
    pub fn obs_property_frame_rate_options_count(p: *mut obs_property_t) -> usize;
    pub fn obs_property_frame_rate_option_name(p: *mut obs_property_t, idx: usize) -> *const ::std::os::raw::c_char;
    pub fn obs_property_frame_rate_option_description(
        p: *mut obs_property_t,
        idx: usize,
    ) -> *const ::std::os::raw::c_char;
    pub fn obs_property_frame_rate_fps_ranges_count(p: *mut obs_property_t) -> usize;
    pub fn obs_property_frame_rate_fps_range_min(p: *mut obs_property_t, idx: usize) -> media_frames_per_second;
    pub fn obs_property_frame_rate_fps_range_max(p: *mut obs_property_t, idx: usize) -> media_frames_per_second;
    pub fn obs_property_group_type(p: *mut obs_property_t) -> obs_group_type;
    pub fn obs_property_group_content(p: *mut obs_property_t) -> *mut obs_properties_t;
    pub fn obs_property_button_type(p: *mut obs_property_t) -> obs_button_type;
    pub fn obs_property_button_url(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
    pub fn obs_proprety_text_type(p: *mut obs_property_t) -> obs_text_type;
    pub fn obs_missing_files_create() -> *mut obs_missing_files_t;
    pub fn obs_missing_file_create(
        path: *const ::std::os::raw::c_char,
        callback: obs_missing_file_cb,
        src_type: ::std::os::raw::c_int,
        src: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut obs_missing_file_t;
    pub fn obs_missing_files_add_file(files: *mut obs_missing_files_t, file: *mut obs_missing_file_t);
    pub fn obs_missing_files_count(files: *mut obs_missing_files_t) -> usize;
    pub fn obs_missing_files_get_file(
        files: *mut obs_missing_files_t,
        idx: ::std::os::raw::c_int,
    ) -> *mut obs_missing_file_t;
    pub fn obs_missing_files_destroy(files: *mut obs_missing_files_t);
    pub fn obs_missing_files_append(dst: *mut obs_missing_files_t, src: *mut obs_missing_files_t);
    pub fn obs_missing_file_issue_callback(file: *mut obs_missing_file_t, new_path: *const ::std::os::raw::c_char);
    pub fn obs_missing_file_get_path(file: *mut obs_missing_file_t) -> *const ::std::os::raw::c_char;
    pub fn obs_missing_file_get_source_name(file: *mut obs_missing_file_t) -> *const ::std::os::raw::c_char;
    pub fn obs_missing_file_release(file: *mut obs_missing_file_t);
    pub fn obs_missing_file_destroy(file: *mut obs_missing_file_t);
    pub fn obs_register_source_s(info: *const obs_source_info, size: usize);
    pub fn obs_register_encoder_s(info: *const obs_encoder_info, size: usize);
    pub fn obs_register_output_s(info: *const obs_output_info, size: usize);
    pub fn obs_register_service_s(info: *const obs_service_info, size: usize);
    #[doc = " @brief Create a fader\n @param type the type of the fader\n @return pointer to the fader object\n\n A fader object is used to map input values from a gui element to dB and\n subsequently multiplier values used by libobs to mix audio.\n The current \"position\" of the fader is internally stored as dB value."]
    pub fn obs_fader_create(type_: obs_fader_type) -> *mut obs_fader_t;
    #[doc = " @brief Destroy a fader\n @param fader pointer to the fader object\n\n Destroy the fader and free all related data"]
    pub fn obs_fader_destroy(fader: *mut obs_fader_t);
    #[doc = " @brief Set the fader dB value\n @param fader pointer to the fader object\n @param db new dB value\n @return true if value was set without clamping"]
    pub fn obs_fader_set_db(fader: *mut obs_fader_t, db: f32) -> bool;
    #[doc = " @brief Get the current fader dB value\n @param fader pointer to the fader object\n @return current fader dB value"]
    pub fn obs_fader_get_db(fader: *mut obs_fader_t) -> f32;
    #[doc = " @brief Set the fader value from deflection\n @param fader pointer to the fader object\n @param def new deflection\n @return true if value was set without clamping\n\n This sets the new fader value from the supplied deflection, in case the\n resulting value was clamped due to limits this function will return false.\n The deflection is typically in the range [0.0, 1.0] but may be higher in\n order to provide some amplification. In order for this to work the high dB\n limit has to be set."]
    pub fn obs_fader_set_deflection(fader: *mut obs_fader_t, def: f32) -> bool;
    #[doc = " @brief Get the current fader deflection\n @param fader pointer to the fader object\n @return current fader deflection"]
    pub fn obs_fader_get_deflection(fader: *mut obs_fader_t) -> f32;
    #[doc = " @brief Set the fader value from multiplier\n @param fader pointer to the fader object\n @return true if the value was set without clamping"]
    pub fn obs_fader_set_mul(fader: *mut obs_fader_t, mul: f32) -> bool;
    #[doc = " @brief Get the current fader multiplier value\n @param fader pointer to the fader object\n @return current fader multiplier"]
    pub fn obs_fader_get_mul(fader: *mut obs_fader_t) -> f32;
    #[doc = " @brief Attach the fader to a source\n @param fader pointer to the fader object\n @param source pointer to the source object\n @return true on success\n\n When the fader is attached to a source it will automatically sync it's state\n to the volume of the source."]
    pub fn obs_fader_attach_source(fader: *mut obs_fader_t, source: *mut obs_source_t) -> bool;
    #[doc = " @brief Detach the fader from the currently attached source\n @param fader pointer to the fader object"]
    pub fn obs_fader_detach_source(fader: *mut obs_fader_t);
    pub fn obs_fader_add_callback(
        fader: *mut obs_fader_t,
        callback: obs_fader_changed_t,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_fader_remove_callback(
        fader: *mut obs_fader_t,
        callback: obs_fader_changed_t,
        param: *mut ::std::os::raw::c_void,
    );
    #[doc = " @brief Create a volume meter\n @param type the mapping type to use for the volume meter\n @return pointer to the volume meter object\n\n A volume meter object is used to prepare the sound levels reported by audio\n sources for display in a GUI.\n It will automatically take source volume into account and map the levels\n to a range [0.0f, 1.0f]."]
    pub fn obs_volmeter_create(type_: obs_fader_type) -> *mut obs_volmeter_t;
    #[doc = " @brief Destroy a volume meter\n @param volmeter pointer to the volmeter object\n\n Destroy the volume meter and free all related data"]
    pub fn obs_volmeter_destroy(volmeter: *mut obs_volmeter_t);
    #[doc = " @brief Attach the volume meter to a source\n @param volmeter pointer to the volume meter object\n @param source pointer to the source object\n @return true on success\n\n When the volume meter is attached to a source it will start to listen to\n volume updates on the source and after preparing the data emit its own\n signal."]
    pub fn obs_volmeter_attach_source(volmeter: *mut obs_volmeter_t, source: *mut obs_source_t) -> bool;
    #[doc = " @brief Detach the volume meter from the currently attached source\n @param volmeter pointer to the volume meter object"]
    pub fn obs_volmeter_detach_source(volmeter: *mut obs_volmeter_t);
    #[doc = " @brief Set the peak meter type for the volume meter\n @param volmeter pointer to the volume meter object\n @param peak_meter_type set if true-peak needs to be measured."]
    pub fn obs_volmeter_set_peak_meter_type(volmeter: *mut obs_volmeter_t, peak_meter_type: obs_peak_meter_type);
    #[doc = " @brief Set the update interval for the volume meter\n @param volmeter pointer to the volume meter object\n @param ms update interval in ms\n\n This sets the update interval in milliseconds that should be processed before\n the resulting values are emitted by the levels_updated signal. The resulting\n number of audio samples is rounded to an integer.\n\n Please note that due to way obs does receive audio data from the sources\n this is no hard guarantee for the timing of the signal itself. When the\n volume meter receives a chunk of data that is multiple the size of the sample\n interval, all data will be sampled and the values updated accordingly, but\n only the signal for the last segment is actually emitted.\n On the other hand data might be received in a way that will cause the signal\n to be emitted in shorter intervals than specified here under some\n circumstances."]
    pub fn obs_volmeter_set_update_interval(volmeter: *mut obs_volmeter_t, ms: ::std::os::raw::c_uint);
    #[doc = " @brief Get the update interval currently used for the volume meter\n @param volmeter pointer to the volume meter object\n @return update interval in ms"]
    pub fn obs_volmeter_get_update_interval(volmeter: *mut obs_volmeter_t) -> ::std::os::raw::c_uint;
    #[doc = " @brief Get the number of channels which are configured for this source.\n @param volmeter pointer to the volume meter object"]
    pub fn obs_volmeter_get_nr_channels(volmeter: *mut obs_volmeter_t) -> ::std::os::raw::c_int;
    pub fn obs_volmeter_add_callback(
        volmeter: *mut obs_volmeter_t,
        callback: obs_volmeter_updated_t,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_volmeter_remove_callback(
        volmeter: *mut obs_volmeter_t,
        callback: obs_volmeter_updated_t,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_mul_to_db(mul: f32) -> f32;
    pub fn obs_db_to_mul(db: f32) -> f32;
    pub fn obs_fader_db_to_def(fader: *mut obs_fader_t) -> obs_fader_conversion_t;
    pub fn obs_hotkey_get_id(key: *const obs_hotkey_t) -> obs_hotkey_id;
    pub fn obs_hotkey_get_name(key: *const obs_hotkey_t) -> *const ::std::os::raw::c_char;
    pub fn obs_hotkey_get_description(key: *const obs_hotkey_t) -> *const ::std::os::raw::c_char;
    pub fn obs_hotkey_get_registerer_type(key: *const obs_hotkey_t) -> obs_hotkey_registerer_t;
    pub fn obs_hotkey_get_registerer(key: *const obs_hotkey_t) -> *mut ::std::os::raw::c_void;
    pub fn obs_hotkey_get_pair_partner_id(key: *const obs_hotkey_t) -> obs_hotkey_id;
    pub fn obs_hotkey_binding_get_key_combination(binding: *mut obs_hotkey_binding_t) -> obs_key_combination_t;
    pub fn obs_hotkey_binding_get_hotkey_id(binding: *mut obs_hotkey_binding_t) -> obs_hotkey_id;
    pub fn obs_hotkey_binding_get_hotkey(binding: *mut obs_hotkey_binding_t) -> *mut obs_hotkey_t;
    pub fn obs_hotkey_set_name(id: obs_hotkey_id, name: *const ::std::os::raw::c_char);
    pub fn obs_hotkey_set_description(id: obs_hotkey_id, desc: *const ::std::os::raw::c_char);
    pub fn obs_hotkey_pair_set_names(
        id: obs_hotkey_pair_id,
        name0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
    );
    pub fn obs_hotkey_pair_set_descriptions(
        id: obs_hotkey_pair_id,
        desc0: *const ::std::os::raw::c_char,
        desc1: *const ::std::os::raw::c_char,
    );
    pub fn obs_hotkeys_set_translations_s(translations: *mut obs_hotkeys_translations, size: usize);
    pub fn obs_hotkeys_set_audio_hotkeys_translations(
        mute: *const ::std::os::raw::c_char,
        unmute: *const ::std::os::raw::c_char,
        push_to_mute: *const ::std::os::raw::c_char,
        push_to_talk: *const ::std::os::raw::c_char,
    );
    pub fn obs_hotkeys_set_sceneitem_hotkeys_translations(
        show: *const ::std::os::raw::c_char,
        hide: *const ::std::os::raw::c_char,
    );
    pub fn obs_hotkey_register_frontend(
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
    pub fn obs_hotkey_register_encoder(
        encoder: *mut obs_encoder_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
    pub fn obs_hotkey_register_output(
        output: *mut obs_output_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
    pub fn obs_hotkey_register_service(
        service: *mut obs_service_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
    pub fn obs_hotkey_register_source(
        source: *mut obs_source_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
    pub fn obs_hotkey_pair_register_frontend(
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
    pub fn obs_hotkey_pair_register_encoder(
        encoder: *mut obs_encoder_t,
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
    pub fn obs_hotkey_pair_register_output(
        output: *mut obs_output_t,
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
    pub fn obs_hotkey_pair_register_service(
        service: *mut obs_service_t,
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
    pub fn obs_hotkey_pair_register_source(
        source: *mut obs_source_t,
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
    pub fn obs_hotkey_unregister(id: obs_hotkey_id);
    pub fn obs_hotkey_pair_unregister(id: obs_hotkey_pair_id);
    pub fn obs_hotkey_load_bindings(id: obs_hotkey_id, combinations: *mut obs_key_combination_t, num: usize);
    pub fn obs_hotkey_load(id: obs_hotkey_id, data: *mut obs_data_array_t);
    pub fn obs_hotkeys_load_encoder(encoder: *mut obs_encoder_t, hotkeys: *mut obs_data_t);
    pub fn obs_hotkeys_load_output(output: *mut obs_output_t, hotkeys: *mut obs_data_t);
    pub fn obs_hotkeys_load_service(service: *mut obs_service_t, hotkeys: *mut obs_data_t);
    pub fn obs_hotkeys_load_source(source: *mut obs_source_t, hotkeys: *mut obs_data_t);
    pub fn obs_hotkey_pair_load(id: obs_hotkey_pair_id, data0: *mut obs_data_array_t, data1: *mut obs_data_array_t);
    pub fn obs_hotkey_save(id: obs_hotkey_id) -> *mut obs_data_array_t;
    pub fn obs_hotkey_pair_save(
        id: obs_hotkey_pair_id,
        p_data0: *mut *mut obs_data_array_t,
        p_data1: *mut *mut obs_data_array_t,
    );
    pub fn obs_hotkeys_save_encoder(encoder: *mut obs_encoder_t) -> *mut obs_data_t;
    pub fn obs_hotkeys_save_output(output: *mut obs_output_t) -> *mut obs_data_t;
    pub fn obs_hotkeys_save_service(service: *mut obs_service_t) -> *mut obs_data_t;
    pub fn obs_hotkeys_save_source(source: *mut obs_source_t) -> *mut obs_data_t;
    pub fn obs_enum_hotkeys(func: obs_hotkey_enum_func, data: *mut ::std::os::raw::c_void);
    pub fn obs_enum_hotkey_bindings(func: obs_hotkey_binding_enum_func, data: *mut ::std::os::raw::c_void);
    pub fn obs_hotkey_inject_event(hotkey: obs_key_combination_t, pressed: bool);
    pub fn obs_hotkey_enable_background_press(enable: bool);
    pub fn obs_hotkey_enable_strict_modifiers(enable: bool);
    pub fn obs_hotkey_set_callback_routing_func(
        func: obs_hotkey_callback_router_func,
        data: *mut ::std::os::raw::c_void,
    );
    pub fn obs_hotkey_trigger_routed_callback(id: obs_hotkey_id, pressed: bool);
    pub fn obs_hotkey_enable_callback_rerouting(enable: bool);
    pub fn obs_hotkey_update_atomic(func: obs_hotkey_atomic_update_func, data: *mut ::std::os::raw::c_void);
    pub fn obs_key_to_str(key: obs_key_t, str_: *mut dstr);
    pub fn obs_key_combination_to_str(key: obs_key_combination_t, str_: *mut dstr);
    pub fn obs_key_from_virtual_key(code: ::std::os::raw::c_int) -> obs_key_t;
    pub fn obs_key_to_virtual_key(key: obs_key_t) -> ::std::os::raw::c_int;
    pub fn obs_key_to_name(key: obs_key_t) -> *const ::std::os::raw::c_char;
    pub fn obs_key_from_name(name: *const ::std::os::raw::c_char) -> obs_key_t;
    #[doc = " Find a core libobs data file\n @param path name of the base file\n @return A string containing the full path to the file.\n          Use bfree after use."]
    pub fn obs_find_data_file(file: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    #[doc = " Add a path to search libobs data files in.\n @param path Full path to directory to look in.\n             The string is copied."]
    pub fn obs_add_data_path(path: *const ::std::os::raw::c_char);
    #[doc = " Remove a path from libobs core data paths.\n @param path The path to compare to currently set paths.\n             It does not need to be the same pointer, but\n             the path string must match an entry fully.\n @return Whether or not the path was successfully removed.\n         If false, the path could not be found."]
    pub fn obs_remove_data_path(path: *const ::std::os::raw::c_char) -> bool;
    #[doc = " Initializes OBS\n\n @param  locale              The locale to use for modules\n @param  module_config_path  Path to module config storage directory\n                             (or NULL if none)\n @param  store               The profiler name store for OBS to use or NULL"]
    pub fn obs_startup(
        locale: *const ::std::os::raw::c_char,
        module_config_path: *const ::std::os::raw::c_char,
        store: *mut profiler_name_store_t,
    ) -> bool;
    #[doc = " Releases all data associated with OBS and terminates the OBS context"]
    pub fn obs_shutdown();
    #[doc = " @return true if the main OBS context has been initialized"]
    pub fn obs_initialized() -> bool;
    #[doc = " @return The current core version"]
    pub fn obs_get_version() -> u32;
    #[doc = " @return The current core version string"]
    pub fn obs_get_version_string() -> *const ::std::os::raw::c_char;
    #[doc = " Sets things up for calls to obs_get_cmdline_args. Called only once at startup\n and safely copies argv/argc from main(). Subsequent calls do nothing.\n\n @param  argc  The count of command line arguments, from main()\n @param  argv  An array of command line arguments, copied from main() and ends\n               with NULL."]
    pub fn obs_set_cmdline_args(argc: ::std::os::raw::c_int, argv: *const *const ::std::os::raw::c_char);
    #[doc = " Get the argc/argv used to start OBS\n\n @return  The command line arguments used for main(). Don't modify this or\n          you'll mess things up for other callers."]
    pub fn obs_get_cmdline_args() -> obs_cmdline_args;
    #[doc = " Sets a new locale to use for modules.  This will call obs_module_set_locale\n for each module with the new locale.\n\n @param  locale  The locale to use for modules"]
    pub fn obs_set_locale(locale: *const ::std::os::raw::c_char);
    #[doc = " @return the current locale"]
    pub fn obs_get_locale() -> *const ::std::os::raw::c_char;
    pub fn obs_init_win32_crash_handler();
    #[doc = " Returns the profiler name store (see util/profiler.h) used by OBS, which is\n either a name store passed to obs_startup, an internal name store, or NULL\n in case obs_initialized() returns false."]
    pub fn obs_get_profiler_name_store() -> *mut profiler_name_store_t;
    #[doc = " Sets base video output base resolution/fps/format.\n\n @note This data cannot be changed if an output is currently active.\n @note The graphics module cannot be changed without fully destroying the\n       OBS context.\n\n @param   ovi  Pointer to an obs_video_info structure containing the\n               specification of the graphics subsystem,\n @return       OBS_VIDEO_SUCCESS if successful\n               OBS_VIDEO_NOT_SUPPORTED if the adapter lacks capabilities\n               OBS_VIDEO_INVALID_PARAM if a parameter is invalid\n               OBS_VIDEO_CURRENTLY_ACTIVE if video is currently active\n               OBS_VIDEO_MODULE_NOT_FOUND if the graphics module is not found\n               OBS_VIDEO_FAIL for generic failure"]
    pub fn obs_reset_video(ovi: *mut obs_video_info) -> ::std::os::raw::c_int;
    #[doc = " Sets base audio output format/channels/samples/etc\n\n @note Cannot reset base audio if an output is currently active."]
    pub fn obs_reset_audio(oai: *const obs_audio_info) -> bool;
    pub fn obs_reset_audio2(oai: *const obs_audio_info2) -> bool;
    #[doc = " Gets the current video settings, returns false if no video"]
    pub fn obs_get_video_info(ovi: *mut obs_video_info) -> bool;
    #[doc = " Gets the SDR white level, returns 300.f if no video"]
    pub fn obs_get_video_sdr_white_level() -> f32;
    #[doc = " Gets the HDR nominal peak level, returns 1000.f if no video"]
    pub fn obs_get_video_hdr_nominal_peak_level() -> f32;
    #[doc = " Sets the video levels"]
    pub fn obs_set_video_levels(sdr_white_level: f32, hdr_nominal_peak_level: f32);
    #[doc = " Gets the current audio settings, returns false if no audio"]
    pub fn obs_get_audio_info(oai: *mut obs_audio_info) -> bool;
    #[doc = " Opens a plugin module directly from a specific path.\n\n If the module already exists then the function will return successful, and\n the module parameter will be given the pointer to the existing module.\n\n This does not initialize the module, it only loads the module image.  To\n initialize the module, call obs_init_module.\n\n @param  module     The pointer to the created module.\n @param  path       Specifies the path to the module library file.  If the\n                    extension is not specified, it will use the extension\n                    appropriate to the operating system.\n @param  data_path  Specifies the path to the directory where the module's\n                    data files are stored.\n @returns           MODULE_SUCCESS if successful\n                    MODULE_ERROR if a generic error occurred\n                    MODULE_FILE_NOT_FOUND if the module was not found\n                    MODULE_MISSING_EXPORTS if required exports are missing\n                    MODULE_INCOMPATIBLE_VER if incompatible version"]
    pub fn obs_open_module(
        module: *mut *mut obs_module_t,
        path: *const ::std::os::raw::c_char,
        data_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    #[doc = " Initializes the module, which calls its obs_module_load export.  If the\n module is already loaded, then this function does nothing and returns\n successful."]
    pub fn obs_init_module(module: *mut obs_module_t) -> bool;
    #[doc = " Returns a module based upon its name, or NULL if not found"]
    pub fn obs_get_module(name: *const ::std::os::raw::c_char) -> *mut obs_module_t;
    #[doc = " Gets library of module"]
    pub fn obs_get_module_lib(module: *mut obs_module_t) -> *mut ::std::os::raw::c_void;
    #[doc = " Returns locale text from a specific module"]
    pub fn obs_module_get_locale_string(
        mod_: *const obs_module_t,
        lookup_string: *const ::std::os::raw::c_char,
        translated_string: *mut *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn obs_module_get_locale_text(
        mod_: *const obs_module_t,
        text: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
    #[doc = " Logs loaded modules"]
    pub fn obs_log_loaded_modules();
    #[doc = " Returns the module file name"]
    pub fn obs_get_module_file_name(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
    #[doc = " Returns the module full name"]
    pub fn obs_get_module_name(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
    #[doc = " Returns the module author(s)"]
    pub fn obs_get_module_author(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
    #[doc = " Returns the module description"]
    pub fn obs_get_module_description(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
    #[doc = " Returns the module binary path"]
    pub fn obs_get_module_binary_path(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
    #[doc = " Returns the module data path"]
    pub fn obs_get_module_data_path(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
    #[doc = " Adds a module search path to be used with obs_find_modules.  If the search\n path strings contain %module%, that text will be replaced with the module\n name when used.\n\n @param  bin   Specifies the module's binary directory search path.\n @param  data  Specifies the module's data directory search path."]
    pub fn obs_add_module_path(bin: *const ::std::os::raw::c_char, data: *const ::std::os::raw::c_char);
    #[doc = " Adds a module to the list of modules allowed to load in Safe Mode.\n If the list is empty, all modules are allowed.\n\n @param  name  Specifies the module's name (filename sans extension)."]
    pub fn obs_add_safe_module(name: *const ::std::os::raw::c_char);
    #[doc = " Automatically loads all modules from module paths (convenience function)"]
    pub fn obs_load_all_modules();
    pub fn obs_module_failure_info_free(mfi: *mut obs_module_failure_info);
    pub fn obs_load_all_modules2(mfi: *mut obs_module_failure_info);
    #[doc = " Notifies modules that all modules have been loaded.  This function should\n be called after all modules have been loaded."]
    pub fn obs_post_load_modules();
    #[doc = " Finds all modules within the search paths added by obs_add_module_path."]
    pub fn obs_find_modules(callback: obs_find_module_callback_t, param: *mut ::std::os::raw::c_void);
    #[doc = " Finds all modules within the search paths added by obs_add_module_path."]
    pub fn obs_find_modules2(callback: obs_find_module_callback2_t, param: *mut ::std::os::raw::c_void);
    #[doc = " Enumerates all loaded modules"]
    pub fn obs_enum_modules(callback: obs_enum_module_callback_t, param: *mut ::std::os::raw::c_void);
    #[doc = " Helper function for using default module locale"]
    pub fn obs_module_load_locale(
        module: *mut obs_module_t,
        default_locale: *const ::std::os::raw::c_char,
        locale: *const ::std::os::raw::c_char,
    ) -> *mut lookup_t;
    #[doc = " Returns the location of a plugin module data file.\n\n @note   Modules should use obs_module_file function defined in obs-module.h\n         as a more elegant means of getting their files without having to\n         specify the module parameter.\n\n @param  module  The module associated with the file to locate\n @param  file    The file to locate\n @return         Path string, or NULL if not found.  Use bfree to free string."]
    pub fn obs_find_module_file(
        module: *mut obs_module_t,
        file: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    #[doc = " Returns the path of a plugin module config file (whether it exists or not)\n\n @note   Modules should use obs_module_config_path function defined in\n         obs-module.h as a more elegant means of getting their files without\n         having to specify the module parameter.\n\n @param  module  The module associated with the path\n @param  file    The file to get a path to\n @return         Path string, or NULL if not found.  Use bfree to free string."]
    pub fn obs_module_get_config_path(
        module: *mut obs_module_t,
        file: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    #[doc = " Enumerates all source types (inputs, filters, transitions, etc)."]
    pub fn obs_enum_source_types(idx: usize, id: *mut *const ::std::os::raw::c_char) -> bool;
    #[doc = " Enumerates all available inputs source types.\n\n   Inputs are general source inputs (such as capture sources, device sources,\n etc)."]
    pub fn obs_enum_input_types(idx: usize, id: *mut *const ::std::os::raw::c_char) -> bool;
    pub fn obs_enum_input_types2(
        idx: usize,
        id: *mut *const ::std::os::raw::c_char,
        unversioned_id: *mut *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn obs_get_latest_input_type_id(unversioned_id: *const ::std::os::raw::c_char)
        -> *const ::std::os::raw::c_char;
    #[doc = " Enumerates all available filter source types.\n\n   Filters are sources that are used to modify the video/audio output of\n other sources."]
    pub fn obs_enum_filter_types(idx: usize, id: *mut *const ::std::os::raw::c_char) -> bool;
    #[doc = " Enumerates all available transition source types.\n\n   Transitions are sources used to transition between two or more other\n sources."]
    pub fn obs_enum_transition_types(idx: usize, id: *mut *const ::std::os::raw::c_char) -> bool;
    #[doc = " Enumerates all available output types."]
    pub fn obs_enum_output_types(idx: usize, id: *mut *const ::std::os::raw::c_char) -> bool;
    #[doc = " Enumerates all available encoder types."]
    pub fn obs_enum_encoder_types(idx: usize, id: *mut *const ::std::os::raw::c_char) -> bool;
    #[doc = " Enumerates all available service types."]
    pub fn obs_enum_service_types(idx: usize, id: *mut *const ::std::os::raw::c_char) -> bool;
    #[doc = " Helper function for entering the OBS graphics context"]
    pub fn obs_enter_graphics();
    #[doc = " Helper function for leaving the OBS graphics context"]
    pub fn obs_leave_graphics();
    #[doc = " Gets the main audio output handler for this OBS context"]
    pub fn obs_get_audio() -> *mut audio_t;
    #[doc = " Gets the main video output handler for this OBS context"]
    pub fn obs_get_video() -> *mut video_t;
    #[doc = " Returns true if video is active, false otherwise"]
    pub fn obs_video_active() -> bool;
    #[doc = " Sets the primary output source for a channel."]
    pub fn obs_set_output_source(channel: u32, source: *mut obs_source_t);
    #[doc = " Gets the primary output source for a channel and increments the reference\n counter for that source.  Use obs_source_release to release."]
    pub fn obs_get_output_source(channel: u32) -> *mut obs_source_t;
    #[doc = " Enumerates all input sources\n\n   Callback function returns true to continue enumeration, or false to end\n enumeration.\n\n   Use obs_source_get_ref or obs_source_get_weak_source if you want to retain\n a reference after obs_enum_sources finishes"]
    pub fn obs_enum_sources(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut obs_source_t) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
    #[doc = " Enumerates scenes"]
    pub fn obs_enum_scenes(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut obs_source_t) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
    #[doc = " Enumerates all sources (regardless of type)"]
    pub fn obs_enum_all_sources(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut obs_source_t) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
    #[doc = " Enumerates outputs"]
    pub fn obs_enum_outputs(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut obs_output_t) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
    #[doc = " Enumerates encoders"]
    pub fn obs_enum_encoders(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut obs_encoder_t) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
    #[doc = " Enumerates encoders"]
    pub fn obs_enum_services(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut obs_service_t) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
    #[doc = " Gets a source by its name.\n\n   Increments the source reference counter, use obs_source_release to\n release it when complete."]
    pub fn obs_get_source_by_name(name: *const ::std::os::raw::c_char) -> *mut obs_source_t;
    #[doc = " Gets a source by its UUID.\n\n   Increments the source reference counter, use obs_source_release to\n release it when complete."]
    pub fn obs_get_source_by_uuid(uuid: *const ::std::os::raw::c_char) -> *mut obs_source_t;
    #[doc = " Get a transition source by its name."]
    pub fn obs_get_transition_by_name(name: *const ::std::os::raw::c_char) -> *mut obs_source_t;
    #[doc = " Get a transition source by its UUID."]
    pub fn obs_get_transition_by_uuid(uuid: *const ::std::os::raw::c_char) -> *mut obs_source_t;
    #[doc = " Gets an output by its name."]
    pub fn obs_get_output_by_name(name: *const ::std::os::raw::c_char) -> *mut obs_output_t;
    #[doc = " Gets an encoder by its name."]
    pub fn obs_get_encoder_by_name(name: *const ::std::os::raw::c_char) -> *mut obs_encoder_t;
    #[doc = " Gets an service by its name."]
    pub fn obs_get_service_by_name(name: *const ::std::os::raw::c_char) -> *mut obs_service_t;
    #[doc = " Returns a commonly used base effect"]
    pub fn obs_get_base_effect(effect: obs_base_effect) -> *mut gs_effect_t;
    pub fn obs_get_default_rect_effect() -> *mut gs_effect_t;
    #[doc = " Returns the primary obs signal handler"]
    pub fn obs_get_signal_handler() -> *mut signal_handler_t;
    #[doc = " Returns the primary obs procedure handler"]
    pub fn obs_get_proc_handler() -> *mut proc_handler_t;
    #[doc = " Renders the main view"]
    pub fn obs_render_main_view();
    #[doc = " Renders the last main output texture"]
    pub fn obs_render_main_texture();
    #[doc = " Renders the last main output texture ignoring background color"]
    pub fn obs_render_main_texture_src_color_only();
    #[doc = " Returns the last main output texture.  This can return NULL if the texture\n is unavailable."]
    pub fn obs_get_main_texture() -> *mut gs_texture_t;
    #[doc = " Sets the master user volume"]
    pub fn obs_set_master_volume(volume: f32);
    #[doc = " Gets the master user volume"]
    pub fn obs_get_master_volume() -> f32;
    #[doc = " Saves a source to settings data"]
    pub fn obs_save_source(source: *mut obs_source_t) -> *mut obs_data_t;
    #[doc = " Loads a source from settings data"]
    pub fn obs_load_source(data: *mut obs_data_t) -> *mut obs_source_t;
    #[doc = " Loads a private source from settings data"]
    pub fn obs_load_private_source(data: *mut obs_data_t) -> *mut obs_source_t;
    #[doc = " Send a save signal to sources"]
    pub fn obs_source_save(source: *mut obs_source_t);
    #[doc = " Send a load signal to sources (soft deprecated; does not load filters)"]
    pub fn obs_source_load(source: *mut obs_source_t);
    #[doc = " Send a load signal to sources"]
    pub fn obs_source_load2(source: *mut obs_source_t);
    #[doc = " Loads sources from a data array"]
    pub fn obs_load_sources(
        array: *mut obs_data_array_t,
        cb: obs_load_source_cb,
        private_data: *mut ::std::os::raw::c_void,
    );
    #[doc = " Saves sources to a data array"]
    pub fn obs_save_sources() -> *mut obs_data_array_t;
    pub fn obs_save_sources_filtered(
        cb: obs_save_source_filter_cb,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut obs_data_array_t;
    #[doc = " Reset source UUIDs. NOTE: this function is only to be used by the UI and\n  will be removed in a future version!"]
    pub fn obs_reset_source_uuids();
    pub fn obs_obj_get_type(obj: *mut ::std::os::raw::c_void) -> obs_obj_type;
    pub fn obs_obj_get_id(obj: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
    pub fn obs_obj_invalid(obj: *mut ::std::os::raw::c_void) -> bool;
    pub fn obs_obj_get_data(obj: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
    pub fn obs_obj_is_private(obj: *mut ::std::os::raw::c_void) -> bool;
    pub fn obs_audio_monitoring_available() -> bool;
    pub fn obs_reset_audio_monitoring();
    pub fn obs_enum_audio_monitoring_devices(cb: obs_enum_audio_device_cb, data: *mut ::std::os::raw::c_void);
    pub fn obs_set_audio_monitoring_device(
        name: *const ::std::os::raw::c_char,
        id: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn obs_get_audio_monitoring_device(
        name: *mut *const ::std::os::raw::c_char,
        id: *mut *const ::std::os::raw::c_char,
    );
    pub fn obs_add_tick_callback(
        tick: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, seconds: f32)>,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_remove_tick_callback(
        tick: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, seconds: f32)>,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_add_main_render_callback(
        draw: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, cx: u32, cy: u32)>,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_remove_main_render_callback(
        draw: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, cx: u32, cy: u32)>,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_add_main_rendered_callback(
        rendered: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_remove_main_rendered_callback(
        rendered: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_add_raw_video_callback(
        conversion: *const video_scale_info,
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, frame: *mut video_data),
        >,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_add_raw_video_callback2(
        conversion: *const video_scale_info,
        frame_rate_divisor: u32,
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, frame: *mut video_data),
        >,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_remove_raw_video_callback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, frame: *mut video_data),
        >,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_add_raw_audio_callback(
        mix_idx: usize,
        conversion: *const audio_convert_info,
        callback: audio_output_callback_t,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_remove_raw_audio_callback(
        mix_idx: usize,
        callback: audio_output_callback_t,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_get_video_frame_time() -> u64;
    pub fn obs_get_active_fps() -> f64;
    pub fn obs_get_average_frame_time_ns() -> u64;
    pub fn obs_get_frame_interval_ns() -> u64;
    pub fn obs_get_total_frames() -> u32;
    pub fn obs_get_lagged_frames() -> u32;
    pub fn obs_nv12_tex_active() -> bool;
    pub fn obs_p010_tex_active() -> bool;
    pub fn obs_apply_private_data(settings: *mut obs_data_t);
    pub fn obs_set_private_data(settings: *mut obs_data_t);
    pub fn obs_get_private_data() -> *mut obs_data_t;
    pub fn obs_queue_task(type_: obs_task_type, task: obs_task_t, param: *mut ::std::os::raw::c_void, wait: bool);
    pub fn obs_in_task_thread(type_: obs_task_type) -> bool;
    pub fn obs_wait_for_destroy_queue() -> bool;
    pub fn obs_set_ui_task_handler(handler: obs_task_handler_t);
    pub fn obs_object_get_ref(object: *mut obs_object_t) -> *mut obs_object_t;
    pub fn obs_object_release(object: *mut obs_object_t);
    pub fn obs_weak_object_addref(weak: *mut obs_weak_object_t);
    pub fn obs_weak_object_release(weak: *mut obs_weak_object_t);
    pub fn obs_object_get_weak_object(object: *mut obs_object_t) -> *mut obs_weak_object_t;
    pub fn obs_weak_object_get_object(weak: *mut obs_weak_object_t) -> *mut obs_object_t;
    pub fn obs_weak_object_expired(weak: *mut obs_weak_object_t) -> bool;
    pub fn obs_weak_object_references_object(weak: *mut obs_weak_object_t, object: *mut obs_object_t) -> bool;
    #[doc = " Creates a view context.\n\n   A view can be used for things like separate previews, or drawing\n sources separately."]
    pub fn obs_view_create() -> *mut obs_view_t;
    #[doc = " Destroys this view context"]
    pub fn obs_view_destroy(view: *mut obs_view_t);
    #[doc = " Sets the source to be used for this view context."]
    pub fn obs_view_set_source(view: *mut obs_view_t, channel: u32, source: *mut obs_source_t);
    #[doc = " Gets the source currently in use for this view context"]
    pub fn obs_view_get_source(view: *mut obs_view_t, channel: u32) -> *mut obs_source_t;
    #[doc = " Renders the sources of this view context"]
    pub fn obs_view_render(view: *mut obs_view_t);
    #[doc = " Adds a view to the main render loop, with current obs_get_video_info state"]
    pub fn obs_view_add(view: *mut obs_view_t) -> *mut video_t;
    #[doc = " Adds a view to the main render loop, with custom video settings"]
    pub fn obs_view_add2(view: *mut obs_view_t, ovi: *mut obs_video_info) -> *mut video_t;
    #[doc = " Removes a view from the main render loop"]
    pub fn obs_view_remove(view: *mut obs_view_t);
    #[doc = " Gets the video settings currently in use for this view context, returns false if no video"]
    pub fn obs_view_get_video_info(view: *mut obs_view_t, ovi: *mut obs_video_info) -> bool;
    #[doc = " Enumerate the video info of all mixes using the specified view context"]
    pub fn obs_view_enum_video_info(
        view: *mut obs_view_t,
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut obs_video_info) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
    #[doc = " Adds a new window display linked to the main render pipeline.  This creates\n a new swap chain which updates every frame.\n\n @param  graphics_data  The swap chain initialization data.\n @return                The new display context, or NULL if failed."]
    pub fn obs_display_create(graphics_data: *const gs_init_data, backround_color: u32) -> *mut obs_display_t;
    #[doc = " Destroys a display context"]
    pub fn obs_display_destroy(display: *mut obs_display_t);
    #[doc = " Changes the size of this display"]
    pub fn obs_display_resize(display: *mut obs_display_t, cx: u32, cy: u32);
    #[doc = " Updates the color space of this display"]
    pub fn obs_display_update_color_space(display: *mut obs_display_t);
    #[doc = " Adds a draw callback for this display context\n\n @param  display  The display context.\n @param  draw     The draw callback which is called each time a frame\n                  updates.\n @param  param    The user data to be associated with this draw callback."]
    pub fn obs_display_add_draw_callback(
        display: *mut obs_display_t,
        draw: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, cx: u32, cy: u32)>,
        param: *mut ::std::os::raw::c_void,
    );
    #[doc = " Removes a draw callback for this display context"]
    pub fn obs_display_remove_draw_callback(
        display: *mut obs_display_t,
        draw: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, cx: u32, cy: u32)>,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_display_set_enabled(display: *mut obs_display_t, enable: bool);
    pub fn obs_display_enabled(display: *mut obs_display_t) -> bool;
    pub fn obs_display_set_background_color(display: *mut obs_display_t, color: u32);
    pub fn obs_display_size(display: *mut obs_display_t, width: *mut u32, height: *mut u32);
    #[doc = " Returns the translated display name of a source"]
    pub fn obs_source_get_display_name(id: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
    #[doc = " Creates a source of the specified type with the specified settings.\n\n   The \"source\" context is used for anything related to presenting\n or modifying video/audio.  Use obs_source_release to release it."]
    pub fn obs_source_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_source_t;
    pub fn obs_source_create_private(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
    ) -> *mut obs_source_t;
    pub fn obs_source_duplicate(
        source: *mut obs_source_t,
        desired_name: *const ::std::os::raw::c_char,
        create_private: bool,
    ) -> *mut obs_source_t;
    #[doc = " Adds/releases a reference to a source.  When the last reference is\n released, the source is destroyed."]
    pub fn obs_source_addref(source: *mut obs_source_t);
    pub fn obs_source_release(source: *mut obs_source_t);
    pub fn obs_weak_source_addref(weak: *mut obs_weak_source_t);
    pub fn obs_weak_source_release(weak: *mut obs_weak_source_t);
    pub fn obs_source_get_ref(source: *mut obs_source_t) -> *mut obs_source_t;
    pub fn obs_source_get_weak_source(source: *mut obs_source_t) -> *mut obs_weak_source_t;
    pub fn obs_weak_source_get_source(weak: *mut obs_weak_source_t) -> *mut obs_source_t;
    pub fn obs_weak_source_expired(weak: *mut obs_weak_source_t) -> bool;
    pub fn obs_weak_source_references_source(weak: *mut obs_weak_source_t, source: *mut obs_source_t) -> bool;
    #[doc = " Notifies all references that the source should be released"]
    pub fn obs_source_remove(source: *mut obs_source_t);
    #[doc = " Returns true if the source should be released"]
    pub fn obs_source_removed(source: *const obs_source_t) -> bool;
    #[doc = " The 'hidden' flag is not the same as a sceneitem's visibility. It is a\n property the determines if it can be found through searches. **/\n/** Simply sets a 'hidden' flag when the source is still alive but shouldn't be found"]
    pub fn obs_source_set_hidden(source: *mut obs_source_t, hidden: bool);
    #[doc = " Returns the current 'hidden' state on the source"]
    pub fn obs_source_is_hidden(source: *mut obs_source_t) -> bool;
    #[doc = " Returns capability flags of a source"]
    pub fn obs_source_get_output_flags(source: *const obs_source_t) -> u32;
    #[doc = " Returns capability flags of a source type"]
    pub fn obs_get_source_output_flags(id: *const ::std::os::raw::c_char) -> u32;
    #[doc = " Gets the default settings for a source type"]
    pub fn obs_get_source_defaults(id: *const ::std::os::raw::c_char) -> *mut obs_data_t;
    #[doc = " Returns the property list, if any.  Free with obs_properties_destroy"]
    pub fn obs_get_source_properties(id: *const ::std::os::raw::c_char) -> *mut obs_properties_t;
    pub fn obs_source_get_missing_files(source: *const obs_source_t) -> *mut obs_missing_files_t;
    pub fn obs_source_replace_missing_file(
        cb: obs_missing_file_cb,
        source: *mut obs_source_t,
        new_path: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    );
    #[doc = " Returns whether the source has custom properties or not"]
    pub fn obs_is_source_configurable(id: *const ::std::os::raw::c_char) -> bool;
    pub fn obs_source_configurable(source: *const obs_source_t) -> bool;
    #[doc = " Returns the properties list for a specific existing source.  Free with\n obs_properties_destroy"]
    pub fn obs_source_properties(source: *const obs_source_t) -> *mut obs_properties_t;
    #[doc = " Updates settings for this source"]
    pub fn obs_source_update(source: *mut obs_source_t, settings: *mut obs_data_t);
    pub fn obs_source_reset_settings(source: *mut obs_source_t, settings: *mut obs_data_t);
    #[doc = " Renders a video source."]
    pub fn obs_source_video_render(source: *mut obs_source_t);
    #[doc = " Gets the width of a source (if it has video)"]
    pub fn obs_source_get_width(source: *mut obs_source_t) -> u32;
    #[doc = " Gets the height of a source (if it has video)"]
    pub fn obs_source_get_height(source: *mut obs_source_t) -> u32;
    #[doc = " Gets the color space of a source (if it has video)"]
    pub fn obs_source_get_color_space(
        source: *mut obs_source_t,
        count: usize,
        preferred_spaces: *const gs_color_space,
    ) -> gs_color_space;
    #[doc = " Hints whether or not the source will blend texels"]
    pub fn obs_source_get_texcoords_centered(source: *mut obs_source_t) -> bool;
    #[doc = " If the source is a filter, returns the parent source of the filter.  Only\n guaranteed to be valid inside of the video_render, filter_audio,\n filter_video, and filter_remove callbacks."]
    pub fn obs_filter_get_parent(filter: *const obs_source_t) -> *mut obs_source_t;
    #[doc = " If the source is a filter, returns the target source of the filter.  Only\n guaranteed to be valid inside of the video_render, filter_audio,\n filter_video, and filter_remove callbacks."]
    pub fn obs_filter_get_target(filter: *const obs_source_t) -> *mut obs_source_t;
    #[doc = " Used to directly render a non-async source without any filter processing"]
    pub fn obs_source_default_render(source: *mut obs_source_t);
    #[doc = " Adds a filter to the source (which is used whenever the source is used)"]
    pub fn obs_source_filter_add(source: *mut obs_source_t, filter: *mut obs_source_t);
    #[doc = " Removes a filter from the source"]
    pub fn obs_source_filter_remove(source: *mut obs_source_t, filter: *mut obs_source_t);
    #[doc = " Modifies the order of a specific filter"]
    pub fn obs_source_filter_set_order(
        source: *mut obs_source_t,
        filter: *mut obs_source_t,
        movement: obs_order_movement,
    );
    #[doc = " Gets filter index"]
    pub fn obs_source_filter_get_index(source: *mut obs_source_t, filter: *mut obs_source_t) -> ::std::os::raw::c_int;
    #[doc = " Sets filter index"]
    pub fn obs_source_filter_set_index(source: *mut obs_source_t, filter: *mut obs_source_t, index: usize);
    #[doc = " Gets the settings string for a source"]
    pub fn obs_source_get_settings(source: *const obs_source_t) -> *mut obs_data_t;
    #[doc = " Gets the name of a source"]
    pub fn obs_source_get_name(source: *const obs_source_t) -> *const ::std::os::raw::c_char;
    #[doc = " Sets the name of a source"]
    pub fn obs_source_set_name(source: *mut obs_source_t, name: *const ::std::os::raw::c_char);
    #[doc = " Gets the UUID of a source"]
    pub fn obs_source_get_uuid(source: *const obs_source_t) -> *const ::std::os::raw::c_char;
    #[doc = " Gets the source type"]
    pub fn obs_source_get_type(source: *const obs_source_t) -> obs_source_type;
    #[doc = " Gets the source identifier"]
    pub fn obs_source_get_id(source: *const obs_source_t) -> *const ::std::os::raw::c_char;
    pub fn obs_source_get_unversioned_id(source: *const obs_source_t) -> *const ::std::os::raw::c_char;
    #[doc = " Returns the signal handler for a source"]
    pub fn obs_source_get_signal_handler(source: *const obs_source_t) -> *mut signal_handler_t;
    #[doc = " Returns the procedure handler for a source"]
    pub fn obs_source_get_proc_handler(source: *const obs_source_t) -> *mut proc_handler_t;
    #[doc = " Sets the user volume for a source that has audio output"]
    pub fn obs_source_set_volume(source: *mut obs_source_t, volume: f32);
    #[doc = " Gets the user volume for a source that has audio output"]
    pub fn obs_source_get_volume(source: *const obs_source_t) -> f32;
    pub fn obs_source_get_speaker_layout(source: *mut obs_source_t) -> speaker_layout;
    #[doc = " Sets the balance value for a stereo audio source"]
    pub fn obs_source_set_balance_value(source: *mut obs_source_t, balance: f32);
    #[doc = " Gets the balance value for a stereo audio source"]
    pub fn obs_source_get_balance_value(source: *const obs_source_t) -> f32;
    #[doc = " Sets the audio sync offset (in nanoseconds) for a source"]
    pub fn obs_source_set_sync_offset(source: *mut obs_source_t, offset: i64);
    #[doc = " Gets the audio sync offset (in nanoseconds) for a source"]
    pub fn obs_source_get_sync_offset(source: *const obs_source_t) -> i64;
    #[doc = " Enumerates active child sources used by this source"]
    pub fn obs_source_enum_active_sources(
        source: *mut obs_source_t,
        enum_callback: obs_source_enum_proc_t,
        param: *mut ::std::os::raw::c_void,
    );
    #[doc = " Enumerates the entire active child source tree used by this source"]
    pub fn obs_source_enum_active_tree(
        source: *mut obs_source_t,
        enum_callback: obs_source_enum_proc_t,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_source_enum_full_tree(
        source: *mut obs_source_t,
        enum_callback: obs_source_enum_proc_t,
        param: *mut ::std::os::raw::c_void,
    );
    #[doc = " Returns true if active, false if not"]
    pub fn obs_source_active(source: *const obs_source_t) -> bool;
    #[doc = " Returns true if currently displayed somewhere (active or not), false if not"]
    pub fn obs_source_showing(source: *const obs_source_t) -> bool;
    #[doc = " Sets source flags.  Note that these are different from the main output\n flags.  These are generally things that can be set by the source or user,\n while the output flags are more used to determine capabilities of a source."]
    pub fn obs_source_set_flags(source: *mut obs_source_t, flags: u32);
    #[doc = " Gets source flags."]
    pub fn obs_source_get_flags(source: *const obs_source_t) -> u32;
    #[doc = " Sets audio mixer flags.  These flags are used to specify which mixers\n the source's audio should be applied to."]
    pub fn obs_source_set_audio_mixers(source: *mut obs_source_t, mixers: u32);
    #[doc = " Gets audio mixer flags"]
    pub fn obs_source_get_audio_mixers(source: *const obs_source_t) -> u32;
    #[doc = " Increments the 'showing' reference counter to indicate that the source is\n being shown somewhere.  If the reference counter was 0, will call the 'show'\n callback."]
    pub fn obs_source_inc_showing(source: *mut obs_source_t);
    #[doc = " Increments the 'active' reference counter to indicate that the source is\n fully active.  If the reference counter was 0, will call the 'activate'\n callback.\n\n Unlike obs_source_inc_showing, this will cause children of this source to be\n considered showing as well (currently used by transition previews to make\n the stinger transition show correctly).  obs_source_inc_showing should\n generally be used instead."]
    pub fn obs_source_inc_active(source: *mut obs_source_t);
    #[doc = " Decrements the 'showing' reference counter to indicate that the source is\n no longer being shown somewhere.  If the reference counter is set to 0,\n will call the 'hide' callback"]
    pub fn obs_source_dec_showing(source: *mut obs_source_t);
    #[doc = " Decrements the 'active' reference counter to indicate that the source is no\n longer fully active.  If the reference counter is set to 0, will call the\n 'deactivate' callback\n\n Unlike obs_source_dec_showing, this will cause children of this source to be\n considered not showing as well.  obs_source_dec_showing should generally be\n used instead."]
    pub fn obs_source_dec_active(source: *mut obs_source_t);
    #[doc = " Enumerates filters assigned to the source"]
    pub fn obs_source_enum_filters(
        source: *mut obs_source_t,
        callback: obs_source_enum_proc_t,
        param: *mut ::std::os::raw::c_void,
    );
    #[doc = " Gets a filter of a source by its display name."]
    pub fn obs_source_get_filter_by_name(
        source: *mut obs_source_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_source_t;
    #[doc = " Gets the number of filters the source has."]
    pub fn obs_source_filter_count(source: *const obs_source_t) -> usize;
    pub fn obs_source_copy_filters(dst: *mut obs_source_t, src: *mut obs_source_t);
    pub fn obs_source_copy_single_filter(dst: *mut obs_source_t, filter: *mut obs_source_t);
    pub fn obs_source_enabled(source: *const obs_source_t) -> bool;
    pub fn obs_source_set_enabled(source: *mut obs_source_t, enabled: bool);
    pub fn obs_source_muted(source: *const obs_source_t) -> bool;
    pub fn obs_source_set_muted(source: *mut obs_source_t, muted: bool);
    pub fn obs_source_push_to_mute_enabled(source: *mut obs_source_t) -> bool;
    pub fn obs_source_enable_push_to_mute(source: *mut obs_source_t, enabled: bool);
    pub fn obs_source_get_push_to_mute_delay(source: *mut obs_source_t) -> u64;
    pub fn obs_source_set_push_to_mute_delay(source: *mut obs_source_t, delay: u64);
    pub fn obs_source_push_to_talk_enabled(source: *mut obs_source_t) -> bool;
    pub fn obs_source_enable_push_to_talk(source: *mut obs_source_t, enabled: bool);
    pub fn obs_source_get_push_to_talk_delay(source: *mut obs_source_t) -> u64;
    pub fn obs_source_set_push_to_talk_delay(source: *mut obs_source_t, delay: u64);
    pub fn obs_source_add_audio_pause_callback(
        source: *mut obs_source_t,
        callback: signal_callback_t,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_source_remove_audio_pause_callback(
        source: *mut obs_source_t,
        callback: signal_callback_t,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_source_add_audio_capture_callback(
        source: *mut obs_source_t,
        callback: obs_source_audio_capture_t,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_source_remove_audio_capture_callback(
        source: *mut obs_source_t,
        callback: obs_source_audio_capture_t,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_source_add_caption_callback(
        source: *mut obs_source_t,
        callback: obs_source_caption_t,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_source_remove_caption_callback(
        source: *mut obs_source_t,
        callback: obs_source_caption_t,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_source_set_deinterlace_mode(source: *mut obs_source_t, mode: obs_deinterlace_mode);
    pub fn obs_source_get_deinterlace_mode(source: *const obs_source_t) -> obs_deinterlace_mode;
    pub fn obs_source_set_deinterlace_field_order(source: *mut obs_source_t, field_order: obs_deinterlace_field_order);
    pub fn obs_source_get_deinterlace_field_order(source: *const obs_source_t) -> obs_deinterlace_field_order;
    pub fn obs_source_set_monitoring_type(source: *mut obs_source_t, type_: obs_monitoring_type);
    pub fn obs_source_get_monitoring_type(source: *const obs_source_t) -> obs_monitoring_type;
    #[doc = " Gets private front-end settings data.  This data is saved/loaded\n automatically.  Returns an incremented reference."]
    pub fn obs_source_get_private_settings(item: *mut obs_source_t) -> *mut obs_data_t;
    pub fn obs_source_backup_filters(source: *mut obs_source_t) -> *mut obs_data_array_t;
    pub fn obs_source_restore_filters(source: *mut obs_source_t, array: *mut obs_data_array_t);
    pub fn obs_source_get_type_data(source: *mut obs_source_t) -> *mut ::std::os::raw::c_void;
    #[doc = " Helper function to set the color matrix information when drawing the source.\n\n @param  color_matrix     The color matrix.  Assigns to the 'color_matrix'\n                          effect variable.\n @param  color_range_min  The minimum color range.  Assigns to the\n                          'color_range_min' effect variable.  If NULL,\n                          {0.0f, 0.0f, 0.0f} is used.\n @param  color_range_max  The maximum color range.  Assigns to the\n                          'color_range_max' effect variable.  If NULL,\n                          {1.0f, 1.0f, 1.0f} is used."]
    pub fn obs_source_draw_set_color_matrix(
        color_matrix: *const matrix4,
        color_range_min: *const vec3,
        color_range_max: *const vec3,
    );
    #[doc = " Helper function to draw sprites for a source (synchronous video).\n\n @param  image   The sprite texture to draw.  Assigns to the 'image' variable\n                 of the current effect.\n @param  x       X position of the sprite.\n @param  y       Y position of the sprite.\n @param  cx      Width of the sprite.  If 0, uses the texture width.\n @param  cy      Height of the sprite.  If 0, uses the texture height.\n @param  flip    Specifies whether to flip the image vertically."]
    pub fn obs_source_draw(
        image: *mut gs_texture_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cx: u32,
        cy: u32,
        flip: bool,
    );
    #[doc = " Outputs asynchronous video data.  Set to NULL to deactivate the texture\n\n NOTE: Non-YUV formats will always be treated as full range with this\n function!  Use obs_source_output_video2 instead if partial range support is\n desired for non-YUV video formats."]
    pub fn obs_source_output_video(source: *mut obs_source_t, frame: *const obs_source_frame);
    pub fn obs_source_output_video2(source: *mut obs_source_t, frame: *const obs_source_frame2);
    pub fn obs_source_set_async_rotation(source: *mut obs_source_t, rotation: ::std::os::raw::c_long);
    pub fn obs_source_output_cea708(source: *mut obs_source_t, captions: *const obs_source_cea_708);
    #[doc = " Preloads asynchronous video data to allow instantaneous playback\n\n NOTE: Non-YUV formats will always be treated as full range with this\n function!  Use obs_source_preload_video2 instead if partial range support is\n desired for non-YUV video formats."]
    pub fn obs_source_preload_video(source: *mut obs_source_t, frame: *const obs_source_frame);
    pub fn obs_source_preload_video2(source: *mut obs_source_t, frame: *const obs_source_frame2);
    #[doc = " Shows any preloaded video data"]
    pub fn obs_source_show_preloaded_video(source: *mut obs_source_t);
    #[doc = " Sets current async video frame immediately\n\n NOTE: Non-YUV formats will always be treated as full range with this\n function!  Use obs_source_preload_video2 instead if partial range support is\n desired for non-YUV video formats."]
    pub fn obs_source_set_video_frame(source: *mut obs_source_t, frame: *const obs_source_frame);
    pub fn obs_source_set_video_frame2(source: *mut obs_source_t, frame: *const obs_source_frame2);
    #[doc = " Outputs audio data (always asynchronous)"]
    pub fn obs_source_output_audio(source: *mut obs_source_t, audio: *const obs_source_audio);
    #[doc = " Signal an update to any currently used properties via 'update_properties'"]
    pub fn obs_source_update_properties(source: *mut obs_source_t);
    #[doc = " Gets the current async video frame"]
    pub fn obs_source_get_frame(source: *mut obs_source_t) -> *mut obs_source_frame;
    #[doc = " Releases the current async video frame"]
    pub fn obs_source_release_frame(source: *mut obs_source_t, frame: *mut obs_source_frame);
    #[doc = " Default RGB filter handler for generic effect filters.  Processes the\n filter chain and renders them to texture if needed, then the filter is\n drawn with\n\n After calling this, set your parameters for the effect, then call\n obs_source_process_filter_end to draw the filter.\n\n Returns true if filtering should continue, false if the filter is bypassed\n for whatever reason."]
    pub fn obs_source_process_filter_begin(
        filter: *mut obs_source_t,
        format: gs_color_format,
        allow_direct: obs_allow_direct_render,
    ) -> bool;
    pub fn obs_source_process_filter_begin_with_color_space(
        filter: *mut obs_source_t,
        format: gs_color_format,
        space: gs_color_space,
        allow_direct: obs_allow_direct_render,
    ) -> bool;
    #[doc = " Draws the filter.\n\n Before calling this function, first call obs_source_process_filter_begin and\n then set the effect parameters, and then call this function to finalize the\n filter."]
    pub fn obs_source_process_filter_end(filter: *mut obs_source_t, effect: *mut gs_effect_t, width: u32, height: u32);
    #[doc = " Draws the filter with a specific technique.\n\n Before calling this function, first call obs_source_process_filter_begin and\n then set the effect parameters, and then call this function to finalize the\n filter."]
    pub fn obs_source_process_filter_tech_end(
        filter: *mut obs_source_t,
        effect: *mut gs_effect_t,
        width: u32,
        height: u32,
        tech_name: *const ::std::os::raw::c_char,
    );
    #[doc = " Skips the filter if the filter is invalid and cannot be rendered"]
    pub fn obs_source_skip_video_filter(filter: *mut obs_source_t);
    #[doc = " Adds an active child source.  Must be called by parent sources on child\n sources when the child is added and active.  This ensures that the source is\n properly activated if the parent is active.\n\n @returns true if source can be added, false if it causes recursion"]
    pub fn obs_source_add_active_child(parent: *mut obs_source_t, child: *mut obs_source_t) -> bool;
    #[doc = " Removes an active child source.  Must be called by parent sources on child\n sources when the child is removed or inactive.  This ensures that the source\n is properly deactivated if the parent is no longer active."]
    pub fn obs_source_remove_active_child(parent: *mut obs_source_t, child: *mut obs_source_t);
    #[doc = " Sends a mouse down/up event to a source"]
    pub fn obs_source_send_mouse_click(
        source: *mut obs_source_t,
        event: *const obs_mouse_event,
        type_: i32,
        mouse_up: bool,
        click_count: u32,
    );
    #[doc = " Sends a mouse move event to a source."]
    pub fn obs_source_send_mouse_move(source: *mut obs_source_t, event: *const obs_mouse_event, mouse_leave: bool);
    #[doc = " Sends a mouse wheel event to a source"]
    pub fn obs_source_send_mouse_wheel(
        source: *mut obs_source_t,
        event: *const obs_mouse_event,
        x_delta: ::std::os::raw::c_int,
        y_delta: ::std::os::raw::c_int,
    );
    #[doc = " Sends a got-focus or lost-focus event to a source"]
    pub fn obs_source_send_focus(source: *mut obs_source_t, focus: bool);
    #[doc = " Sends a key up/down event to a source"]
    pub fn obs_source_send_key_click(source: *mut obs_source_t, event: *const obs_key_event, key_up: bool);
    #[doc = " Sets the default source flags."]
    pub fn obs_source_set_default_flags(source: *mut obs_source_t, flags: u32);
    #[doc = " Gets the base width for a source (not taking in to account filtering)"]
    pub fn obs_source_get_base_width(source: *mut obs_source_t) -> u32;
    #[doc = " Gets the base height for a source (not taking in to account filtering)"]
    pub fn obs_source_get_base_height(source: *mut obs_source_t) -> u32;
    pub fn obs_source_audio_pending(source: *const obs_source_t) -> bool;
    pub fn obs_source_get_audio_timestamp(source: *const obs_source_t) -> u64;
    pub fn obs_source_get_audio_mix(source: *const obs_source_t, audio: *mut obs_source_audio_mix);
    pub fn obs_source_set_async_unbuffered(source: *mut obs_source_t, unbuffered: bool);
    pub fn obs_source_async_unbuffered(source: *const obs_source_t) -> bool;
    #[doc = " Used to decouple audio from video so that audio doesn't attempt to sync up\n with video.  I.E. Audio acts independently.  Only works when in unbuffered\n mode."]
    pub fn obs_source_set_async_decoupled(source: *mut obs_source_t, decouple: bool);
    pub fn obs_source_async_decoupled(source: *const obs_source_t) -> bool;
    pub fn obs_source_set_audio_active(source: *mut obs_source_t, show: bool);
    pub fn obs_source_audio_active(source: *const obs_source_t) -> bool;
    pub fn obs_source_get_last_obs_version(source: *const obs_source_t) -> u32;
    #[doc = " Media controls"]
    pub fn obs_source_media_play_pause(source: *mut obs_source_t, pause: bool);
    pub fn obs_source_media_restart(source: *mut obs_source_t);
    pub fn obs_source_media_stop(source: *mut obs_source_t);
    pub fn obs_source_media_next(source: *mut obs_source_t);
    pub fn obs_source_media_previous(source: *mut obs_source_t);
    pub fn obs_source_media_get_duration(source: *mut obs_source_t) -> i64;
    pub fn obs_source_media_get_time(source: *mut obs_source_t) -> i64;
    pub fn obs_source_media_set_time(source: *mut obs_source_t, ms: i64);
    pub fn obs_source_media_get_state(source: *mut obs_source_t) -> obs_media_state;
    pub fn obs_source_media_started(source: *mut obs_source_t);
    pub fn obs_source_media_ended(source: *mut obs_source_t);
    pub fn obs_transition_get_source(transition: *mut obs_source_t, target: obs_transition_target)
        -> *mut obs_source_t;
    pub fn obs_transition_clear(transition: *mut obs_source_t);
    pub fn obs_transition_get_active_source(transition: *mut obs_source_t) -> *mut obs_source_t;
    pub fn obs_transition_start(
        transition: *mut obs_source_t,
        mode: obs_transition_mode,
        duration_ms: u32,
        dest: *mut obs_source_t,
    ) -> bool;
    pub fn obs_transition_set(transition: *mut obs_source_t, source: *mut obs_source_t);
    pub fn obs_transition_set_manual_time(transition: *mut obs_source_t, t: f32);
    pub fn obs_transition_set_manual_torque(transition: *mut obs_source_t, torque: f32, clamp: f32);
    pub fn obs_transition_set_scale_type(transition: *mut obs_source_t, type_: obs_transition_scale_type);
    pub fn obs_transition_get_scale_type(transition: *const obs_source_t) -> obs_transition_scale_type;
    pub fn obs_transition_set_alignment(transition: *mut obs_source_t, alignment: u32);
    pub fn obs_transition_get_alignment(transition: *const obs_source_t) -> u32;
    pub fn obs_transition_set_size(transition: *mut obs_source_t, cx: u32, cy: u32);
    pub fn obs_transition_get_size(transition: *const obs_source_t, cx: *mut u32, cy: *mut u32);
    #[doc = " Enables fixed transitions (videos or specific types of transitions that\n are of fixed duration and linearly interpolated"]
    pub fn obs_transition_enable_fixed(transition: *mut obs_source_t, enable: bool, duration_ms: u32);
    pub fn obs_transition_fixed(transition: *mut obs_source_t) -> bool;
    pub fn obs_transition_get_time(transition: *mut obs_source_t) -> f32;
    pub fn obs_transition_force_stop(transition: *mut obs_source_t);
    pub fn obs_transition_video_render(transition: *mut obs_source_t, callback: obs_transition_video_render_callback_t);
    pub fn obs_transition_video_render2(
        transition: *mut obs_source_t,
        callback: obs_transition_video_render_callback_t,
        placeholder_texture: *mut gs_texture_t,
    );
    pub fn obs_transition_video_get_color_space(transition: *mut obs_source_t) -> gs_color_space;
    #[doc = " Directly renders its sub-source instead of to texture.  Returns false if no\n longer transitioning"]
    pub fn obs_transition_video_render_direct(transition: *mut obs_source_t, target: obs_transition_target) -> bool;
    pub fn obs_transition_audio_render(
        transition: *mut obs_source_t,
        ts_out: *mut u64,
        audio: *mut obs_source_audio_mix,
        mixers: u32,
        channels: usize,
        sample_rate: usize,
        mix_a_callback: obs_transition_audio_mix_callback_t,
        mix_b_callback: obs_transition_audio_mix_callback_t,
    ) -> bool;
    pub fn obs_transition_swap_begin(tr_dest: *mut obs_source_t, tr_source: *mut obs_source_t);
    pub fn obs_transition_swap_end(tr_dest: *mut obs_source_t, tr_source: *mut obs_source_t);
    #[doc = " Creates a scene.\n\n   A scene is a source which is a container of other sources with specific\n display orientations.  Scenes can also be used like any other source."]
    pub fn obs_scene_create(name: *const ::std::os::raw::c_char) -> *mut obs_scene_t;
    pub fn obs_scene_create_private(name: *const ::std::os::raw::c_char) -> *mut obs_scene_t;
    #[doc = " Duplicates a scene."]
    pub fn obs_scene_duplicate(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
        type_: obs_scene_duplicate_type,
    ) -> *mut obs_scene_t;
    pub fn obs_scene_addref(scene: *mut obs_scene_t);
    pub fn obs_scene_release(scene: *mut obs_scene_t);
    pub fn obs_scene_get_ref(scene: *mut obs_scene_t) -> *mut obs_scene_t;
    #[doc = " Gets the scene's source context"]
    pub fn obs_scene_get_source(scene: *const obs_scene_t) -> *mut obs_source_t;
    #[doc = " Gets the scene from its source, or NULL if not a scene"]
    pub fn obs_scene_from_source(source: *const obs_source_t) -> *mut obs_scene_t;
    #[doc = " Determines whether a source is within a scene"]
    pub fn obs_scene_find_source(scene: *mut obs_scene_t, name: *const ::std::os::raw::c_char) -> *mut obs_sceneitem_t;
    pub fn obs_scene_find_source_recursive(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_sceneitem_t;
    pub fn obs_scene_find_sceneitem_by_id(scene: *mut obs_scene_t, id: i64) -> *mut obs_sceneitem_t;
    #[doc = " Enumerates sources within a scene"]
    pub fn obs_scene_enum_items(
        scene: *mut obs_scene_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut obs_scene_t,
                arg2: *mut obs_sceneitem_t,
                arg3: *mut ::std::os::raw::c_void,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
    pub fn obs_scene_reorder_items(
        scene: *mut obs_scene_t,
        item_order: *const *mut obs_sceneitem_t,
        item_order_size: usize,
    ) -> bool;
    pub fn obs_scene_reorder_items2(
        scene: *mut obs_scene_t,
        item_order: *mut obs_sceneitem_order_info,
        item_order_size: usize,
    ) -> bool;
    pub fn obs_source_is_scene(source: *const obs_source_t) -> bool;
    #[doc = " Adds/creates a new scene item for a source"]
    pub fn obs_scene_add(scene: *mut obs_scene_t, source: *mut obs_source_t) -> *mut obs_sceneitem_t;
    pub fn obs_scene_atomic_update(
        scene: *mut obs_scene_t,
        func: obs_scene_atomic_update_func,
        data: *mut ::std::os::raw::c_void,
    );
    pub fn obs_sceneitem_addref(item: *mut obs_sceneitem_t);
    pub fn obs_sceneitem_release(item: *mut obs_sceneitem_t);
    #[doc = " Removes a scene item."]
    pub fn obs_sceneitem_remove(item: *mut obs_sceneitem_t);
    #[doc = " Adds a scene item."]
    pub fn obs_sceneitems_add(scene: *mut obs_scene_t, data: *mut obs_data_array_t);
    #[doc = " Saves Sceneitem into an array, arr"]
    pub fn obs_sceneitem_save(item: *mut obs_sceneitem_t, arr: *mut obs_data_array_t);
    #[doc = " Set the ID of a sceneitem"]
    pub fn obs_sceneitem_set_id(sceneitem: *mut obs_sceneitem_t, id: i64);
    #[doc = " Tries to find the sceneitem of the source in a given scene. Returns NULL if not found"]
    pub fn obs_scene_sceneitem_from_source(scene: *mut obs_scene_t, source: *mut obs_source_t) -> *mut obs_sceneitem_t;
    #[doc = " Save all the transform states for a current scene's sceneitems"]
    pub fn obs_scene_save_transform_states(scene: *mut obs_scene_t, all_items: bool) -> *mut obs_data_t;
    #[doc = " Load all the transform states of sceneitems in that scene"]
    pub fn obs_scene_load_transform_states(state: *const ::std::os::raw::c_char);
    #[doc = "  Gets a sceneitem's order in its scene"]
    pub fn obs_sceneitem_get_order_position(item: *mut obs_sceneitem_t) -> ::std::os::raw::c_int;
    #[doc = " Gets the scene parent associated with the scene item."]
    pub fn obs_sceneitem_get_scene(item: *const obs_sceneitem_t) -> *mut obs_scene_t;
    #[doc = " Gets the source of a scene item."]
    pub fn obs_sceneitem_get_source(item: *const obs_sceneitem_t) -> *mut obs_source_t;
    pub fn obs_sceneitem_select(item: *mut obs_sceneitem_t, select: bool);
    pub fn obs_sceneitem_selected(item: *const obs_sceneitem_t) -> bool;
    pub fn obs_sceneitem_locked(item: *const obs_sceneitem_t) -> bool;
    pub fn obs_sceneitem_set_locked(item: *mut obs_sceneitem_t, lock: bool) -> bool;
    pub fn obs_sceneitem_set_pos(item: *mut obs_sceneitem_t, pos: *const vec2);
    pub fn obs_sceneitem_set_rot(item: *mut obs_sceneitem_t, rot_deg: f32);
    pub fn obs_sceneitem_set_scale(item: *mut obs_sceneitem_t, scale: *const vec2);
    pub fn obs_sceneitem_set_alignment(item: *mut obs_sceneitem_t, alignment: u32);
    pub fn obs_sceneitem_set_order(item: *mut obs_sceneitem_t, movement: obs_order_movement);
    pub fn obs_sceneitem_set_order_position(item: *mut obs_sceneitem_t, position: ::std::os::raw::c_int);
    pub fn obs_sceneitem_set_bounds_type(item: *mut obs_sceneitem_t, type_: obs_bounds_type);
    pub fn obs_sceneitem_set_bounds_alignment(item: *mut obs_sceneitem_t, alignment: u32);
    pub fn obs_sceneitem_set_bounds_crop(item: *mut obs_sceneitem_t, crop: bool);
    pub fn obs_sceneitem_set_bounds(item: *mut obs_sceneitem_t, bounds: *const vec2);
    pub fn obs_sceneitem_get_id(item: *const obs_sceneitem_t) -> i64;
    pub fn obs_sceneitem_get_pos(item: *const obs_sceneitem_t, pos: *mut vec2);
    pub fn obs_sceneitem_get_rot(item: *const obs_sceneitem_t) -> f32;
    pub fn obs_sceneitem_get_scale(item: *const obs_sceneitem_t, scale: *mut vec2);
    pub fn obs_sceneitem_get_alignment(item: *const obs_sceneitem_t) -> u32;
    pub fn obs_sceneitem_get_bounds_type(item: *const obs_sceneitem_t) -> obs_bounds_type;
    pub fn obs_sceneitem_get_bounds_alignment(item: *const obs_sceneitem_t) -> u32;
    pub fn obs_sceneitem_get_bounds_crop(item: *const obs_sceneitem_t) -> bool;
    pub fn obs_sceneitem_get_bounds(item: *const obs_sceneitem_t, bounds: *mut vec2);
    pub fn obs_sceneitem_get_info(item: *const obs_sceneitem_t, info: *mut obs_transform_info);
    pub fn obs_sceneitem_set_info(item: *mut obs_sceneitem_t, info: *const obs_transform_info);
    pub fn obs_sceneitem_get_info2(item: *const obs_sceneitem_t, info: *mut obs_transform_info);
    pub fn obs_sceneitem_set_info2(item: *mut obs_sceneitem_t, info: *const obs_transform_info);
    pub fn obs_sceneitem_get_draw_transform(item: *const obs_sceneitem_t, transform: *mut matrix4);
    pub fn obs_sceneitem_get_box_transform(item: *const obs_sceneitem_t, transform: *mut matrix4);
    pub fn obs_sceneitem_get_box_scale(item: *const obs_sceneitem_t, scale: *mut vec2);
    pub fn obs_sceneitem_visible(item: *const obs_sceneitem_t) -> bool;
    pub fn obs_sceneitem_set_visible(item: *mut obs_sceneitem_t, visible: bool) -> bool;
    pub fn obs_sceneitem_set_crop(item: *mut obs_sceneitem_t, crop: *const obs_sceneitem_crop);
    pub fn obs_sceneitem_get_crop(item: *const obs_sceneitem_t, crop: *mut obs_sceneitem_crop);
    pub fn obs_sceneitem_set_scale_filter(item: *mut obs_sceneitem_t, filter: obs_scale_type);
    pub fn obs_sceneitem_get_scale_filter(item: *mut obs_sceneitem_t) -> obs_scale_type;
    pub fn obs_sceneitem_set_blending_method(item: *mut obs_sceneitem_t, method: obs_blending_method);
    pub fn obs_sceneitem_get_blending_method(item: *mut obs_sceneitem_t) -> obs_blending_method;
    pub fn obs_sceneitem_set_blending_mode(item: *mut obs_sceneitem_t, type_: obs_blending_type);
    pub fn obs_sceneitem_get_blending_mode(item: *mut obs_sceneitem_t) -> obs_blending_type;
    pub fn obs_sceneitem_force_update_transform(item: *mut obs_sceneitem_t);
    pub fn obs_sceneitem_defer_update_begin(item: *mut obs_sceneitem_t);
    pub fn obs_sceneitem_defer_update_end(item: *mut obs_sceneitem_t);
    #[doc = " Gets private front-end settings data.  This data is saved/loaded\n automatically.  Returns an incremented reference."]
    pub fn obs_sceneitem_get_private_settings(item: *mut obs_sceneitem_t) -> *mut obs_data_t;
    pub fn obs_scene_add_group(scene: *mut obs_scene_t, name: *const ::std::os::raw::c_char) -> *mut obs_sceneitem_t;
    pub fn obs_scene_insert_group(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
        items: *mut *mut obs_sceneitem_t,
        count: usize,
    ) -> *mut obs_sceneitem_t;
    pub fn obs_scene_add_group2(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
        signal: bool,
    ) -> *mut obs_sceneitem_t;
    pub fn obs_scene_insert_group2(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
        items: *mut *mut obs_sceneitem_t,
        count: usize,
        signal: bool,
    ) -> *mut obs_sceneitem_t;
    pub fn obs_scene_get_group(scene: *mut obs_scene_t, name: *const ::std::os::raw::c_char) -> *mut obs_sceneitem_t;
    pub fn obs_sceneitem_is_group(item: *mut obs_sceneitem_t) -> bool;
    pub fn obs_sceneitem_group_get_scene(group: *const obs_sceneitem_t) -> *mut obs_scene_t;
    pub fn obs_sceneitem_group_ungroup(group: *mut obs_sceneitem_t);
    pub fn obs_sceneitem_group_ungroup2(group: *mut obs_sceneitem_t, signal: bool);
    pub fn obs_sceneitem_group_add_item(group: *mut obs_sceneitem_t, item: *mut obs_sceneitem_t);
    pub fn obs_sceneitem_group_remove_item(group: *mut obs_sceneitem_t, item: *mut obs_sceneitem_t);
    pub fn obs_sceneitem_get_group(scene: *mut obs_scene_t, item: *mut obs_sceneitem_t) -> *mut obs_sceneitem_t;
    pub fn obs_source_is_group(source: *const obs_source_t) -> bool;
    pub fn obs_scene_is_group(scene: *const obs_scene_t) -> bool;
    pub fn obs_sceneitem_group_enum_items(
        group: *mut obs_sceneitem_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut obs_scene_t,
                arg2: *mut obs_sceneitem_t,
                arg3: *mut ::std::os::raw::c_void,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
    #[doc = " Gets the group from its source, or NULL if not a group"]
    pub fn obs_group_from_source(source: *const obs_source_t) -> *mut obs_scene_t;
    pub fn obs_sceneitem_defer_group_resize_begin(item: *mut obs_sceneitem_t);
    pub fn obs_sceneitem_defer_group_resize_end(item: *mut obs_sceneitem_t);
    pub fn obs_sceneitem_set_show_transition(item: *mut obs_sceneitem_t, transition: *mut obs_source_t);
    pub fn obs_sceneitem_set_show_transition_duration(item: *mut obs_sceneitem_t, duration_ms: u32);
    pub fn obs_sceneitem_get_show_transition(item: *mut obs_sceneitem_t) -> *mut obs_source_t;
    pub fn obs_sceneitem_get_show_transition_duration(item: *mut obs_sceneitem_t) -> u32;
    pub fn obs_sceneitem_set_hide_transition(item: *mut obs_sceneitem_t, transition: *mut obs_source_t);
    pub fn obs_sceneitem_set_hide_transition_duration(item: *mut obs_sceneitem_t, duration_ms: u32);
    pub fn obs_sceneitem_get_hide_transition(item: *mut obs_sceneitem_t) -> *mut obs_source_t;
    pub fn obs_sceneitem_get_hide_transition_duration(item: *mut obs_sceneitem_t) -> u32;
    pub fn obs_sceneitem_set_transition(item: *mut obs_sceneitem_t, show: bool, transition: *mut obs_source_t);
    pub fn obs_sceneitem_get_transition(item: *mut obs_sceneitem_t, show: bool) -> *mut obs_source_t;
    pub fn obs_sceneitem_set_transition_duration(item: *mut obs_sceneitem_t, show: bool, duration_ms: u32);
    pub fn obs_sceneitem_get_transition_duration(item: *mut obs_sceneitem_t, show: bool) -> u32;
    pub fn obs_sceneitem_do_transition(item: *mut obs_sceneitem_t, visible: bool);
    pub fn obs_sceneitem_transition_load(item: *mut obs_scene_item, data: *mut obs_data_t, show: bool);
    pub fn obs_sceneitem_transition_save(item: *mut obs_scene_item, show: bool) -> *mut obs_data_t;
    pub fn obs_scene_prune_sources(scene: *mut obs_scene_t);
    pub fn obs_output_get_display_name(id: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
    #[doc = " Creates an output.\n\n   Outputs allow outputting to file, outputting to network, outputting to\n directshow, or other custom outputs."]
    pub fn obs_output_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_output_t;
    #[doc = " Adds/releases a reference to an output.  When the last reference is\n released, the output is destroyed."]
    pub fn obs_output_addref(output: *mut obs_output_t);
    pub fn obs_output_release(output: *mut obs_output_t);
    pub fn obs_weak_output_addref(weak: *mut obs_weak_output_t);
    pub fn obs_weak_output_release(weak: *mut obs_weak_output_t);
    pub fn obs_output_get_ref(output: *mut obs_output_t) -> *mut obs_output_t;
    pub fn obs_output_get_weak_output(output: *mut obs_output_t) -> *mut obs_weak_output_t;
    pub fn obs_weak_output_get_output(weak: *mut obs_weak_output_t) -> *mut obs_output_t;
    pub fn obs_weak_output_references_output(weak: *mut obs_weak_output_t, output: *mut obs_output_t) -> bool;
    pub fn obs_output_get_name(output: *const obs_output_t) -> *const ::std::os::raw::c_char;
    #[doc = " Starts the output."]
    pub fn obs_output_start(output: *mut obs_output_t) -> bool;
    #[doc = " Stops the output."]
    pub fn obs_output_stop(output: *mut obs_output_t);
    #[doc = " Sets the current output delay, in seconds (if the output supports delay).\n\n If delay is currently active, it will set the delay value, but will not\n affect the current delay, it will only affect the next time the output is\n activated."]
    pub fn obs_output_set_delay(output: *mut obs_output_t, delay_sec: u32, flags: u32);
    #[doc = " Gets the currently set delay value, in seconds."]
    pub fn obs_output_get_delay(output: *const obs_output_t) -> u32;
    #[doc = " If delay is active, gets the currently active delay value, in seconds."]
    pub fn obs_output_get_active_delay(output: *const obs_output_t) -> u32;
    #[doc = " Forces the output to stop.  Usually only used with delay."]
    pub fn obs_output_force_stop(output: *mut obs_output_t);
    #[doc = " Returns whether the output is active"]
    pub fn obs_output_active(output: *const obs_output_t) -> bool;
    #[doc = " Returns output capability flags"]
    pub fn obs_output_get_flags(output: *const obs_output_t) -> u32;
    #[doc = " Returns output capability flags"]
    pub fn obs_get_output_flags(id: *const ::std::os::raw::c_char) -> u32;
    #[doc = " Gets the default settings for an output type"]
    pub fn obs_output_defaults(id: *const ::std::os::raw::c_char) -> *mut obs_data_t;
    #[doc = " Returns the property list, if any.  Free with obs_properties_destroy"]
    pub fn obs_get_output_properties(id: *const ::std::os::raw::c_char) -> *mut obs_properties_t;
    #[doc = " Returns the property list of an existing output, if any.  Free with\n obs_properties_destroy"]
    pub fn obs_output_properties(output: *const obs_output_t) -> *mut obs_properties_t;
    #[doc = " Updates the settings for this output context"]
    pub fn obs_output_update(output: *mut obs_output_t, settings: *mut obs_data_t);
    #[doc = " Specifies whether the output can be paused"]
    pub fn obs_output_can_pause(output: *const obs_output_t) -> bool;
    #[doc = " Pauses the output (if the functionality is allowed by the output"]
    pub fn obs_output_pause(output: *mut obs_output_t, pause: bool) -> bool;
    #[doc = " Returns whether output is paused"]
    pub fn obs_output_paused(output: *const obs_output_t) -> bool;
    pub fn obs_output_get_settings(output: *const obs_output_t) -> *mut obs_data_t;
    #[doc = " Returns the signal handler for an output"]
    pub fn obs_output_get_signal_handler(output: *const obs_output_t) -> *mut signal_handler_t;
    #[doc = " Returns the procedure handler for an output"]
    pub fn obs_output_get_proc_handler(output: *const obs_output_t) -> *mut proc_handler_t;
    #[doc = " Sets the current audio/video media contexts associated with this output,\n required for non-encoded outputs.  Can be null."]
    pub fn obs_output_set_media(output: *mut obs_output_t, video: *mut video_t, audio: *mut audio_t);
    #[doc = " Returns the video media context associated with this output"]
    pub fn obs_output_video(output: *const obs_output_t) -> *mut video_t;
    #[doc = " Returns the audio media context associated with this output"]
    pub fn obs_output_audio(output: *const obs_output_t) -> *mut audio_t;
    #[doc = " Sets the current audio mixer for non-encoded outputs"]
    pub fn obs_output_set_mixer(output: *mut obs_output_t, mixer_idx: usize);
    #[doc = " Gets the current audio mixer for non-encoded outputs"]
    pub fn obs_output_get_mixer(output: *const obs_output_t) -> usize;
    #[doc = " Sets the current audio mixes (mask) for a non-encoded multi-track output"]
    pub fn obs_output_set_mixers(output: *mut obs_output_t, mixers: usize);
    #[doc = " Gets the current audio mixes (mask) for a non-encoded multi-track output"]
    pub fn obs_output_get_mixers(output: *const obs_output_t) -> usize;
    #[doc = " Sets the current video encoder associated with this output,\n required for encoded outputs"]
    pub fn obs_output_set_video_encoder(output: *mut obs_output_t, encoder: *mut obs_encoder_t);
    #[doc = " Sets the current video encoder associated with this output,\n required for encoded outputs.\n\n The idx parameter specifies the video encoder index.\n Only used with outputs that have multiple video outputs (FFmpeg typically),\n otherwise the parameter is ignored."]
    pub fn obs_output_set_video_encoder2(output: *mut obs_output_t, encoder: *mut obs_encoder_t, idx: usize);
    #[doc = " Sets the current audio encoder associated with this output,\n required for encoded outputs.\n\n The idx parameter specifies the audio encoder index to set the encoder to.\n Only used with outputs that have multiple audio outputs (RTMP typically),\n otherwise the parameter is ignored."]
    pub fn obs_output_set_audio_encoder(output: *mut obs_output_t, encoder: *mut obs_encoder_t, idx: usize);
    #[doc = " Returns the current video encoder associated with this output"]
    pub fn obs_output_get_video_encoder(output: *const obs_output_t) -> *mut obs_encoder_t;
    #[doc = " Returns the current video encoder associated with this output.\n\n The idx parameter specifies the video encoder index.\n Only used with outputs that have multiple video outputs (FFmpeg typically),\n otherwise specifying an idx > 0 returns a NULL."]
    pub fn obs_output_get_video_encoder2(output: *const obs_output_t, idx: usize) -> *mut obs_encoder_t;
    #[doc = " Returns the current audio encoder associated with this output\n\n The idx parameter specifies the audio encoder index.  Only used with\n outputs that have multiple audio outputs, otherwise the parameter is\n ignored."]
    pub fn obs_output_get_audio_encoder(output: *const obs_output_t, idx: usize) -> *mut obs_encoder_t;
    #[doc = " Sets the current service associated with this output."]
    pub fn obs_output_set_service(output: *mut obs_output_t, service: *mut obs_service_t);
    #[doc = " Gets the current service associated with this output."]
    pub fn obs_output_get_service(output: *const obs_output_t) -> *mut obs_service_t;
    #[doc = " Sets the reconnect settings.  Set retry_count to 0 to disable reconnecting."]
    pub fn obs_output_set_reconnect_settings(
        output: *mut obs_output_t,
        retry_count: ::std::os::raw::c_int,
        retry_sec: ::std::os::raw::c_int,
    );
    pub fn obs_output_get_total_bytes(output: *const obs_output_t) -> u64;
    pub fn obs_output_get_frames_dropped(output: *const obs_output_t) -> ::std::os::raw::c_int;
    pub fn obs_output_get_total_frames(output: *const obs_output_t) -> ::std::os::raw::c_int;
    #[doc = " Sets the preferred scaled resolution for this output.  Set width and height\n to 0 to disable scaling.\n\n If this output uses an encoder, it will call obs_encoder_set_scaled_size on\n the encoder before the stream is started.  If the encoder is already active,\n then this function will trigger a warning and do nothing."]
    pub fn obs_output_set_preferred_size(output: *mut obs_output_t, width: u32, height: u32);
    #[doc = " Sets the preferred scaled resolution for this output.  Set width and height\n to 0 to disable scaling.\n\n If this output uses an encoder, it will call obs_encoder_set_scaled_size on\n the encoder before the stream is started.  If the encoder is already active,\n then this function will trigger a warning and do nothing.\n\n The idx parameter specifies the video encoder index to apply the scaling to.\n Only used with outputs that have multiple video outputs (FFmpeg typically),\n otherwise the parameter is ignored."]
    pub fn obs_output_set_preferred_size2(output: *mut obs_output_t, width: u32, height: u32, idx: usize);
    #[doc = " For video outputs, returns the width of the encoded image"]
    pub fn obs_output_get_width(output: *const obs_output_t) -> u32;
    #[doc = " For video outputs, returns the width of the encoded image.\n\n The idx parameter specifies the video encoder index.\n Only used with outputs that have multiple video outputs (FFmpeg typically),\n otherwise the parameter is ignored and returns 0."]
    pub fn obs_output_get_width2(output: *const obs_output_t, idx: usize) -> u32;
    #[doc = " For video outputs, returns the height of the encoded image"]
    pub fn obs_output_get_height(output: *const obs_output_t) -> u32;
    #[doc = " For video outputs, returns the height of the encoded image.\n\n The idx parameter specifies the video encoder index.\n Only used with outputs that have multiple video outputs (FFmpeg typically),\n otherwise the parameter is ignored and returns 0."]
    pub fn obs_output_get_height2(output: *const obs_output_t, idx: usize) -> u32;
    pub fn obs_output_get_id(output: *const obs_output_t) -> *const ::std::os::raw::c_char;
    pub fn obs_output_caption(output: *mut obs_output_t, captions: *const obs_source_cea_708);
    pub fn obs_output_output_caption_text1(output: *mut obs_output_t, text: *const ::std::os::raw::c_char);
    pub fn obs_output_output_caption_text2(
        output: *mut obs_output_t,
        text: *const ::std::os::raw::c_char,
        display_duration: f64,
    );
    pub fn obs_output_get_congestion(output: *mut obs_output_t) -> f32;
    pub fn obs_output_get_connect_time_ms(output: *mut obs_output_t) -> ::std::os::raw::c_int;
    pub fn obs_output_reconnecting(output: *const obs_output_t) -> bool;
    #[doc = " Pass a string of the last output error, for UI use"]
    pub fn obs_output_set_last_error(output: *mut obs_output_t, message: *const ::std::os::raw::c_char);
    pub fn obs_output_get_last_error(output: *mut obs_output_t) -> *const ::std::os::raw::c_char;
    pub fn obs_output_get_supported_video_codecs(output: *const obs_output_t) -> *const ::std::os::raw::c_char;
    pub fn obs_output_get_supported_audio_codecs(output: *const obs_output_t) -> *const ::std::os::raw::c_char;
    pub fn obs_output_get_protocols(output: *const obs_output_t) -> *const ::std::os::raw::c_char;
    pub fn obs_is_output_protocol_registered(protocol: *const ::std::os::raw::c_char) -> bool;
    pub fn obs_enum_output_protocols(idx: usize, protocol: *mut *mut ::std::os::raw::c_char) -> bool;
    pub fn obs_enum_output_types_with_protocol(
        protocol: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
        enum_cb: ::std::option::Option<
            unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: *const ::std::os::raw::c_char) -> bool,
        >,
    );
    pub fn obs_get_output_supported_video_codecs(id: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
    pub fn obs_get_output_supported_audio_codecs(id: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
    pub fn obs_output_get_type_data(output: *mut obs_output_t) -> *mut ::std::os::raw::c_void;
    #[doc = " Gets the video conversion info.  Used only for raw output"]
    pub fn obs_output_get_video_conversion(output: *mut obs_output_t) -> *const video_scale_info;
    #[doc = " Optionally sets the video conversion info.  Used only for raw output"]
    pub fn obs_output_set_video_conversion(output: *mut obs_output_t, conversion: *const video_scale_info);
    #[doc = " Optionally sets the audio conversion info.  Used only for raw output"]
    pub fn obs_output_set_audio_conversion(output: *mut obs_output_t, conversion: *const audio_convert_info);
    #[doc = " Returns whether data capture can begin"]
    pub fn obs_output_can_begin_data_capture(output: *const obs_output_t, flags: u32) -> bool;
    #[doc = " Initializes encoders (if any)"]
    pub fn obs_output_initialize_encoders(output: *mut obs_output_t, flags: u32) -> bool;
    #[doc = " Begins data capture from media/encoders.\n\n @param  output  Output context\n @return         true if successful, false otherwise."]
    pub fn obs_output_begin_data_capture(output: *mut obs_output_t, flags: u32) -> bool;
    #[doc = " Ends data capture from media/encoders"]
    pub fn obs_output_end_data_capture(output: *mut obs_output_t);
    #[doc = " Signals that the output has stopped itself.\n\n @param  output  Output context\n @param  code    Error code (or OBS_OUTPUT_SUCCESS if not an error)"]
    pub fn obs_output_signal_stop(output: *mut obs_output_t, code: ::std::os::raw::c_int);
    pub fn obs_output_get_pause_offset(output: *mut obs_output_t) -> u64;
    pub fn obs_encoder_get_display_name(id: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
    #[doc = " Creates a video encoder context\n\n @param  id        Video encoder ID\n @param  name      Name to assign to this context\n @param  settings  Settings\n @return           The video encoder context, or NULL if failed or not found."]
    pub fn obs_video_encoder_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_encoder_t;
    #[doc = " Creates an audio encoder context\n\n @param  id        Audio Encoder ID\n @param  name      Name to assign to this context\n @param  settings  Settings\n @param  mixer_idx Index of the mixer to use for this audio encoder\n @return           The video encoder context, or NULL if failed or not found."]
    pub fn obs_audio_encoder_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        mixer_idx: usize,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_encoder_t;
    #[doc = " Adds/releases a reference to an encoder.  When the last reference is\n released, the encoder is destroyed."]
    pub fn obs_encoder_addref(encoder: *mut obs_encoder_t);
    pub fn obs_encoder_release(encoder: *mut obs_encoder_t);
    pub fn obs_weak_encoder_addref(weak: *mut obs_weak_encoder_t);
    pub fn obs_weak_encoder_release(weak: *mut obs_weak_encoder_t);
    pub fn obs_encoder_get_ref(encoder: *mut obs_encoder_t) -> *mut obs_encoder_t;
    pub fn obs_encoder_get_weak_encoder(encoder: *mut obs_encoder_t) -> *mut obs_weak_encoder_t;
    pub fn obs_weak_encoder_get_encoder(weak: *mut obs_weak_encoder_t) -> *mut obs_encoder_t;
    pub fn obs_weak_encoder_references_encoder(weak: *mut obs_weak_encoder_t, encoder: *mut obs_encoder_t) -> bool;
    pub fn obs_encoder_set_name(encoder: *mut obs_encoder_t, name: *const ::std::os::raw::c_char);
    pub fn obs_encoder_get_name(encoder: *const obs_encoder_t) -> *const ::std::os::raw::c_char;
    #[doc = " Returns the codec of an encoder by the id"]
    pub fn obs_get_encoder_codec(id: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
    #[doc = " Returns the type of an encoder by the id"]
    pub fn obs_get_encoder_type(id: *const ::std::os::raw::c_char) -> obs_encoder_type;
    #[doc = " Returns the codec of the encoder"]
    pub fn obs_encoder_get_codec(encoder: *const obs_encoder_t) -> *const ::std::os::raw::c_char;
    #[doc = " Returns the type of an encoder"]
    pub fn obs_encoder_get_type(encoder: *const obs_encoder_t) -> obs_encoder_type;
    #[doc = " Sets the scaled resolution for a video encoder.  Set width and height to 0\n to disable scaling.  If the encoder is active, this function will trigger\n a warning, and do nothing."]
    pub fn obs_encoder_set_scaled_size(encoder: *mut obs_encoder_t, width: u32, height: u32);
    #[doc = " Enable/disable GPU based scaling for a video encoder.\n OBS_SCALE_DISABLE disables GPU based scaling (default),\n any other value enables GPU based scaling. If the encoder\n is active, this function will trigger a warning, and do nothing."]
    pub fn obs_encoder_set_gpu_scale_type(encoder: *mut obs_encoder_t, gpu_scale_type: obs_scale_type);
    #[doc = " Set frame rate divisor for a video encoder. This allows recording at\n a partial frame rate compared to the base frame rate, e.g. 60 FPS with\n divisor = 2 will record at 30 FPS, with divisor = 3 at 20, etc.\n\n Can only be called on stopped encoders, changing this on the fly is not supported"]
    pub fn obs_encoder_set_frame_rate_divisor(encoder: *mut obs_encoder_t, divisor: u32) -> bool;
    #[doc = " Adds region of interest (ROI) for an encoder. This allows prioritizing\n quality of regions of the frame.\n If regions overlap, regions added earlier take precedence.\n\n Returns false if the encoder does not support ROI or region is invalid."]
    pub fn obs_encoder_add_roi(encoder: *mut obs_encoder_t, roi: *const obs_encoder_roi) -> bool;
    #[doc = " For video encoders, returns true if any ROIs were set"]
    pub fn obs_encoder_has_roi(encoder: *const obs_encoder_t) -> bool;
    #[doc = " Clear all regions"]
    pub fn obs_encoder_clear_roi(encoder: *mut obs_encoder_t);
    #[doc = " Enumerate regions with callback (reverse order of addition)"]
    pub fn obs_encoder_enum_roi(
        encoder: *mut obs_encoder_t,
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut obs_encoder_roi),
        >,
        param: *mut ::std::os::raw::c_void,
    );
    #[doc = " Get ROI increment, encoders must rebuild their ROI map if it has changed"]
    pub fn obs_encoder_get_roi_increment(encoder: *const obs_encoder_t) -> u32;
    #[doc = " For video encoders, returns true if pre-encode scaling is enabled"]
    pub fn obs_encoder_scaling_enabled(encoder: *const obs_encoder_t) -> bool;
    #[doc = " For video encoders, returns the width of the encoded image"]
    pub fn obs_encoder_get_width(encoder: *const obs_encoder_t) -> u32;
    #[doc = " For video encoders, returns the height of the encoded image"]
    pub fn obs_encoder_get_height(encoder: *const obs_encoder_t) -> u32;
    #[doc = " For video encoders, returns whether GPU scaling is enabled"]
    pub fn obs_encoder_gpu_scaling_enabled(encoder: *mut obs_encoder_t) -> bool;
    #[doc = " For video encoders, returns GPU scaling type"]
    pub fn obs_encoder_get_scale_type(encoder: *mut obs_encoder_t) -> obs_scale_type;
    #[doc = " For video encoders, returns the frame rate divisor (default is 1)"]
    pub fn obs_encoder_get_frame_rate_divisor(encoder: *const obs_encoder_t) -> u32;
    #[doc = " For audio encoders, returns the sample rate of the audio"]
    pub fn obs_encoder_get_sample_rate(encoder: *const obs_encoder_t) -> u32;
    #[doc = " For audio encoders, returns the frame size of the audio packet"]
    pub fn obs_encoder_get_frame_size(encoder: *const obs_encoder_t) -> usize;
    #[doc = " Sets the preferred video format for a video encoder.  If the encoder can use\n the format specified, it will force a conversion to that format if the\n obs output format does not match the preferred format.\n\n If the format is set to VIDEO_FORMAT_NONE, will revert to the default\n functionality of converting only when absolutely necessary."]
    pub fn obs_encoder_set_preferred_video_format(encoder: *mut obs_encoder_t, format: video_format);
    pub fn obs_encoder_get_preferred_video_format(encoder: *const obs_encoder_t) -> video_format;
    #[doc = " Gets the default settings for an encoder type"]
    pub fn obs_encoder_defaults(id: *const ::std::os::raw::c_char) -> *mut obs_data_t;
    pub fn obs_encoder_get_defaults(encoder: *const obs_encoder_t) -> *mut obs_data_t;
    #[doc = " Returns the property list, if any.  Free with obs_properties_destroy"]
    pub fn obs_get_encoder_properties(id: *const ::std::os::raw::c_char) -> *mut obs_properties_t;
    #[doc = " Returns the property list of an existing encoder, if any.  Free with\n obs_properties_destroy"]
    pub fn obs_encoder_properties(encoder: *const obs_encoder_t) -> *mut obs_properties_t;
    #[doc = " Updates the settings of the encoder context.  Usually used for changing\n bitrate while active"]
    pub fn obs_encoder_update(encoder: *mut obs_encoder_t, settings: *mut obs_data_t);
    #[doc = " Gets extra data (headers) associated with this context"]
    pub fn obs_encoder_get_extra_data(
        encoder: *const obs_encoder_t,
        extra_data: *mut *mut u8,
        size: *mut usize,
    ) -> bool;
    #[doc = " Returns the current settings for this encoder"]
    pub fn obs_encoder_get_settings(encoder: *const obs_encoder_t) -> *mut obs_data_t;
    #[doc = " Sets the video output context to be used with this encoder"]
    pub fn obs_encoder_set_video(encoder: *mut obs_encoder_t, video: *mut video_t);
    #[doc = " Sets the audio output context to be used with this encoder"]
    pub fn obs_encoder_set_audio(encoder: *mut obs_encoder_t, audio: *mut audio_t);
    #[doc = " Returns the video output context used with this encoder, or NULL if not\n a video context"]
    pub fn obs_encoder_video(encoder: *const obs_encoder_t) -> *mut video_t;
    #[doc = " Returns the parent video output context used with this encoder, or NULL if not\n a video context. Used when an FPS divisor is set, where the original video\n context would not otherwise be gettable."]
    pub fn obs_encoder_parent_video(encoder: *const obs_encoder_t) -> *mut video_t;
    #[doc = " Returns the audio output context used with this encoder, or NULL if not\n a audio context"]
    pub fn obs_encoder_audio(encoder: *const obs_encoder_t) -> *mut audio_t;
    #[doc = " Returns true if encoder is active, false otherwise"]
    pub fn obs_encoder_active(encoder: *const obs_encoder_t) -> bool;
    pub fn obs_encoder_get_type_data(encoder: *mut obs_encoder_t) -> *mut ::std::os::raw::c_void;
    pub fn obs_encoder_get_id(encoder: *const obs_encoder_t) -> *const ::std::os::raw::c_char;
    pub fn obs_get_encoder_caps(encoder_id: *const ::std::os::raw::c_char) -> u32;
    pub fn obs_encoder_get_caps(encoder: *const obs_encoder_t) -> u32;
    #[doc = " Duplicates an encoder packet"]
    pub fn obs_duplicate_encoder_packet(dst: *mut encoder_packet, src: *const encoder_packet);
    pub fn obs_free_encoder_packet(packet: *mut encoder_packet);
    pub fn obs_encoder_packet_ref(dst: *mut encoder_packet, src: *mut encoder_packet);
    pub fn obs_encoder_packet_release(packet: *mut encoder_packet);
    pub fn obs_encoder_create_rerouted(
        encoder: *mut obs_encoder_t,
        reroute_id: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
    #[doc = " Returns whether encoder is paused"]
    pub fn obs_encoder_paused(output: *const obs_encoder_t) -> bool;
    pub fn obs_encoder_get_last_error(encoder: *mut obs_encoder_t) -> *const ::std::os::raw::c_char;
    pub fn obs_encoder_set_last_error(encoder: *mut obs_encoder_t, message: *const ::std::os::raw::c_char);
    pub fn obs_encoder_get_pause_offset(encoder: *const obs_encoder_t) -> u64;
    #[doc = " Creates an \"encoder group\", allowing synchronized startup of encoders within\n the group. Encoder groups are single owner, and hold strong references to\n encoders within the group. Calling destroy on an active group will not actually\n destroy the group until it becomes completely inactive."]
    pub fn obs_encoder_set_group(encoder: *mut obs_encoder_t, group: *mut obs_encoder_group_t) -> bool;
    pub fn obs_encoder_group_create() -> *mut obs_encoder_group_t;
    pub fn obs_encoder_group_destroy(group: *mut obs_encoder_group_t);
    pub fn obs_service_get_display_name(id: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
    pub fn obs_service_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_service_t;
    pub fn obs_service_create_private(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
    ) -> *mut obs_service_t;
    #[doc = " Adds/releases a reference to a service.  When the last reference is\n released, the service is destroyed."]
    pub fn obs_service_addref(service: *mut obs_service_t);
    pub fn obs_service_release(service: *mut obs_service_t);
    pub fn obs_weak_service_addref(weak: *mut obs_weak_service_t);
    pub fn obs_weak_service_release(weak: *mut obs_weak_service_t);
    pub fn obs_service_get_ref(service: *mut obs_service_t) -> *mut obs_service_t;
    pub fn obs_service_get_weak_service(service: *mut obs_service_t) -> *mut obs_weak_service_t;
    pub fn obs_weak_service_get_service(weak: *mut obs_weak_service_t) -> *mut obs_service_t;
    pub fn obs_weak_service_references_service(weak: *mut obs_weak_service_t, service: *mut obs_service_t) -> bool;
    pub fn obs_service_get_name(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
    #[doc = " Gets the default settings for a service"]
    pub fn obs_service_defaults(id: *const ::std::os::raw::c_char) -> *mut obs_data_t;
    #[doc = " Returns the property list, if any.  Free with obs_properties_destroy"]
    pub fn obs_get_service_properties(id: *const ::std::os::raw::c_char) -> *mut obs_properties_t;
    #[doc = " Returns the property list of an existing service context, if any.  Free with\n obs_properties_destroy"]
    pub fn obs_service_properties(service: *const obs_service_t) -> *mut obs_properties_t;
    #[doc = " Gets the service type"]
    pub fn obs_service_get_type(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
    #[doc = " Updates the settings of the service context"]
    pub fn obs_service_update(service: *mut obs_service_t, settings: *mut obs_data_t);
    #[doc = " Returns the current settings for this service"]
    pub fn obs_service_get_settings(service: *const obs_service_t) -> *mut obs_data_t;
    #[doc = " Returns the URL for this service context"]
    pub fn obs_service_get_url(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
    #[doc = " Returns the stream key (if any) for this service context"]
    pub fn obs_service_get_key(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
    #[doc = " Returns the username (if any) for this service context"]
    pub fn obs_service_get_username(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
    #[doc = " Returns the password (if any) for this service context"]
    pub fn obs_service_get_password(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
    #[doc = " Applies service-specific video encoder settings.\n\n @param  video_encoder_settings  Video encoder settings.  Optional.\n @param  audio_encoder_settings  Audio encoder settings.  Optional."]
    pub fn obs_service_apply_encoder_settings(
        service: *mut obs_service_t,
        video_encoder_settings: *mut obs_data_t,
        audio_encoder_settings: *mut obs_data_t,
    );
    pub fn obs_service_get_type_data(service: *mut obs_service_t) -> *mut ::std::os::raw::c_void;
    pub fn obs_service_get_id(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
    pub fn obs_service_get_supported_resolutions(
        service: *const obs_service_t,
        resolutions: *mut *mut obs_service_resolution,
        count: *mut usize,
    );
    pub fn obs_service_get_max_fps(service: *const obs_service_t, fps: *mut ::std::os::raw::c_int);
    pub fn obs_service_get_max_bitrate(
        service: *const obs_service_t,
        video_bitrate: *mut ::std::os::raw::c_int,
        audio_bitrate: *mut ::std::os::raw::c_int,
    );
    pub fn obs_service_get_supported_video_codecs(service: *const obs_service_t) -> *mut *const ::std::os::raw::c_char;
    pub fn obs_service_get_supported_audio_codecs(service: *const obs_service_t) -> *mut *const ::std::os::raw::c_char;
    pub fn obs_service_get_output_type(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
    #[doc = " Returns the protocol for this service context"]
    pub fn obs_service_get_protocol(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
    pub fn obs_service_get_preferred_output_type(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
    pub fn obs_service_get_connect_info(service: *const obs_service_t, type_: u32) -> *const ::std::os::raw::c_char;
    pub fn obs_service_can_try_to_connect(service: *const obs_service_t) -> bool;
    pub fn obs_source_frame_init(frame: *mut obs_source_frame, format: video_format, width: u32, height: u32);
    pub fn obs_source_frame_copy(dst: *mut obs_source_frame, src: *const obs_source_frame);
    pub fn obs_source_get_icon_type(id: *const ::std::os::raw::c_char) -> obs_icon_type;
}
